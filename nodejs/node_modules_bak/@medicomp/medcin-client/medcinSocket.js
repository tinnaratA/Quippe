/*** Created by pkarcher on 12/12/2014.*/
'use strict';

var medicomp = medicomp || require('./index');
var net = require('net');
//var Q = require ("Q");

var MedcinSocket = function(PropertyBagOrConfiguration, failOrSucceedFunction) {

  var host = PropertyBagOrConfiguration.host || '';
      host = host.toString() || '';
  var port = PropertyBagOrConfiguration.port || NaN;
  var actuallyConnect = !PropertyBagOrConfiguration.hasOwnProperty('actuallyConnect') ||
          PropertyBagOrConfiguration.actuallyConnect;


  var currentBuffer = null;
  var client = null; //(net.Socket)

  switch (typeof(port)) {
    case 'number':
      break;
    case 'string':
      port = parseInt(port);
      break;
    case 'object':
      port = parseInt(port.toString());
      break;
    default:
      port = NaN;
  }

  var doWeEvenTry = (host !== '' && ! isNaN(port));

  if (doWeEvenTry) {

  }

  var thisMedcinSocket = this;
  thisMedcinSocket.modularDataReturnFunction = failOrSucceedFunction;

  function connectToServer() {

    client = new net.Socket();
    //var deferred = Q.defer();
    client.on('error', function(e) {
      thisMedcinSocket.isConnected = false;
      client.destroy();
      if(typeof(thisMedcinSocket.modularDataReturnFunction) === 'function') {
        thisMedcinSocket.modularDataReturnFunction(e, null);
      }
    });
    client.connect(port, host, function() {
      thisMedcinSocket.isConnected = true;
      failOrSucceedFunction(null, 1);
    });

    client.on('end', function() {
      console.log('********************** End Event Fired For Some Reason **********************');
    });
    client.on('close', function() {
      thisMedcinSocket.isConnected = false;
    });
    var lengthWeAreTryingToAchieve = 0;
    var contentsWeGotSoFar = null;
    client.on('data', function(data) {
      try {
        if (contentsWeGotSoFar === null) {
          lengthWeAreTryingToAchieve = data.slice(2,6).readInt32BE(0);
          contentsWeGotSoFar = data;
        } else {
          contentsWeGotSoFar = Buffer.concat([contentsWeGotSoFar, data]);
        }

        if (contentsWeGotSoFar.length >= lengthWeAreTryingToAchieve) {
          var medicomp = medicomp || require('./index');
          var bufferToReturn = new medicomp.ResultBuffer(contentsWeGotSoFar);
          contentsWeGotSoFar = null;
          thisMedcinSocket.modularDataReturnFunction(null, bufferToReturn);
        }

      }
      catch (e) {
        thisMedcinSocket.modularDataReturnFunction(e, null);
      }

    });

  }

  this.setNoDelay = function(state) {
    client.setNoDelay(state);
  };

  this.setUpBuffer = function(bufferOrMethodId){
    if (typeof(bufferOrMethodId) === 'object') {
      currentBuffer = bufferOrMethodId;
    } else {
      currentBuffer = new medicomp.SocketBuffer(bufferOrMethodId);
    }
    return currentBuffer;
  };

  this.sendBufferContents = function(failOrSucceedFunction) {

    currentBuffer.wrapUpBuffer();
    var buffer = new Buffer(currentBuffer.bufferArray);
//    console.log("\r\n" + "--> buffer: " + buffer.toJSON().toString());
//    var ninja = "\r\n" + "--> buffer: " + buffer.toJSON().toString();
//    console.log (ninja);
//    setTimeout(function() {
//      client.pause();
//      client.resume();
//    client.setNoDelay(true);
      if (failOrSucceedFunction !== undefined) {
        thisMedcinSocket.modularDataReturnFunction = failOrSucceedFunction;
      }
    client.write(buffer, 'ascii'); //'utf8');
//    }, 500);

  };

  this.closeDown = function () {
    client.end();
    client.destroy();
  };

  this.host = host;
  this.port = port;
  this.doWeEvenTry = doWeEvenTry;
  this.actuallyTryToConnect = actuallyConnect;
  this.isConnected = null;

  if (actuallyConnect) {connectToServer();}


};



module.exports = MedcinSocket;