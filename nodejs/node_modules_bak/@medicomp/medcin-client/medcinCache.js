/*** Created by pkarcher on 1/23/2015. */
'use strict';

var medicomp = medicomp || require('./index');
var Q = require ('q');
var ServerCode = require('./ServerCodes');
medicomp.SocketBuffer = require('./medcinSocketBuffer');
var Validator = require('./medcinValidator');
//medicomp.Socket = require("./medcinSocket");


//var CodeSet  = {
//  None: 0,
//  CCC: 1,
//  Medispan: 2,
//  SNOMED: 3,
//  LabCorp: 4,
//  ICD10: 5,
//  ICD: 6,
//  ICD2: 7,
//  ICDOM: 8,
//  ICDOT: 9,
//  ICDH: 10,
//  ICDF: 11,
//  ICDNEC: 12,
//  ICDCAT: 13,
//  ICDALT: 14,
//  ICDOSpec: 15,
//  ICDOther: 16,
//  ICDProc: 17,
//  ACC: 18,
//  CPT: 19,
//  CPTMod: 20,
//  CPTAMod: 21,
//  HCPC: 22,
//  DSM: 23,
//  CAS: 24,
//  LOINC: 25,
//  CDT: 26,
//  ICDMan: 27,
//  FDB: 28,
//  Multum: 29,
//  Quest: 30,
//  RxNorm: 31,
//  CVX: 32,
//  UNII: 33,
//  CVXH: 36,
//  FirstConsult: 37,
//  NANDA: 38,
//  DODUC: 39
//};



var Cache = function (existingConnection) {

  var conn = existingConnection;

  var gettingCacheCodeValuesFor = null;
  var cacheCodesPromise = null;
  var codesList = null;
  var cachedCodes = null;

  this.getAllTheCodesInABigWad = function(medcinId, callbackFunction) {

    var validator = new Validator();
    medcinId = validator.int('medcinId', medcinId);

    if (gettingCacheCodeValuesFor !== medcinId) {
      createCacheCodesPromise(medcinId);
    }
    cacheCodesPromise.then(function(data, err) {

      try {
        if (err) {
          callbackFunction(err);
          return;
        }

        callbackFunction(null, cachedCodes);

      }
      catch (e) {
        callbackFunction(e);
      }

    });

  };



  this.getCodeLink = function(medcinId, codeSet, callbackFunction) {

    var validator = new Validator();
    medcinId = validator.int('medcinId', medcinId);
    codeSet = validator.int('codeSet', codeSet);

    if (gettingCacheCodeValuesFor !== medcinId) {
      createCacheCodesPromise(medcinId);
    }

    cacheCodesPromise.then(function() {

      try {

        var stringToReturn = cachedCodes.codeFromMedcin(codeSet);

        callbackFunction(null, stringToReturn);

      }
      catch (e) {
        callbackFunction(e);
      }

    }, function(err) {
      callbackFunction(err);
    });

  };


  function createCacheCodesPromise(newMedcinId) {

    var deferred = Q.defer();
    gettingCacheCodeValuesFor = newMedcinId;

    var buf = new medicomp.SocketBuffer(ServerCode.ClientCache);
    buf.pushInt(newMedcinId,'newMedcinId');
    buf.pushShort(1, 'indicator_codes');

    conn.socket.setUpBuffer(buf);

    conn.socket.sendBufferContents(function(err, buf) {
      if (err) {
        deferred.reject(err);
      }
      else {

        var lengthOfResults = buf.popShort();
        if (lengthOfResults < 14) {
          this.codeCount = 0;
          this.codeHaveType1 = 0;
          this.codeHaveType2 = 0;
          deferred.resolve(true);
          return;
        }

        if (buf.popInt() !== newMedcinId) {
          throw new Error('Something went very wrong.  Getting cache values didn\'t return the right medcinId');
        }

        buf.popInt(); // "code_link_offset", whatever that is.  Not used.

        this.codeCount = buf.popShort();
        this.codeHaveType1 = buf.popInt();
        this.codeHaveType2 = buf.popInt();
        buf.popByte();

        codesList = [];
        var codeTypes = [];
        var mapSets = [];

        if (this.codeCount === 0) {
          deferred.resolve(true);
          return;
        }
        for (var i = 0; i < this.codeCount; i++) {
          codeTypes[i] = buf.popInt();
          buf.popShort(); // skip the year
          if (buf.popInt() === 0) {
            codeTypes[i] = 0;
          }
          buf.popInt(); // ignore "hint_offset"
          buf.popInt(); // ignore "parm_offset"
          buf.popInt(); // ignore "spec_offset"
          mapSets[i] = buf.popShort();
          buf.popShort(); // ignore "endyear"
          buf.popInt(); // ignore "prop_offset"
          buf.popByte(); // ignore "flags"
        }
        for (i = 0; i < this.codeCount; i++) {
          if (codeTypes[i] !== 0) {
            var aCode = {};
            aCode.codeSet = codeTypes[i];
            aCode.mapSet = mapSets[i];
            aCode.code = buf.popString();
            codesList.push(aCode);
          }
        }

        var medicomp = medicomp || require('./index');

        cachedCodes = new medicomp.CachedCodes(newMedcinId, codesList);


        deferred.resolve(codesList);
      }
    });

    cacheCodesPromise = deferred.promise;
    cacheCodesPromise.ninja = 'taco';



  }




  var GettingCachePropertyValuesFor = null;
  var CachePropertiesPromise = null;

  this.getPropertyValuesPromise = function(medcinId) {

    medcinId = (new Validator()).int('medcinId', medcinId);  // checking this hear so validation happens even if
                                                             // we aren't getting new values.
    if (GettingCachePropertyValuesFor !== medcinId) {
      createCachePropertiesPromise(medcinId);
    }
    return CachePropertiesPromise;
  };

  function createCachePropertiesPromise(newMedcinId) {
    var deferred = Q.defer();
    GettingCachePropertyValuesFor = newMedcinId;

    var buf = new medicomp.SocketBuffer(ServerCode.ClientCache);
    buf.pushInt(newMedcinId,'newMedcinId');
    buf.pushShort(0, 'indicator_properties');

    conn.socket.setUpBuffer(buf);

    conn.socket.sendBufferContents(function(err, buf) {
      if (err) {
        deferred.reject(err);
      }
      else {

        var lengthOfResults = buf.popShort();
        if (lengthOfResults < 38) {
          deferred.resolve(true);
          return;
        }

        this.propertyValues = {
          medcinId : buf.popInt(),
          termType : buf.popByte(),
          rxCode : buf.popString(),
          testCode : buf.popString(),
          riskCode : buf.popString(),
          privacy : buf.popString(),
          complex : buf.popString(),
          nodeLevel : buf.popByte(),
          subs : buf.popString(),
          flag : buf.popShort(),
          eFlag : buf.popShort(),
          aFlags : buf.popShort(),
          caFlags : buf.popShort(),
          qFlags : buf.popShort(),
          gpFlags : buf.popShort(),

          nodeKey : buf.popShort(),
          specialty : buf.popShort(),
          unit : buf.popShort(),
          search : buf.popShort()
        };

        buf.popShort();
        this.propertyValues.nodeKey = (this.propertyValues.nodeKey === 0) ? null : buf.popString();
        this.propertyValues.specialty = (this.propertyValues.specialty === 0) ? null : buf.popString();
        this.propertyValues.unit = (this.propertyValues.unit === 0) ? null : buf.popString();
        this.propertyValues.search = (this.propertyValues.search === 0) ? null : buf.popString();

        deferred.resolve(this.propertyValues);
      }
    });
    CachePropertiesPromise = deferred.promise;
  }


};

module.exports = Cache;