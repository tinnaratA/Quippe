'use strict';

var specHelper = function () {

// ********** below here are settings to change to alter testing behavior **********
  //var test_host = 'romulus',
  //var test_host = '192.168.1.8',
  //var test_host = '192.168.12.182',
  //var test_host = 'PKarcher8770W',
  var testHost = 'romulus';
  var testPort = 8190;
  var doTimeConsumingConnectionFailureTests = true;
  var doExtraTestReporting = false;
// ********************

  var fs = require('fs');
  var parseString = require('xml2js').parseString;
  var Q = require ('q');

  var lastBatchOfParametersForPotentialReUse;

  var massageCallXmlObject = function(call, place, fileName) {
    // The library we're using to grock the xml scenarios, xml2js, puts the data into a nice handy
    // json object, but with a lot more layers and hoops to get to the data than would be handy.
    // So here we:
    //    A. rearrange the call data object to be simpler.
    // Also, the xml2js library kindof "pre-escapes" data it pulls in.  Meaning in the xml we might
    // specify as an expectation "foo\tbar", meaning foo + [tab] + bar, 7 characters.  But xml2js
    // pulls it in as foo + \ + tbar, 8 characters.  So, we:
    //    B. replace escape sequences in the string text with the intended values.

    // Here we massage the parameters.  We allow for some flexibility on whether there is a "params"
    // element around "param" elements.  Also, the call might have the "reuseParameters" attribute,
    // which means we reuse the parameters from the previous call except those explicit in this call
    // (with the "which" parameter), which will override the parameters inherited from the previous call.
    try {
      var paramsWeSeeForThisCall = [];
      if (call.params) {
          paramsWeSeeForThisCall = paramsWeSeeForThisCall.concat(call.params[0].param);
      }
      if (call.param) {
          paramsWeSeeForThisCall = paramsWeSeeForThisCall.concat(call.param);
      }

      if (call.$.reuseParameters) {
        var newArrayOfParams = lastBatchOfParametersForPotentialReUse.slice();
        paramsWeSeeForThisCall.forEach(function (value) {
          newArrayOfParams[value.$.which - 1] = value.$;
        });
        call.params = newArrayOfParams;
      } else {
        call.params = paramsWeSeeForThisCall;
        call.params.forEach(function (value, number, theArray) {
          theArray[number] = value.$;
        });
      }
      lastBatchOfParametersForPotentialReUse = call.params;
    }
    catch (e) {
      call.params = [];
    }

    function fixEscapeSequences(fromXML) {
      //      return fromXML.replace("\\''", "\'").replace("\\\"", "\"").replace("\\\\", "\\").replace("\\n", "\n")
      //        .replace("\\r", "\r").replace("\\t", "\t").replace("\\b", "\b").replace("\\f", "\f");
      return fromXML.split('\\t').join('\t').split('\\\\').join('\\'); // fromXML.replace("\\t", "\t").replace("\\\\", "\\", );
      // it occurs to me that my first stab above could have problems.  The plan now is to allow for each
      // hyper-escaping as it occurs.
    }

    if (call.expect !== undefined) {

      var newExpect = call.expect[0].$;
      var findingListConcepts;

      if ( call.expect[0].concepts !== undefined) {

        findingListConcepts = call.expect[0].concepts[0].concept;

        findingListConcepts.forEach(function(value, number, theArray) {

          theArray[number] = value.$;

          for (var p in theArray[number]) {
            if (theArray[number].hasOwnProperty(p)) {
              var _index = p.indexOf('_');
              if (_index > -1){
                var first = p.substr(0, _index);
                var second = p.substr(_index + 1, 1).toUpperCase();
                var third = p.substr(_index + 2);
                theArray[number][first + second + third] = theArray[number][p];
                delete theArray[number][p];
              }
            }
          }

        });

//          call.expect[0].$.concepts = findingListConcepts;

      } else {

        var callExpectType = 'boolean';
        if (newExpect) {
          if (!newExpect.type) {
              throw new Error('No expect element for call "'.concat(call.method, '", call #', call.place,
                  ' in "', call.file, '.'));
          }

          callExpectType = newExpect.type;
        }

        switch(callExpectType) {

          case 'number' :
            throw new Error('Get rid of \'number\' expect type in ' + fileName + '.xml file.');
          case 'integer' :
          case 'int' :
            newExpect.value = parseInt(newExpect.value);
            break;
          case 'float' :
            newExpect.value = parseFloat(newExpect.value);
            break;
          case 'boolean' :
            newExpect.value = true;
            break;
        }

      }

      call.expect = newExpect;

      call.expect.concepts = findingListConcepts;

      if (call.expect.type === 'string') {
        call.expect.value = fixEscapeSequences(call.expect.value);
      }

    }

    call.method = call.$.jsmethod;
    call.place = place;
    call.file = fileName;
    call.name = call.$.name;

    call.getArrayOfParameterValues = function() {
      var parameters = [];
      call.params.forEach(function(param) {
        switch(param.type) {
          case 'short' :
          case 'int' :
            parameters.push(parseInt(param.value));
            break;
          case 'double' :
            parameters.push(parseFloat(param.value));
            break;
          case 'string' :
            parameters.push(param.value);
            break;
          default:
            throw new Error('unrecognized param type ' + param.type);
        }
      });
      return parameters;

    };

    return call;
  };


  return {
    doTimeConsumingTests : doTimeConsumingConnectionFailureTests,
    doExtraTestReporting : doExtraTestReporting,
    testHost : testHost,
    testPort : testPort,
//    verboseTestResults : false,
    getTestConfiguration : function() {
      return {host : testHost,
              port : testPort,
              returnExtraTestInformation : true};
    },
    massageCallXmlObject : massageCallXmlObject,

    compareCallAndResult : function (call, returnedData) {

      function compareCallAndDataFindingList(call, returnedData) {

//        returnedData.should.not.be.null;
        if (call.expect.variance) {
          returnedData.length.should.be.lessThan(parseInt(call.expect.value) + call.expect.variance + 1);
          returnedData.length.should.be.greaterThan(parseInt(call.expect.value) - call.expect.variance - 1);
        } else {
          returnedData.length.should.equal(parseInt(call.expect.value));
        }

        call.expect.concepts.forEach(function(concept) {

          var gotIt = false;
          returnedData.forEach(function(finding) {
            var thisIsAMatch = false;
              /*jshint unused:true, eqnull:true */
            if (gotIt === false && concept.medcinId == finding.medcinId) { // jshint ignore:line
              thisIsAMatch = true;
              for (var requiredMatch in concept) {
                if (concept.hasOwnProperty(requiredMatch)) {
                  finding[requiredMatch].toString().should.equal(concept[requiredMatch],
                      'Expected Concept with medcinId ' + concept.medcinId + ' to have a ' + requiredMatch +
                      ' property of "' + concept[requiredMatch] + '".');
                }
              }
            }
            if (thisIsAMatch) {gotIt = true;}
          });
          // every concept listed in the test cases must be included in the results.
          gotIt.should.equal(true, 'In the finding list results for ' + call.name + ', a finding for medcinId #' +
            concept.medcinId + ' was expected but was not among the ' + returnedData.length + ' results.');
        });
      }


      if (call.expect === undefined) {return;}

      if (call.expect.type === 'finding_list') {
        compareCallAndDataFindingList(call, returnedData);
      } else {
        if (call.expect.variance) {
          returnedData.should.be.lessThan(parseInt(call.expect.value) + call.expect.variance + 1);
          returnedData.should.be.greaterThan(parseInt(call.expect.value) - call.expect.variance - 1);
        } else {
          returnedData.should.equal(call.expect.value);
        }

      }

    },

    getCallsFromFile : function (methodsFile) {

      var deferred = Q.defer();
      var pathToScenarios = __dirname + '\\..\\..\\..\\test scenarios\\';
      fs.readFile(pathToScenarios + methodsFile + '.xml', 'utf-8', function (error, text) {
        if (error) {
          deferred.reject(error);
        } else {
          parseString(text, function (err, result) {
            if (error) {
              deferred.reject(error);
            } else {
              var calls = result.calls.call;
              calls.forEach(function (call, counter) {
                massageCallXmlObject(call, counter + 1, methodsFile);
              });
              deferred.resolve(calls);
            }
          });
        }
      });

      return deferred.promise;
    },

    createPromiseError : function (message, relevantCall) {
      if (relevantCall !== undefined) {
          message = message + '  (' + relevantCall.file + '.xml, call #' + relevantCall.place + ')';
      }
      var deferred = Q.defer();
      deferred.reject(new Error(message));
      return deferred.promise;

    }


};

};

module.exports = specHelper();