/*** Created by pkarcher on 1/13/2015.*/
'use strict';

//var should = require("should");
//var fs = require('fs');
//var parseString = require('xml2js').parseString;
var Q = require ('q');
var specHelper = require('../SpecHelper');
//require(__dirname + '/../../connection');
var medicomp = medicomp || require(__dirname + '/../../index');

describe('(int) scenario method Tests', function () {

  var conn;

  var whatWasCalled = { totalCalls : 0,
                        viaPromise : 0,
                        viaCallback : 0};

  it('standalone_methods', function(done) {
    runMethods('standalone_methods', done);
  });

  it('getcode_methods', function(done) {
    runMethods('getcode_methods', done);
  });

  it('cachedproperty_methods', function(done) {
    runMethods('cachedproperty_methods', done);
  });

  it('cachedcode_methods', function(done) {
    runMethods('cachedcode_methods', done);
  });

  it('grouped_methods', function(done) {
    runMethods('grouped_methods', done);
  });

  it('encounter_methods', function(done) {
    runMethods('encounter_methods', done);
  });

  it('all the calls were called both ways', function() {
    if (whatWasCalled.totalCalls !== whatWasCalled.viaPromise) {
      throw new Error ('There were ' + whatWasCalled.totalCalls.toString() + ' scenario calls, but ' +
        whatWasCalled.viaPromise.toString() + ' calls were made using promises.');
    }
    if (whatWasCalled.totalCalls !== whatWasCalled.viaCallback) {
      throw new Error ('There were ' + whatWasCalled.totalCalls.toString() + ' scenario calls, but ' +
        whatWasCalled.viaCallback + ' calls were made using callback.');
    }
  });


  function callAndTestMethodWithCallbacks(call, functionToCallNextThing, done) {

    whatWasCalled.viaCallback++;

    var theMethod = conn[call.method];
    if (theMethod === undefined) {
      done('The medcin.Connection object currently does not have a "' + call.method + '" method.', call);
    }

    var sh = specHelper;

    function whatToDoWithTheResults(err, data) {
      if (err) {
        err.message = 'In (scenarios, callback versionAsync) ' + call.file + '.xml on ' + call.name + ': ' + err.message;
        done(err);
      } else {
        try {
          sh.compareCallAndResult(call, data);
          functionToCallNextThing();
        }
        catch (e) {
          e.message = 'In (scenarios, callback versionAsync) ' + call.file + '.xml on ' + call.name + ': ' + e.message;
          done(e);
        }
      }
    }

    var parameters = call.getArrayOfParameterValues().concat(whatToDoWithTheResults);

    conn[call.method].apply(conn, parameters);

  }


  function callTheFirstOneAndContinue(calls, done) {

    var callToCallNow = calls.shift();

    if (calls.length === 0) {
      callAndTestMethodWithCallbacks(callToCallNow, done, done);
    } else {
      callAndTestMethodWithCallbacks(callToCallNow, function() {
          callTheFirstOneAndContinue(calls, done);
        }, done);
    }

//    var functionToCallTheRest;
//    functionToCallTheRest = callTheFirstOneAndContinue(calls);

  }


  function runMethods(methodsFile, done) {

    conn = new medicomp.Connection(specHelper.getTestConfiguration());

    specHelper.getCallsFromFile(methodsFile).then(function(calls) {

      whatWasCalled.totalCalls = whatWasCalled.totalCalls + calls.length;

      var callsForCallbacks = calls.slice();

      runMethodsWithPromises(calls, function(problem) {
        if (problem) {
          done(problem);
        } else {
          runMethodsWithCallbacks(callsForCallbacks, done);
        }
      });


    }, function(err) {
      done(err);
    });

  }

  function runMethodsWithPromises(calls, done) {

    conn = new medicomp.Connection(specHelper.getTestConfiguration());

    conn.connectionPromise.then(function() {

      function setUpTheNextOne (lastPromise, arrayOfCalls, whichToSetUpNow, done) {
        lastPromise.then(function (){
          whatWasCalled.viaPromise++;
          var thisPromise = callAndTestMethod(arrayOfCalls[whichToSetUpNow]);
          if (whichToSetUpNow < arrayOfCalls.length - 1 ) {
            setUpTheNextOne(thisPromise, arrayOfCalls, whichToSetUpNow + 1, done);
          }
          else {
            thisPromise.then(function () {
              conn.medcinEnd().then(function () {
                done();
              });
            }, function (err) {
              //done(err);
              conn.medcinEnd().then(function () {
                done(err);
              });
            });
          }
        }, function(err){
          //done(err);
          conn.medcinEnd().then(function() {
            done(err);
          });
        });
      }

      whatWasCalled.viaPromise++;
      var firstPromise = callAndTestMethod(calls[0]);

      setUpTheNextOne(firstPromise, calls, 1, done);

    });

  }


  function runMethodsWithCallbacks(calls, done) {

    conn = new medicomp.Connection(specHelper.getTestConfiguration());

    conn.connectionPromise.then(function() {

      callTheFirstOneAndContinue(calls, done);

    });

  }



  function callAndTestMethod(call) {

    //if (call.file == "standalone_methods" && call.name == "code_from_medcin")
    //  var taco = "ninja";

    var parameters = call.getArrayOfParameterValues();
    var theMethod = conn[call.method];
    if (theMethod === undefined)
    //throw new Error("The connection object currently does not have a '" +
    //call.method + "' method.");
    {
        return specHelper.createPromiseError('The medcin.Connection object currently does not have a "' +
        call.method + '" method.', call);
    }
    var methodPromise = conn[call.method].apply(conn, parameters);

    var deferred = Q.defer();

    methodPromise.then(function(data) {
      try {
        specHelper.compareCallAndResult(call, data);
        deferred.resolve();
      }
      catch (e) {
        e.message = 'In (scenarios) ' + call.file + '.xml on ' + call.name + ': ' + e.message;
        deferred.reject(e);
      }
    }, function(err) {
      err.message = 'In (scenarios) ' + call.file + '.xml on ' + call.name + ': ' + err.message;
      deferred.reject(err);
    });

    return deferred.promise;

  }


});
