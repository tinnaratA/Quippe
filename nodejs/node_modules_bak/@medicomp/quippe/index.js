var express = require('express');
var edge = require('edge');
var path = require('path');
var requireDir = require('require-dir');
var q = require('q');
var rawBody = require('raw-body');
var fs = require('fs');
var pathToRegexp = require('path-to-regexp');
var util = require('util');
var http = require('http');
var url = require('url');
var zlib = require('zlib');
var https = require('https');

var wrapPromiseFunction = function (originalFunction) {
    return function (data, callback) {
        q.when(originalFunction(data), function (results) {
            callback(null, results);
        }, function(errors) {
            callback(errors);
        });
    };
};

var wrapCallbackFunction = function (originalFunction) {
    return function (data) {
        var deferred = q.defer();
        
        originalFunction(data, function (errors, results) {
            if (errors) {
                deferred.reject(errors);
            }

            else {
                deferred.resolve(results);
            }
        });
        
        return deferred.promise;
    };
};

function quippeApplication() {
    // summary:
    //     Middleware component to be used for Quippe when integrating it into [Connect](https://github.com/senchalabs/connect)-based Node.js applications.
    // description:
    //     `setup()` method should be called first, and the [q promise](https://github.com/kriskowal/q) that it returns should be awaited upon and then the
    //     middleware should be added to the application.
    // example:
    //  |	quippe.setup({
    //  |	    // Configuration settings
    //  |	}).then(function() {
    //  |	    app.use(quippe.middleware);
    //  |	}, function(errors) {
    //  |	    console.error("Error calling quippe.setup(): " + errors);
    //  |	    process.exit();
    //  |	});
    // services: Object
    //     Hash of service objects (both .NET and Node.js varieties) that are indexed by interface name.
    // routes: Object[]
    //     List of custom route handlers present in `config.routesDirectory`.

    this.services = {};
    this.routes = [];

    this.getService = function (serviceName, options) {
        // summary:
        //     Gets the service object for a particular interface (`serviceName`) that was registered with the `registerService()` method.
        // serviceName: String
        //     Name of the interface for which we are to retrieve the service, i.e. `Quippe.IFavoritesService` or `Quippe.IPatientSummaryService`.
        // options: Object
        //     Optional configuration options specifying which version of the service to return; this object can include the following properties:
        //
        //      - `usesPromises` (optional, defaults to `false`): Flag specifying whether the service returns a version of the service whose methods return
        //        [q-compatible promise](https://github.com/kriskowal/q) or accept a callback method as their second parameter.
        // returns: Object
        //     Returns the service object for the given interface (`serviceName`).
        options = util._extend({
            usesPromises: false
        }, options || {});

        return options.usesPromises ? this.services[serviceName].promiseService : this.services[serviceName].callbackService;
    };

    this.registerService = function (serviceNames, service, options) {
        // summary:
        //     Registers a data service implementation (`service`) for a given set of service interfaces (`serviceNames`) to be used by the Quippe .NET layer
        //     to store and retrieve data.
        // serviceNames: String|String[]
        //     Name(s) of the interface(s) that the service implements, i.e. `"Quippe.IFavoritesService"` or `['Quippe.IPatientSummaryService',
        //     'Quippe.IPatientHistoryService', 'Quippe.IEncounterIOService']`
        // service: Object
        //     Service object whose functions we are to call when we need to access any of the service interfaces.
        // options: Object
        //     Optional configuration options specifying metadata about the service; this object can include the following properties:
        //
        //      - `usesPromises` (optional, defaults to `false`): Flag specifying whether the service returns a 
        //        [q-compatible promise](https://github.com/kriskowal/q) or accepts a callback method as its second parameter.
        // description:
        //     Each of these functions in `service` should take one or two parameters: `data` and, if `options` is not specified or `options.usesPromises` is 
        //     false,  `callback`.  The ` data` parameter will contain a property for each parameter accepted by the method, plus an additional parameter 
        //     (`ContextData`) containing the security context information returned by `Quippe.IAuthorizationService.GetContextData()`. The `callback` 
        //     parameter is a callback function that must be invoked once the data service function has finished processing.  If `options.usesPromises` is set
        //     to true, the method should return a [q-compatible promise](https://github.com/kriskowal/q) representing ongoing async processing.
        //
        //     See the `DataServices.xml` file for a list of available interfaces to implement.
        var self = this;

        options = util._extend({
            usesPromises: false
        }, options || {});

        if (typeof serviceNames == 'string') {
            var serviceNamesList = [];
            serviceNamesList.push(serviceNames);

            serviceNames = serviceNamesList;
        }

        var promiseService = null;
        var callbackService = null;
        
        if (options.usesPromises) {
            promiseService = service;
            callbackService = {};

            for (property in service) {
                if (typeof(service[property]) != "function" || !service.hasOwnProperty(property)) {
                    continue;
                }

                callbackService[property] = wrapPromiseFunction(service[property]);
            }
        }

        else {
            callbackService = service;
            promiseService = {};

            for (property in service) {
                if (typeof (service[property]) != "function" || !service.hasOwnProperty(property)) {
                    continue;
                }
                
                promiseService[property] = wrapCallbackFunction(service[property]);
            }
        }

        for (var i = 0; i < serviceNames.length; i++) {
            this.logger.info('Node.js data provider registered for %s', serviceNames[i]);
        }

        this.registerServiceMethod({
            serviceNames: serviceNames,
            service: callbackService
        }, function (errors) {
            if (errors) {
                throw errors;
            }

            for (var x = 0; x < serviceNames.length; x++) {
                self.services[serviceNames[x]] = {
                    promiseService: promiseService,
                    callbackService: callbackService
                };
            }
        });
    };

    this.registerRoute = function (verb, path, callback) {
        // summary:
        //     Registers a web service route that the Quippe server should respond to.
        // description:
        //     The route can be an entirely new route specific for functionality in your app or it can be an existing route normally serviced by Quippe, in
        //     which case the Quippe .NET layer will not be invoked for that particular web service and your `callback` function will instead be responsible
        //     for responding to it.
        // verb: String
        //     The HTTP verb ("GET", "POST", etc.) that this route should respond to.
        // path: String
        //     The URL path for this route.  The path will automatically be prefixed with `quippe.config.webServicePrefix`, the setting for which was
        //     provided in the call to `quippe.setup()` and which defaults to "/ws.aspx".
        // callback: Function
        //     The callback function that will be invoked to respond to requests for this route.  This function must accept the same three parameters that
        //     standard [Connect](https://github.com/senchalabs/connect)-based middleware methods do:
        //
        //      - `request`: The request object.
        //      - `response`: The response object.
        //      - `next`: The next function in the routing call stack.
        this.logger.info('Custom route registered for %s', path);

        path = this.config.webServiceUrlPrefix + path.replace(new RegExp('{(.+?)}', 'gi'), ':$1');

        this.routes.push({
            path: path,
            pathRegexp: pathToRegexp(path),
            method: verb,
            callback: callback
        });
    };

    this.writeResponse = function (request, response, data, errors) {
        // summary:
        //     Writes the response data back to the client for a given request.
        // description:
        //     Should be called from custom routes in `config.routesDirectory` to write the response data back to the client.
        // request: Object
        //     The Connect request object.
        // response: Object
        //     The Connect response object.
        // data: Object
        //     The data to send back to the client.  Depending on the value of the `DataFormat` query string parameter, the data in the object will either be
        //     JSON or XML-serialized.
        // errors: Object
        //     Any errors that were encountered during processing.  If this parameter is set to a non-null value, the `data` parameter is ignored, the HTTP
        //     status is set to 500, and the contents of this parameter are written to the output stream.
        if (errors) {
            response.send(500, errors);
        }

        else {
            if (request.query.DataFormat && (request.query.DataFormat == 2 || request.query.DataFormat == 'JSON')) {
                response.end(JSON.stringify(data));
            }

            else if (request.query.DataFormat && (request.query.DataFormat == 3 || request.query.DataFormat == 'JSF')) {
                response.end(JSON.stringify(data, null, 4));
            }

            //else {
            //    var xmlBuilder = new xml2js.Builder();
            //    response.end(xmlBuilder.buildObject(data));
            //}
        }
    };

    this.setup = function (config) {
        // summary:
        //     Initializes the Quippe middleware layer for use with a [Connect](https://github.com/senchalabs/connect)-based Node.js server application.
        // description:
        //     Initializes all of the data service implementations in `config.servicesDirectory` and registers them with the Quippe .NET layer.  Also sets up a
        //     listener to respond to Quippe web service requests.
        // config: Object
        //     Configuration options for the initialization process; this object can include the following properties:
        //
        //      - `webServiceUrlPrefix` (optional, defaults to "/ws.aspx"):  URL prefix for routing that is applied to incoming Quippe web service requests.
        //      - `sdkSiteDirectory` (required): Path to the directory that contains the `bin` directory housing the SDK site .NET assemblies.
        //      - `servicesDirectory` (optional): Path to the directory that contains the data services implementations used by Quippe.
        //      - `routesDirectory` (optional): Path to the directory that contains any additional routes that should be responded to by the Quippe server.
        //      - `logger` (optional): Logging object to receive messages from the Quippe middleware.  It should implement `info()`, `warn()`, `error()`, and
        //        `debug()`  methods capable of receiving a string and format arguments in a manner identical to
        //        [util.format()](http://nodejs.org/api/util.html#util_util_format_format).  Most logging libraries (like
        //        [winston](https://github.com/flatiron/winston), which the sample server uses) already implement these methods.  This object will receive
        //        messages **ONLY** from the Quippe middleware layer; since you are responsible for implementing your own data providers, you can add your own
        //        logging logic to those classes.
        //      - `webConfigPath` (optional): Path to the web.config file that should be used for configuration information by the .NET assemblies.  If
        //        this is not specified, it defaults to the web.config file in the `sdkSiteDirectory`.
        //      - `fileUploadDirectory` (required): Temporary path where files uploaded through HTTP are stored.
        // returns: Promise
        //     Returns a [q promise](https://github.com/kriskowal/q) that will be fulfilled when the initialization process is complete.
        if (!config) {
            throw 'Non-null config parameter must be provided to quippe.setup()';
        }

        this.config = {
            webServiceUrlPrefix: '/ws.aspx',
            webConfigPath: path.join(config.sdkSiteDirectory, 'web.config')
        };

        this.config = util._extend(this.config, config);
        this.logger = config.logger ? config.logger : util._extend({
            debug: console.info
        }, console);

        this.logger.info('config.sdkSiteDirectory is: %s', this.config.sdkSiteDirectory);
        this.logger.info('config.dataDirectory is: %s', this.config.dataDirectory);
        this.logger.info('config.servicesDirectory is: %s', this.config.servicesDirectory);
        this.logger.info('config.routesDirectory is: %s', this.config.routesDirectory);
        this.logger.info('config.webConfigPath is: %s', this.config.webConfigPath);
        this.logger.info('config.fileUploadDirectory is: %s', this.config.fileUploadDirectory);

        if (!this.config.sdkSiteDirectory) {
            throw 'sdkSiteDirectory must be specified in the config parameter passed to quippe.setup()';
        }

        if (!this.config.dataDirectory) {
            throw 'dataDirectory must be specified in the config parameter passed to quippe.setup()';
        }

        if (!this.config.fileUploadDirectory) {
            throw 'fileUploadDirectory must be specified in the config parameter passed to quippe.setup()'
        }

        this.logger.info('Loading the .NET assembly methods');

        var setConfigFileMethod = edge.func({
            assemblyFile: path.join(this.config.sdkSiteDirectory, 'bin', 'Quippe.NodeJs.dll'),
            typeName: 'Quippe.NodeJs.WebMethods',
            methodName: 'SetConfigFile'
        });

        var setFileUploadPathMethod = edge.func({
            assemblyFile: path.join(this.config.sdkSiteDirectory, 'bin', 'Quippe.NodeJs.dll'),
            typeName: 'Quippe.NodeJs.WebMethods',
            methodName: 'SetFileUploadPath'
        });

        var addAssemblySearchPathMethod = edge.func({
            assemblyFile: path.join(this.config.sdkSiteDirectory, 'bin', 'Quippe.NodeJs.dll'),
            typeName: 'Quippe.NodeJs.WebMethods',
            methodName: 'AddAssemblySearchPath'
        });

        var getWebMethods = edge.func({
            assemblyFile: path.join(this.config.sdkSiteDirectory, 'bin', 'Quippe.NodeJs.dll'),
            typeName: 'Quippe.NodeJs.WebMethods',
            methodName: 'GetWebMethods'
        });

        this.callWebMethod = edge.func({
            assemblyFile: path.join(this.config.sdkSiteDirectory, 'bin', 'Quippe.NodeJs.dll'),
            typeName: 'Quippe.NodeJs.WebMethods',
            methodName: 'CallWebMethod'
        });

        this.registerServiceMethod = edge.func({
            assemblyFile: path.join(this.config.sdkSiteDirectory, 'bin', 'Quippe.NodeJs.dll'),
            typeName: 'Quippe.NodeJs.ServiceMethods',
            methodName: 'RegisterNodeJsService'
        });

        var deferred = q.defer();

        if (this.config.routesDirectory) {
            this.logger.info('Loading the user-defined routes from %s', this.config.routesDirectory);

            requireDir(this.config.routesDirectory, {
                recurse: true
            });
        }

        var callServiceMethod = edge.func({
            assemblyFile: path.join(this.config.sdkSiteDirectory, 'bin', 'Quippe.NodeJs.dll'),
            typeName: 'Quippe.NodeJs.ServiceMethods',
            methodName: 'CallServiceMethod'
        });

        var getServiceMethodStubJavaScript = edge.func({
            assemblyFile: path.join(this.config.sdkSiteDirectory, 'bin', 'Quippe.NodeJs.dll'),
            typeName: 'Quippe.NodeJs.ServiceMethods',
            methodName: 'GetServiceMethodStubJavaScript'
        });

        var self = this;

        this.logger.info('Setting the web.config file location for .NET to %s', this.config.webConfigPath);

        setConfigFileMethod({
            path: this.config.webConfigPath
        }, function (setConfigFileErrors) {
            if (setConfigFileErrors) {
                deferred.reject(setConfigFileErrors);
            }

            else {
                self.logger.info('Setting file upload path to %s', self.config.fileUploadDirectory);

                setFileUploadPathMethod({
                    path: self.config.fileUploadDirectory
                }, function(setFileUploadPathErrors) {
                    if (setFileUploadPathErrors) {
                        deferred.reject(setFileUploadPathErrors);
                    }

                    else {
                        self.logger.info('Adding %s as an assembly search location', path.join(self.config.sdkSiteDirectory, 'bin'));

                        addAssemblySearchPathMethod({
                            path: path.join(self.config.sdkSiteDirectory, 'bin')
                        }, function(addAssemblySearchPathErrors) {
                            if (addAssemblySearchPathErrors) {
                                deferred.reject(addAssemblySearchPathErrors);
                            }

                            else {
                                self.logger.info('Getting the call hooks for the .NET data providers');

                                getServiceMethodStubJavaScript({
                                    callServiceMethodName: 'callServiceMethod'
                                }, function(errors, result) {
                                    if (errors) {
                                        deferred.reject(errors);
                                    }

                                    else {
                                        var services = eval(result);

                                        for (var service in services) {
                                            self.services[service] = services[service];
                                        }

                                        if (self.config.servicesDirectory) {
                                            self.logger.info('Loading the Node.js data providers from %s', self.config.servicesDirectory);

                                            fs.readdirSync(self.config.servicesDirectory + '/').forEach(function(file) {
                                                if (file.match(/.+\.js$/ig) !== null) {
                                                    self.logger.info('Loading the data providers in %s', file);

                                                    var name = file.replace(/\.js$/i, '');
                                                    require(self.config.servicesDirectory + '/' + name);
                                                }
                                            });
                                        }

                                        getWebMethods(null, function(getWebMethodsError, getWebMethodsResult) {
                                            if (getWebMethodsError) {
                                                self.logger.error(getWebMethodsError);
                                                deferred.reject(getWebMethodsError);

                                                return;
                                            }

                                            var methods = getWebMethodsResult;

                                            for (var i = 0; i < methods.length; i++) {
                                                var path = self.config.webServiceUrlPrefix + methods[i].path.replace(new RegExp('{(.+?)}', 'gi'), ':$1');

                                                self.logger.info('Listening for requests to %s', path);

                                                self.routes.push({
                                                    path: path,
                                                    pathRegexp: pathToRegexp(path),
                                                    method: methods[i].method
                                                });
                                            }

                                            self.middleware = function(request, response, next) {
                                                var matchingRoute = null;

                                                for (var j = 0; j < self.routes.length; j++) {
                                                    if (self.routes[j].pathRegexp.test(request.path) && self.routes[j].method.toLowerCase() == request.method.toLowerCase()) {
                                                        self.logger.debug('Request path %s matched the endpoint for %s', request.path, self.routes[j].path);

                                                        matchingRoute = self.routes[j];
                                                        break;
                                                    }
                                                }

                                                if (!matchingRoute) {
                                                    self.logger.debug('Request path %s did not match any endpoints', request.path);
                                                    next();
                                                    return;
                                                }

                                                if (matchingRoute.callback) {
                                                    matchingRoute.callback(request, response, next);
                                                    return;
                                                }

                                                self.logger.debug('Processing request to %s', request.path);

                                                rawBody(request, {
                                                    length: request.headers['content-length'],
                                                    limit: '5mb'
                                                }, function(error, buffer) {
                                                    if (error) {
                                                        return next(error);
                                                    }

                                                    request.rawBody = buffer;
                                                    var requestHeaders = [];

                                                    for (var headerName in request.headers) {
                                                        self.logger.debug('Request HTTP header value: %s=%s', headerName, request.headers[headerName]);

                                                        requestHeaders.push({
                                                            name: headerName,
                                                            value: request.headers[headerName]
                                                        });
                                                    }

                                                    self.logger.debug('Calling into .NET to process the request');

                                                    self.callWebMethod({
                                                        method: request.method,
                                                        path: request._parsedUrl.pathname,
                                                        url: 'http://' + request.headers.host + request._parsedUrl.pathname,
                                                        queryString: request._parsedUrl.query,
                                                        requestBody: request.rawBody,
                                                        physicalPath: self.config.sdkSiteDirectory,
                                                        requestHeaders: requestHeaders,
                                                        webServiceUrlPrefix: self.config.webServiceUrlPrefix
                                                    }, function(webMethodError, webMethodResult) {
                                                        if (webMethodError) {
                                                            self.logger.error(util.format('Errors processing request to %s: %s', request.path, webMethodError));

                                                            response.status(500).send(webMethodError);
                                                            return next(webMethodError);
                                                        }

                                                        self.logger.debug('Request to %s succeeded (HTTP status code: %d, %d bytes of response data)', request.path, webMethodResult.status, webMethodResult.data.length);

                                                        for (var k = 0; k < webMethodResult.headers.length; k++) {
                                                            self.logger.debug('Response HTTP header value: %s=%s', webMethodResult.headers[k].name, webMethodResult.headers[k].value);
                                                            response.set(webMethodResult.headers[k].name, webMethodResult.headers[k].value);
                                                        }

                                                        response.status(webMethodResult.status).end(webMethodResult.data);
                                                        next();
                                                    });
                                                });
                                            };

                                            deferred.resolve();
                                        });
                                    }
                                });
                            }
                        });
                    }
                });
            }
        });

        return deferred.promise;
    };

    var thisProxyReference = this;

    this.proxyMiddleware = function (request, response, next) {
        // summary:
        //     Middleware component that proxies HTTP requests to remote URLs to get around CORS restrictions.
        // description:
        //     Requests to proxy should be sent over the URL in the format: `/proxy?[URL-encoded URL to send the request to]`.  The request body data of the
        //     incoming request is copied to the proxied request along with any headers prefixed with 'Proxy-Header-' (the 'Proxy-Header-' prefix is 
        //     stripped away in the outgoing proxy request).  If a 'Proxy-CopyHeaders' header is provided, we extract the list of headers from its comma-, 
        //     space-, or semicolon-separated list of values and copy those headers over to the proxy request as well.
        //
        //     The `validateProxyUrl` method on the `quippe` object is called during each invocation of this route to check to see if we should proxy the given
        //     URL or not.  The default implementation of that method returns true for all URLs, but if you want to restrict the list of URLs that this route
        //     should proxy for, you can implement your own copy of this method.
        //
        //     You can use this middleware in your [Connect](https://github.com/senchalabs/connect)-based Node.js server application by calling
        //     `app.use(quippe.proxyMiddleware)`.
        // request: Object
        //     [Request object](https://nodejs.org/api/http.html#http_class_http_clientrequest) for the incoming HTTP request for this route.
        // response: Object
        //     [Response object](https://nodejs.org/api/http.html#http_class_http_serverresponse) for the HTTP response to this request.
        // next: Function
        //     The next function in the route pipeline.
        if (!request.originalUrl.match(/^\/proxy/)) {
            return next();
        }

        if (request.originalUrl.indexOf('?') == -1) {
            thisProxyReference.logger.error('Proxy request received, but no URL to request was provided in the query string');
            response.status(404).send('No request URL provided in the query string.');
            return next();
        }

        var proxyUrl = decodeURIComponent(request.originalUrl.substring(request.originalUrl.indexOf('?') + 1));

        if (!proxyUrl.match(/^http\:\/\//i)) {
            proxyUrl = "http://" + proxyUrl;
        }

        if (!thisProxyReference.validateProxyUrl(proxyUrl)) {
            thisProxyReference.logger.warn('Received a request to proxy %s, but the validation method returned false')
            response.status(403).send('Not authorized to send requests to ' + URL + '.');
            return next();
        }

        var urlComponents = url.parse(proxyUrl);
        var proxyRequestHeaders = {};

        thisProxyReference.logger.debug('Proxying a request to %s', proxyUrl);

        if (request.headers['proxy-copyheaders']) {
            var headerNames = request.headers['proxy-copyheaders'].split(/(\,|\;| )/);

            for (var i = 0; i < headerNames.length; i++) {
                if (request.headers[headerNames[i]]) {
                    thisProxyReference.logger.debug('Proxy header value: %s=%s', headerNames[i], request.headers[headerNames[i]]);
                    proxyRequestHeaders[headerNames[i]] = request.headers[headerNames[i]];
                }
            }
        }

        for (var headerName in request.headers) {
            if (headerName.match(/^proxy\-header\-/i)) {
                thisProxyReference.logger.debug('Proxy header value: %s=%s', headerName.substring(13), request.headers[headerName]);
                proxyRequestHeaders[headerName.substring(13)] = request.headers[headerName];
            }
        }

        thisProxyReference.logger.debug('Sending proxy request');

        var proxyRequest = (urlComponents.protocol == 'https:' ? https : http).request({
            hostname: urlComponents.hostname,
            port: urlComponents.port || (urlComponents.protocol == 'https:' ? 443 : 80),
            path: urlComponents.path || '/',
            method: request.method,
            headers: proxyRequestHeaders
        }, function(proxyResponse) {
            thisProxyReference.logger.debug('Received a response to the proxy request (status code: %d)', proxyResponse.statusCode);

            response.status(proxyResponse.statusCode);
            response.setHeader('Content-Type', proxyResponse.headers['content-type']);

            var chunks = [];

            proxyResponse.on('data', function(chunk) {
                chunks.push(chunk);
            });

            proxyResponse.on('end', function() {
                var buffer = Buffer.concat(chunks);
                var encoding = proxyResponse.headers['content-encoding'];

                if (encoding == 'gzip') {
                    zlib.gunzip(buffer, function(error, decodedBuffer) {
                        if (error) {
                            thisProxyReference.logger.error(util.format('Error unzipping proxy response data: %s', error));
                            return next(error);
                        }

                        thisProxyReference.logger.debug('Finished copying proxy response to the client response stream');
                        response.end(decodedBuffer);
                        next();
                    });
                }

                else if (encoding == 'deflate') {
                    zlib.inflate(buffer, function(error, decodedBuffer) {
                        if (error) {
                            thisProxyReference.logger.error(util.format('Error inflating proxy response data: %s', error));
                            return next(error);
                        }

                        thisProxyReference.logger.debug('Finished copying proxy response to the client response stream');
                        response.end(decodedBuffer);
                        next();
                    });
                }

                else {
                    thisProxyReference.logger.debug('Finished copying proxy response to the client response stream');
                    response.end(buffer);
                    next();
                }
            });
        });

        proxyRequest.on('error', function(error) {
            thisProxyReference.logger.error(util.format('Error performing proxy request: %s', error));
            response.status(500).send(error);
            next(error);
        });

        request.pipe(proxyRequest);
    };

    this.validateProxyUrl = function (proxyUrl) {
        // summary:
        //     Checks a URL to see if Quippe should proxy it.
        // description:
        //     If you are using the Quippe proxy middleware via `app.use(quippe.proxyMiddleware)`, you can override this function to provide checking on the
        //     URLs that Quippe is being asked to proxy.  The default version of this function returns `true` for all cases.
        // proxyUrl: String
        //     URL that Quippe is being asked to proxy.
        // returns: Boolean
        //     Returns `true` if we should proxy the URL, `false` otherwise.
        return true;
    };
};

module.exports = new quippeApplication();
