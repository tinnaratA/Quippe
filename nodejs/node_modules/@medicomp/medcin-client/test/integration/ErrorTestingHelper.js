/**
 * Created by pkarcher on 2/19/2015.
 */
'use strict';

//var should = require('should');
var medicomp = medicomp || require('../../index');

var Q = require ('q');
//var specHelper = require('../SpecHelper');
require('../../connection');

var ErrorTestingHelper = function(done, situationWeAreTryingNow) {

  this.currentMethodName = null;
  this.currentMethodWithParameters = null;
  this.situationWeAreTryingNow = situationWeAreTryingNow;

  this.specialConfiguration = {errorConsistency : [true, true, true],
                               addAndProcessCallback : true};

  var whatWasCalled = {
    totalCalls: 0,
    howManyCalled: 0
  };

  var thisHelper = this;

  var doTimeDelayedAsyncTests = true;  // ***********************************

  this.constructStandardTestCalls = function constructStandardTestCalls() {

    var standardCalls = [['codeFromMedcin', 313196, 3, 1],
      ['codeFromMedcin', 1583, 3, 0],
      ['getCachedCodes', 32881],
      ['setDebugOutput', 2],
      ['activateExpansion', 102905],
      ['codeFromMedcin', 313196, 3, 1],
      ['histAddDocName', 5, 'Dr. Bob'],
      ['getProperty', 102905, 'Takes', 0]];

    var copyOfArray = [];
    standardCalls.slice().forEach(function (methodAndParameters) {
      copyOfArray.push(methodAndParameters.slice());
    });
    standardCalls.push(['callInSequence', copyOfArray]);

    standardCalls = standardCalls.concat([['getCachedProperties', 1583], ['getCachedCodes', 33288]]);

    return standardCalls;
  };

  function tryOut(connOrConnFunction, callInfo) {

    var deferredToReturn = Q.defer();

    try {

      // This method makes sure that no matter how the results of a call are gotten, the failure is always
      // there, always clear, an consistent.  The three ways are:
      // a. promise returned when callback parameter is included
      // b. callback parameter
      // c. promise returned when callback parameter is not included

      thisHelper.currentMethodName = callInfo.shift();

      var copyOfCallInfo = callInfo.slice();
      copyOfCallInfo.forEach(function (item, i, theArray) {
        if (typeof item === 'function') {
          theArray[i] = 'some function';
        }
        if (item instanceof Array) {
          theArray[i] = 'some array';
        }
      });
      thisHelper.currentMethodWithParameters = thisHelper.currentMethodName + '(' + copyOfCallInfo.join(', ') + ')';

      if (thisHelper.situationWeAreTryingNow === 'When methods are called without waiting for the connection to be established' &&
        thisHelper.currentMethodName === 'codeFromMedcin') {
        console.log('taco');
      }

      var firstMethodPromiseHasAlreadyHappened = false;
      var callbackHasAlreadyHappened = false;
      var conn;
      if (typeof connOrConnFunction === 'function') {
        conn = connOrConnFunction();
      } else {
        conn = connOrConnFunction;
      }

      var firstCallDeferred = Q.defer();

      if (doTimeDelayedAsyncTests) {
        setTimeout(function () {
          if (!firstMethodPromiseHasAlreadyHappened) {
            deferredToReturn.reject(new Error('after 2 seconds, the first promise still hadn\'t been resolved or rejected.'));
          }
        }, 2000);
      }

      var firstCallInterPromise = conn[thisHelper.currentMethodName].apply(conn, callInfo);
      firstCallInterPromise.then(function (data) {
        firstMethodPromiseHasAlreadyHappened = true;
        firstCallDeferred.resolve(data); //  Bingo!
      }, function (err) {
        firstMethodPromiseHasAlreadyHappened = true;
        firstCallDeferred.resolve(err);
      });
      var firstCallPromise = firstCallDeferred.promise;

      var secondCallInterPromise;
      var secondCallCallbackFunction;
      var secondCallCallbackPromise = Q.defer();
      var secondCallDeferred = Q.defer();

      //var firstCallPromise = new Q(1);
      firstCallPromise.then(function () {

        if (thisHelper.specialConfiguration.addAndProcessCallback) {
          if (doTimeDelayedAsyncTests) {
            setTimeout(function () {
              if (!callbackHasAlreadyHappened) {
                var message = 'Error in int_exceptions_handled_spec, ' + thisHelper.situationWeAreTryingNow + ', calling ' +
                  thisHelper.currentMethodWithParameters + ': after 2 seconds, the callback still hadn\'t been called.';
                console.log('\r\n' + message);
                secondCallCallbackPromise.reject(new Error(message));
              }
            }, 2000);
          }

          secondCallCallbackFunction = function (err, data) {

            if (callbackHasAlreadyHappened) {  // This makes sure the callback isn't called more than once, which happened at one point.
              var message = 'Error in int_exceptions_handled_spec, ' + thisHelper.situationWeAreTryingNow + ', calling ' +
                thisHelper.currentMethodWithParameters + ': an error callback was called twice!';
              console.log(message);
              deferredToReturn.reject(new Error(message));
            }
            callbackHasAlreadyHappened = true;

            if (err) {
              secondCallCallbackPromise.resolve(err);  //  Bingo!
            } else {
              secondCallCallbackPromise.resolve(data);
            }
          };
          callInfo.push(secondCallCallbackFunction);
        } else {
          secondCallCallbackPromise.resolve('nothing');
        }

        if (typeof connOrConnFunction === 'function') {
          try {
            conn.medcinEnd();
          } catch(e) {
            console.log('hi');
          }
          conn = connOrConnFunction();
        }
        secondCallInterPromise = conn[thisHelper.currentMethodName].apply(conn, callInfo);
        secondCallInterPromise.then(function (data) {
          secondCallDeferred.resolve(data); //  Bingo!
        }, function (err) {
          secondCallDeferred.resolve(err);
        });

      });

      var allThreePromises = Q.all([firstCallPromise, secondCallDeferred.promise, secondCallCallbackPromise.promise]);

      allThreePromises.then(function (data) {
        whatWasCalled.howManyCalled++;
        var whatNeedsToBeConsistent = thisHelper.specialConfiguration.errorConsistency;
        try {
          if (!(data[0] instanceof Error)) {
            deferredToReturn.reject(
              new Error('Promise returned when callback not passed in was not error. Instead it was: ' + data[0].toString()));
          }
          if (!(data[1] instanceof Error)) {
            deferredToReturn.reject(new Error('Promise returned when callback passed in was not error. Instead it was: ' +
            data[1].toString()));
          }
          if (!(data[2] instanceof Error) && thisHelper.specialConfiguration.addAndProcessCallback) {
            deferredToReturn.reject(new Error('Callback function passed in was not error. Instead it was: ' +
            data[2].toString()));
          }
          if (whatNeedsToBeConsistent[0] && whatNeedsToBeConsistent [1]) {
            if (data[0].message !== data[1].message) {
              deferredToReturn.reject(
                new Error('Promise error was not consistent between whether callback was included or not.'));
            }
          }
          if (whatNeedsToBeConsistent[1] && whatNeedsToBeConsistent [2] && thisHelper.specialConfiguration.addAndProcessCallback) {
            if (data[1].message !== data[2].message) {
              deferredToReturn.reject(
                new Error('Promise error was not consistent with Callback function error.'));
            }
          }
          if (whatNeedsToBeConsistent[0] && whatNeedsToBeConsistent [2] && thisHelper.specialConfiguration.addAndProcessCallback) {
            if (data[0].message !== data[2].message) {
              deferredToReturn.reject(
                new Error('Promise error was not consistent with Callback function error.'));
            }
            //I'm NOT testing whether lastError matches what we got back.  This is all asynch, and there's no control
            //over what the error is at time.  A callback could easily be called a 2nd time (and we can't stop it)
            //that would result in a new conn.lastError message that is bogus and would otherwise have been lost.
            //if (data[0].message !== conn.lastError.message) {
            //  deferredToReturn.reject(
            //    new Error('returned Errors were not consistent with connection.lastError property.'));
            //}
          }
          // At this point all three results were errors, and all had the same message.  Success!
          deferredToReturn.resolve(data);
        } catch (e) {
          var err = new Error('Error analyzing and comparing results by callback/promise:  ' + e.message);
          err.inner = e;
          deferredToReturn.reject(err);
        }
      }, function (err) {
        console.log('In int_exceptions_handled_spec, based on how we\'re doing this, whether the method call errored ' +
        'or not, we should never get here.  So ever seeing this indicates a syntax error in the tryOut function.  ' +
        'Error was ' + err.message);
      });

      return deferredToReturn.promise;

    }
    catch (e) {
      setImmediate(function () {
        var err = new Error('Something totally unhandled error happened: ' + e.messagege);
        err.inner = e;
        deferredToReturn.reject(e);
      });
      return deferredToReturn.promise;
    }

  }

  this.tryTheseOneAfterAnother = function tryTheseOneAfterAnother (functionToMakeSureErrorWasCorrect,
                                   connectionOrFunctionThatPreparesConnection, calls) {

    function functionToRespondToInconsistentErrors(messedUpError) {
      messedUpError.message = thisHelper.situationWeAreTryingNow + ', when calling ' + thisHelper.currentMethodWithParameters +
      ', before we got to our assertions: ' + messedUpError.message;
      done(messedUpError);
    }

    whatWasCalled.totalCalls = whatWasCalled.totalCalls + calls.length;

    function setUpTheNextOne(lastPromise, arrayOfCalls, whichToSetUpNow, done) {
      lastPromise.then(function () {
        //whatWasCalled.viaPromise++;
        //          var thisPromise = callAndTestMethod(arrayOfCalls[whichToSetUpNow]);
        var thisPromise = tryOut(connectionOrFunctionThatPreparesConnection, arrayOfCalls[whichToSetUpNow])
          .then(function (lastGoodError) {
            try {
              functionToMakeSureErrorWasCorrect(lastGoodError);
            }
            catch (e) {
              e.message = 'Error in int_exceptions_handled_spec, ' + thisHelper.situationWeAreTryingNow + ', calling ' +
              thisHelper.currentMethodWithParameters + ': ' + e.message;
              done(e);
            }

            if (whichToSetUpNow < arrayOfCalls.length - 1) {
              setUpTheNextOne(thisPromise, arrayOfCalls, whichToSetUpNow + 1, done);
            }
            else {
              thisPromise.then(function () {
                //conn.medcinEnd().then(function () {
                done();
                //});
              }, function (err) {
                done(err);
                //conn.medcinEnd().then(function () {
                //  done(err);
                //});
              });
            }

          }, functionToRespondToInconsistentErrors);

      }, function (err) {
        done(err);
        //conn.medcinEnd().then(function() {
        //  done(err);
        //});
      });
    }

    setUpTheNextOne(new Q(1), calls, 0, done);

  };

};

module.exports = ErrorTestingHelper;
