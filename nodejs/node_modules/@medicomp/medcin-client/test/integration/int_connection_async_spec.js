/*** Created by pkarcher on 1/27/2015. */
'use strict';

require('should');
var medicomp = medicomp || require('../../index');

//var fs = require('fs');
//var parseString = require('xml2js').parseString;
var Q = require ('q');
var specHelper = require('../SpecHelper');
//require('../../connection');

describe('(int)medicomp.Connection.callInSequence', function () {

  // This file's job is to use some of the general scenario files to call their methods via
  // Connection.tryTheseOneAfterAnother().  All the scenario methods <could> be call in this manor, but
  // we only call some for the following reasons:
  //   A) only some (those with multiple interdependent methods) give any real testing benefit, and
  //   B) each one causes some overhead and upkeep here (how to call methods has to be specified).
  // So we only want to call the ones that provide benefit.
  describe('when send it an array of method info arrays', function () {

    it('calls all the encounter_methods scenario correctly in sequence, and returns last value correctly',
      function (done) {
        runMethods('encounter_methods', done, [''],
          ['setPatient', 'addEncounter', 'addNarrate2', 'addNarrate2Ex']);
      }
    );

    it('calls all the grouped_methods scenario correctly in sequence, and returns last value correctly',
      function (done) {
        runMethods('grouped_methods', done, ['activateWordSearch', 'activateDx', 'haveDx'],
          ['wordSearch', 'addDx', 'clearDx']);
      }
    );

    // ToDo:  Add more scenarios here, when we have them.  Like intelligent prompting and buffered history.

    it('fills array of answers if an empty array is passed in.',
      function (done) {
        var answersArray = [];
        var conn = new medicomp.Connection(specHelper.getTestConfiguration());
        function CheckTheAnswers (err) {
          if (err) {
            done('Error in int_connection_async_spec where we manually call callInSequence to make ' +
              'sure answer array is filled out: ' + err.message);
          } else {
            answersArray.length.should.equal(7);
            answersArray[0].should.equal(true);
            answersArray[1].should.equal('headache');
            answersArray[2].should.equal('~> were normal');
            answersArray[3].should.equal('');
            answersArray[4].should.equal(true);
            answersArray[5].should.equal('Takes.Value\tPatientEngagementType');
            answersArray[6].should.equal(10);
            done();
          }
        }
        conn.connectionPromise.then(function () {
          conn.callInSequence([['setDebugOutput', 2], ['sDocPos', '10'],
            ['sDocNeg', 102905], ['getProperty', 102905, 'Takes', 0], ['histAddDocName', 5, 'Dr. Bob'],
            ['getProperty', 0, '', 0], ['baseGroup', 102905]], answersArray, CheckTheAnswers);
        });

      }
    );

    function runMethods(methodsFile, done, methodsThatReturnSomethingAndTerminateChain,
                        methodsThatReturnNothingAndContinueChain) {

      specHelper.getCallsFromFile(methodsFile).then(function(calls) {

        var sequences = [];
        var currentSequence = null;

        calls.forEach(function (call) {
          call.methodArray = [call.method].concat(call.getArrayOfParameterValues());

          if (!currentSequence) {
            currentSequence = [];
            sequences.push(currentSequence);
          }
          currentSequence.push(call.methodArray);
          currentSequence.lastCall = call;
          if (methodsThatReturnSomethingAndTerminateChain.indexOf(call.method) > -1) {
            currentSequence = null;
          } else if (methodsThatReturnNothingAndContinueChain.indexOf(call.method) < 0) {
            done('method ' + call.method +
            ' is not accounted for in our two lists of methods, so we don\'t know how to treat it.');
          }
        });

        var conn = new medicomp.Connection(specHelper.getTestConfiguration());

        conn.connectionPromise.then(function () {

          function setUpTheNextOne (lastPromise, arrayOfCalls, whichToSetUpNow, done) {
            lastPromise.then(function (){
              var thisPromise = callAndTestMethod(arrayOfCalls[whichToSetUpNow]);
              if (whichToSetUpNow < arrayOfCalls.length - 1 ) {
                  setUpTheNextOne(thisPromise, arrayOfCalls, whichToSetUpNow + 1, done);
              }
              else {
                  thisPromise.then(function () {
                      conn.medcinEnd().then(function () {
                          done();
                      });
                  }, function (err) {
                      conn.medcinEnd().then(function () {
                          done(err);
                      });
                  });
              }
            }, function(err){
              conn.medcinEnd().then(function() {done(err);});
            });
          }

//                var firstPromise = callAndTestMethod(sequences[0]);
          var bogusDeferred = Q.defer();
          bogusDeferred.resolve({});

          setUpTheNextOne(bogusDeferred.promise, sequences, 0, done);

          function callAndTestMethod(sequence) {
            if (sequence === null || sequence === undefined  ) {
                return specHelper.createPromiseError('A sequence passed in to test \'tryTheseOneAfterAnother\' was all missed up.');
            }
            //var bogusArray = [];
            //sequence.push(bogusArray);
            var methodPromise = conn.callInSequence(sequence);
            var deferred = Q.defer();
            methodPromise.then(function(data) {
              try {
                specHelper.compareCallAndResult(sequence.lastCall, data);
                conn.howManyMethodsCalled.should.equal(sequence.length);
                deferred.resolve();
              }
              catch (e) {
                e.message = 'In (tryTheseOneAfterAnother) ' + sequence.lastCall.file + '.xml on ' +
                  sequence.lastCall.name + ': ' + e.message;
                deferred.reject(e);
              }
            }, function(err) {
              err.message = 'In (tryTheseOneAfterAnother) ' + sequence.lastCall.file + '.xml on ' +
                sequence.lastCall.name + ': ' + err.message;
              deferred.reject(err);
            });
            return deferred.promise;
          }

        });

      }, function(err) {
        done(err);
      });

    }

  });


});
