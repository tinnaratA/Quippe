<?xml version="1.0"?>
<doc>
<assembly>
<name>
Quippe.Coding
</name>
</assembly>
<members>
<member name="P:Quippe.Coding.TranslateItemHandler.SourceVocabulary">
	<summary>
 The unique string code of the source vocabulary to translate from.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.SourceCode">
	<summary>
 The source code.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.TargetVocabulary">
	<summary>
 The unique string code of the target vocabulary.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.Prefix">
	<summary>
 The optional MEDCIN prefix associated with a MEDCIN source code.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.Result">
	<summary>
 The optional MEDCIN result qualifier associated with a MEDCIN source code.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.Status">
	<summary>
 The optional MEDCIN status qualifier associated with a MEDCIN source code.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.Modifier">
	<summary>
 The optional MEDCIN modifier qualifier associated with a MEDCIN source code.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.Specifier">
	<summary>
 The optional MEDCIN specification string associated with a MEDCIN source code.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.Age">
	<summary>
 The optional patient age, in minutes, associated with a MEDCIN source code.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.Sex">
	<summary>
 The optional patient sex associated with a MEDCIN source code.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.Value">
	<summary>
 The optional test or measurement value associated with a MEDCIN source code.
 </summary>
</member><member name="P:Quippe.Coding.TranslateItemHandler.EncounterTime">
	<summary>
 The optional encounter date and time associated with an item.
 </summary>
</member><member name="P:Quippe.Coding.TermMapHandler.MedcinId">
	<summary>
 The ID of the MEDCIN finding for which to retrieve code maps
 </summary>
</member><member name="M:Quippe.Coding.TermMapHandler.AddOptionParms">
	<summary>
 Adds translation options to perform loose matching of all qualifiers.
 </summary>
	<remarks>
		<para>Sets the prefix matching option and the qualifier matching option (all other qualifiers) to "Loose" so
 that the standard translator will essentially return candidate maps by matching only the MEDCIN ID.</para>
	</remarks>
</member><member name="P:Quippe.Coding.SpecifierListHandler.ListId">
	<summary>
 The specifier list ID.
 </summary>
</member><member name="P:Quippe.Coding.FindingMapHandler.MedcinId">
	<summary>
 The ID of the MEDCIN finding for which to retrieve code maps
 </summary>
</member><member name="P:Quippe.Coding.FindingMapHandler.Prefix">
	<summary>
 The optional MEDCIN prefix associated with the MEDCIN finding.
 </summary>
</member><member name="P:Quippe.Coding.FindingMapHandler.Result">
	<summary>
 The optional MEDCIN result qualifier associated with the MEDCIN finding.
 </summary>
</member><member name="P:Quippe.Coding.FindingMapHandler.Status">
	<summary>
 The optional MEDCIN status qualifier associated with the MEDCIN finding.
 </summary>
</member><member name="P:Quippe.Coding.FindingMapHandler.Modifier">
	<summary>
 The optional MEDCIN modifier qualifier associated with the MEDCIN finding.
 </summary>
</member><member name="P:Quippe.Coding.FindingMapHandler.Specifier">
	<summary>
 The optional MEDCIN specification string associated with the MEDCIN finding.
 </summary>
</member><member name="P:Quippe.Coding.FindingMapHandler.Value">
	<summary>
 The optional test or measurement value associated with the MEDCIN finding.
 </summary>
</member><member name="P:Quippe.Coding.CodeEntryHandler.VocabCode">
	<summary>
 The unique string identifier of the coding vocabulary.
 </summary>
</member><member name="P:Quippe.Coding.CodeEntryHandler.Code">
	<summary>
 The code in the specified vocabulary for which data is requested.
 </summary>
</member><member name="P:Quippe.Coding.BaseMapHandler.IncludeHints">
	<summary>
 Indicates whether textual code hints for the target codes should be included with the code mapping results, if available.
 </summary>
</member><member name="P:Quippe.Coding.BaseMapHandler.IncludeSpecifierLists">
	<summary>
 Indicates whether code specifier lists associated with the target codes should be included with the code mapping results, if available.
 </summary>
</member><member name="P:Quippe.Coding.BaseMapHandler.AutoGenerateMaps">
	<summary>
 Indicates whether maps from qualified MEDCIN concepts should be automatically generated where applicable if no maps are available.
 </summary>
</member><member name="P:Quippe.Coding.BaseMapHandler.MapExpressionOption">
	<summary>
 Indicates how SNOMED-CT map expressions are created.
 </summary>
</member><member name="F:Quippe.Coding.VocabularyVersion.MIN_VALID_CODE_YEAR">
	<summary>Minimum allowable value for the name of versions that are code years.</summary>
</member><member name="F:Quippe.Coding.VocabularyVersion.MAX_VALID_CODE_YEAR">
	<summary>Maximum allowable value for the name of versions that are code years.</summary>
</member><member name="M:Quippe.Coding.VocabularyVersion.#ctor(System.String,System.Boolean,System.Boolean,System.DateTime,System.DateTime)">
	<summary>
 Creates a new VocabularyVersion object.
 </summary>
	<param name="Name">Name of the version, either a version name or number, or a code year.</param>
	<param name="UsesCodeYear">Indicates whether the code year is used as the version, in which case the Name should parse to an integer year value, e.g., "2011".</param>
	<param name="IsCurrent">Indicates whether this version is the current (most recent) version.</param>
	<param name="StartDate">The optional start date when the version took effect.</param>
	<param name="EndDate">The optional end date after which the version was no longer in effect.</param>
	<remarks>
		<para>See <see cref="P:Quippe.Coding.VocabularyVersion.StartDate"/> and <see cref="P:Quippe.Coding.VocabularyVersion.EndDate"/> properties for more information on start and end dates
 and their use in code translation.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.VocabularyVersion.Name">
	<summary>
 Gets a string identifier that uniquely defines the version within the vocabulary.
 </summary>
	<remarks>
		<para>Valid names are non-empty strings unique within the vocabulary.</para>
		<para>Typically Name is either a name, version number or a code year or combination thereof. For 
 example, MEDCIN sourced vocabularies such as ICD-9-CM use a code year to identify the version (e.g., "2010"), 
 whereas other Medicomp supported vocabularies may use a name derived from the date the 
 vocabulary was last updated (e.g., "2010-08" in "YYYY-MM" format for RxNorm).</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.VocabularyVersion.IsCurrent">
	<summary>
 Gets or sets a Boolean value indicating whether this version is the currently active version of the vocabulary.
 </summary>
	<remarks>
		<para>If True, this version is the currently active version of the associated vocabulary. If False, this
 version is not the currently active version of the associated vocabulary.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.VocabularyVersion.UsesCodeYear">
	<summary>
 Gets or sets a Boolean value indicating whether the version is a code year.
 </summary>
	<exception cref="T:Quippe.Coding.CodingException">Thrown when setting this property and the version is not a valid code year. Refer to <see cref="M:Quippe.Coding.VocabularyVersion.HasValidCodeYear"/>
 for more information.</exception>
	<remarks>
		<para>Code mappings for a vocabulary with code year versions may be searched differently than those with
 versions that are not specified by code year.</para>
		<para>In some cases, a version is a string representation of a "code year" in the associated vocabulary. A code year 
 is a numeric value, e.g., "2010", identifying a year within the vocabulary for which a given set of codes are valid.
 Not all coding systems or vocabularies are code year based, but typically a coding system used for billing will be
 versioned by year. A coding system that is code year based, may not align the code year with the calendar year.
 For instance, ICD-9-CM code years begin at the start of the 4th quarter (October 1st).
 </para>
		<para>Medicomp distnguishes revisions of its billable code mappings by a "code year" and the process for mapping
 MEDCIN concepts to codes in these vocabularies and performing code translations using these mappings depends
 on these values. This property indicates whether the versions associated with this vocabulary are given by 
 code year and hence determine how mappings are retrieved by the coding service providers. Typically, when given an
 encounter date, and a list of encounter entries containing MEDCIN codes to translate into an external vocabulary
 such as ICD-9-CM, a coding service provider will only look at the maps that have target codes in the
 code year of the encounter or earlier, obtaining the map to the most recent target code available. So the 
 code translation process has some complexity when the vocabulary version is a code year.
 </para>
		<para>If the vocabulary does not use code years, then the code translation process is simpler. In the absence of a
 vocabulary version, a coding service translator would simply return the best mapping available, regardless of version.
 If a version was specified for a vocabulary that doesn't use code years, the code translator would simply return the best
 mapping to a code having the exact same version.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.VocabularyVersion.StartDate">
	<summary>
 Gets or sets the optional date on which this version of an associated vocabulary became effective.
 </summary>
	<remarks>
		<para>This value, in combination with the EndDate, could be used to determine which version of a vocabulary
 is current for a given date.</para>
		<para>The StartDate and EndDate are optional and define the dates during which the version is in effect. When the version
 is a code year, the StartDate and EndDate should span a year and indicate when the year starts and ends. If the code year corresponds 
 to the calendar year, then the start date will be 1/1/yyyy and the end date, 12/31/yyy. Sometimes the code year
 does not corrrespond to the calendar year, as is the case for ICD-9-CM, and the start and end dates should
 be defined accordingly.</para>
		<para>The start and end dates are used by coding service translation providers to determine
 when a given code year is in effect. When a translator is given an encounter date, the start and end dates
 will indicate which code year is in effect for the encounter. The code translation process can then access only
 those maps that are relevant for the encounter code year in the target vocabulary, which typically includes 
 maps that reference target codes in the code year or earlier.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.VocabularyVersion.EndDate">
	<summary>
 Gets or sets the optional date after which this version of an associated vocabulary became ineffective.
 </summary>
	<remarks>
		<para>This value, in combination with the EndDate, could be used to determine which version of a vocabulary
 is current for a given date.</para>
		<para>The StartDate and EndDate are optional and define the dates during which the version is in effect. When the version
 is a code year, the StartDate and EndDate should span a year and indicate when the year starts and ends. If the code year corresponds 
 to the calendar year, then the start date will be 1/1/yyyy and the end date, 12/31/yyy. Sometimes the code year
 does not corrrespond to the calendar year, as is the case for ICD-9-CM, and the start and end dates should
 be defined accordingly.</para>
		<para>The start and end dates are used by coding service translation providers to determine
 when a given code year is in effect. When a translator is given an encounter date, the start and end dates
 will indicate which code year is in effect for the encounter. The code translation process can then access only
 those maps that are relevant for the encounter code year in the target vocabulary, which typically includes 
 maps that reference target codes in the code year or earlier.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyVersion.ToString">
	<summary>
 Returns a string representation of the current instance.
 </summary>
	<returns>Returns a string that represents the object.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyVersion.HasValidCodeYear">
	<summary>
 Determines if the version name is a valid code year.
 </summary>
	<returns>Returns True if this version's name is a valid code year and False otherwise.</returns>
	<remarks>
		<para>This function checks that the version name is numeric and then determines whether the year falls 
 within the valid range. Years from MIN_VALID_CODE_YEAR to MAX_VALID_CODE_YEAR are considered valid.</para>
		<para>See the <see cref="P:Quippe.Coding.VocabularyVersion.UsesCodeYear"/> property for more information on code years.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyVersion.GetCodeYear">
	<summary>
 Gets the code year representation of the version name, provided the version uses code years and the
 version name is a valid code year.
 </summary>
	<returns>Returns the code year representation of the version name as an Integer if the version uses code 
 years and the version name is a valid code year, otherwise returns -1.</returns>
	<remarks>
		<para>In some cases, a version is a string representation of a "code year" in the associated vocabulary. A code year 
 is a numeric value, e.g., "2010", identifying a year within the vocabulary for which a given set of codes are valid.
 Not all coding systems or vocabularies are code year based, but typically a coding system used for billing will be
 versioned by year. A coding system that is code year based, may not align the code year with the calendar year.
 For instance, ICD-9-CM code years begin at the start of the 4th quarter (October 1st). See the <see cref="P:Quippe.Coding.VocabularyVersion.UsesCodeYear"/>
 property for more information on code years.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyVersion.CoversDate(System.DateTime)">
	<summary>
 Determines if the specified date falls within the date range of this version.
 </summary>
	<param name="aDate">The date to check against the date range of this version.</param>
	<returns>Returns True if the specified date falls within the date range
 defined by the version's start and end dates, and returns False otherwise.</returns>
	<remarks>
		<para>This function could be used to determine if a vocabulary version was applicable
 on a specified encounter date; if it was applicable, and the version uses code years, the Name 
 property would be the code year to use to obtain the code mappings that were in force on
 that date.</para>
		<para>See <see cref="P:Quippe.Coding.VocabularyVersion.StartDate"/> and <see cref="P:Quippe.Coding.VocabularyVersion.EndDate"/> properties for more information on start and end dates
 and their use in code translation.</para>
		<para>See the <see cref="P:Quippe.Coding.VocabularyVersion.UsesCodeYear"/> property for more information on code years.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyVersion.CompareToDate(System.DateTime)">
	<summary>
 Determines whether the specified date falls before, within, or after the date range of this version.
 </summary>
	<param name="aDate">The date to check against the date range of this version.</param>
	<returns>Returns -1, 0, or 1 if the specified date falls before, within or after, respectively, 
 the date range defined by the version's start and end dates, and returns False otherwise.</returns>
	<exception cref="T:Quippe.Coding.CodingException">Thrown when the specified date in aDate parameter is Nothing or when
 either of the StartDate and EndDate properties of the vocabulary version instance are Nothing.</exception>
	<remarks>
		<para>This function could be used to determine if a vocabulary version was applicable
 on a specified encounter date; if it was applicable, and the version uses code years, the Name 
 property would be the code year to use to obtain the code mappings that were in force on
 that date.</para>
		<para>See <see cref="P:Quippe.Coding.VocabularyVersion.StartDate"/> and <see cref="P:Quippe.Coding.VocabularyVersion.EndDate"/> properties for more information on start and end dates
 and their use in code translation.</para>
		<para>See the <see cref="P:Quippe.Coding.VocabularyVersion.UsesCodeYear"/> property for more information on code years.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyVersion.Clone">
	<summary>
 Creates a new object that is a copy of the current instance.
 </summary>
	<remarks>Creates a deep copy of the current VocabularyVersion instance and returns the copy as an Object.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyVersion.IsValidCodeYear(System.String)">
	<summary>
 Determines if the specified version name is a valid code year.
 </summary>
	<param name="VersionName">The version name to check for validity as a code year.</param>
	<returns>Returns True if the specified version name is a valid code year and False otherwise.</returns>
	<remarks>
		<para>This function checks that the version name is numeric and then determines whether the year falls 
 within the valid range. Years from MIN_VALID_CODE_YEAR to MAX_VALID_CODE_YEAR are considered valid.</para>
		<para>See the <see cref="P:Quippe.Coding.VocabularyVersion.UsesCodeYear"/> property for more information on code years.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyVersion.IsValidCodeYear(System.Int32)">
	<summary>
 Determines if the specified code year is valid.
 </summary>
	<param name="CodeYear">The code year to check for validity as a code year.</param>
	<returns>Returns True if the specified code year is a valid code year and False otherwise.</returns>
	<remarks>
		<para>This function checks that the code year falls within the valid range. Years from 
 MIN_VALID_CODE_YEAR to MAX_VALID_CODE_YEAR are considered valid.</para>
		<para>See the <see cref="P:Quippe.Coding.VocabularyVersion.UsesCodeYear"/> property for more information on code years.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyVersion.GetCodeYearStartDate(System.Int32,Quippe.Coding.Vocabulary.CodeYearTypeEnum)">
	<summary>
 Determines the start date of the specified code year based on the specified code year type.
 </summary>
	<param name="CodeYear">A code year as an integer value, representing a year during which a release of a code set or vocabulary 
 is valid, usually for billing purposes.</param>
	<param name="CodeYearType">A type indicating when the code year starts and ends, e.g., either the calendar year or fiscal year.</param>
	<remarks>A calendar code year will start on January 1st and a fiscal code year will start on October 1st.</remarks>
</member><member name="M:Quippe.Coding.VocabularyVersion.GetCodeYearEndDate(System.Int32,Quippe.Coding.Vocabulary.CodeYearTypeEnum)">
	<summary>
 Determines the end date of the specified code year based on the specified code year type.
 </summary>
	<param name="CodeYear">A code year as an integer value, representing a year during which a release of a code set or vocabulary 
 is valid, usually for billing purposes.</param>
	<param name="CodeYearType">A type indicating when the code year starts and ends, e.g., either the calendar year or fiscal year.</param>
	<remarks>A calendar code year will end on December 31st and a fiscal code year will end on September 30th.</remarks>
</member><member name="M:Quippe.Coding.VocabularyVersion.GetCodeYear(System.DateTime,Quippe.Coding.Vocabulary.CodeYearTypeEnum)">
	<summary>
 Determines the code year for a specified date based on the specified code year type.
 </summary>
	<param name="InputDate">The date for which the code year is desired.</param>
	<param name="CodeYearType">A type indicating when the code year starts and ends, e.g., either the calendar year or fiscal year.</param>
</member><member name="M:Quippe.Coding.VocabularyVersion.GetCurrentCodeYear(Quippe.Coding.Vocabulary.CodeYearTypeEnum)">
	<summary>
 Determines the code year for the current date based on the specified code year type.
 </summary>
	<param name="CodeYearType">A type indicating when the code year starts and ends, e.g., either the calendar year or fiscal year.</param>
</member><member name="T:Quippe.Coding.VocabularyVersion">
	<summary>
 Represents a version of a coding system vocabulary.
 </summary>
	<remarks>
		<para>Vocabulary versions are defined by a version name, which may simply be an integer code year or may be a text
 version identifier. A vocabulary may have multiple versions, but only one version should be the current version.
 The version is associated with a vocabulary only by virtue of its belonging to the vocabulary's version 
 collection.</para>
		<para>In some cases, a version is a string representation of a "code year" in the associated vocabulary. A code year 
 is a numeric value, e.g., "2010", identifying a year within the vocabulary for which a given set of codes are valid.
 Not all coding systems or vocabularies are code year based, but typically a coding system used for billing will be
 versioned by year. A coding system that is code year based, may not align the code year with the calendar year.
 For instance, ICD-9-CM code years begin at the start of the 4th quarter (October 1st).
 </para>
		<para>Medicomp distnguishes revisions of its billable code mappings by a "code year" and the process for mapping
 MEDCIN concepts to codes in these vocabularies and performing code translations using these mappings depends
 on these values. This property indicates whether the versions associated with this vocabulary are given by 
 code year and hence determine how mappings are retrieved by the coding service providers. Typically, when given an
 encounter date, and a list of encounter entries containing MEDCIN codes to translate into an external vocabulary
 such as ICD-9-CM, a coding service provider will only look at the maps that have target codes in the
 code year of the encounter or earlier, obtaining the map to the most recent target code available. So the 
 code translation process has some complexity when the vocabulary version is a code year.
 </para>
		<para>If the vocabulary does not use code years, then the code translation process is simpler. In the absence of a
 vocabulary version, a coding service translator would simply return the best mapping available, regardless of version.
 If a version was specified for a vocabulary that doesn't use code years, the code translator would simply return the best
 mapping to a code having the exact same version.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyManager.#ctor(System.Int32)">
	<summary>
 Creates a new VocabularyCollection.
 </summary>
	<param name="Capacity">The initial number of vocabularies the collection can contain.</param>
	<remarks>
		<para>The capacity is the number of vocabularies that can be added before resizing is necessary. As
 vocabularies are added, the capacity is automatically increased.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyManager.HasVocabulary(System.String)">
	<summary>
 Determines whether a vocabulary with the specified name exists in the collection.
 </summary>
	<param name="VocabCode">The unique String code of the vocabulary to locate in the collection.</param>
	<returns>Returns True if a vocabulary with the specified code exists in the collection and False otherwise.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyManager.Add(Quippe.Coding.Vocabulary)">
	<summary>
 Adds the specified vocabulary to the collection, provided one with the same code is not already present.
 </summary>
	<param name="Vocabulary">Vocabulary with unique code to add to the collection.</param>
</member><member name="M:Quippe.Coding.VocabularyManager.Remove(System.String)">
	<summary>
 Removes the vocabulary with the specified code from the collection, if found.
 </summary>
	<param name="VocabCode">Unique code identifying the vocabulary to remove.</param>
	<returns>Returns the removed vocabulary, if found, or Nothing, otherwise.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the VocabCode parameter is empty or Nothing.</exception>
</member><member name="M:Quippe.Coding.VocabularyManager.Clear">
	<summary>
 Removes all vocabularies from the collection and releases their references to other objects.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.VocabularyManager.Count">
	<summary>
 Gets the number of Vocabularies in the collection or 0 if there are none.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyManager.GetVocabulary(System.String)">
	<summary>
 Gets a reference to the vocabulary having the specified unique identifying code.
 </summary>
	<param name="VocabCode">Unique identifying code of the desired vocabulary.</param>
	<returns>Returns a reference to the Vocabulary having the specified code or Nothing if a vocabulary with that code was not found.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the VocabCode parameter is empty or Nothing.</exception>
</member><member name="M:Quippe.Coding.VocabularyManager.GetVocabulary(System.String,System.String)">
	<summary>
 Gets the vocabulary that has the specified vocabulary code and named version.
 </summary>
	<param name="VocabCode">The unique String code of the desired vocabulary.</param>
	<param name="VersionName">The unique String name of the desired version within the specified vocabulary.</param>
	<returns>Returns a reference to the vocabulary having the specified vocabulary code that also contains a version with the specified
 name, or Nothing if no such vocabulary or version exists.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if either of the VocabCode or VersionName parameters
 is empty or Nothing.</exception>
	<remarks>Even if the vocabulary exists, Nothing will be returned if the vocabulary does not contain a version
 with the specified name.</remarks>
</member><member name="P:Quippe.Coding.VocabularyManager.Values">
	<summary>
 Gets a collection of all vocabularies in the vocabulary collection.
 </summary>
</member><member name="P:Quippe.Coding.VocabularyManager.Codes">
	<summary>
 Gets a collection of all unique vocabulary codes in the collection.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyManager.GetCodeSet(System.String)">
	<summary>
 Gets a new version-less CodeSet object for the vocabulary that has the specified unique code.
 </summary>
	<param name="VocabCode">Unique code of the vocabulary for the desired CodeSet.</param>
	<returns>Returns a CodeSet object corresponding to the requested vocabulary, if the vocabulary exists, otherwise returns
 Nothing.</returns>
	<remarks>
		<para>A CodeSet is created from an existing vocabulary for use in the code translation API. The CodeSet has
 an empty version name. If the vocabulary does not exist, one should be created first before requesting a 
 CodeSet.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyManager.GetCodeSet(System.String,System.String)">
	<summary>
 Gets a new CodeSet object for the specified vocabulary and version.
 </summary>
	<param name="VocabCode">Unique String code of the vocabulary for the desired CodeSet.</param>
	<param name="VersionName">Unique String version name of the vocabulary for the desired CodeSet.</param>
	<returns>Returns a CodeSet object corresponding to the requested vocabulary and version, if the specified
 vocabulary exists and has the specified version, otherwise returns Nothing.</returns>
	<remarks>
		<para>A CodeSet is created from an existing vocabulary and version for use in the code translation API.
 If the vocabulary version does not exist, the vocabulary and version should be created first before requesting 
 a CodeSet.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyManager.GetCurrentCodeSets">
	<summary>
 Gets an array of the code sets corresponding to the current vocabularies.
 </summary>
	<returns>Returns an array of the current or best code sets, one for each vocabulary, or Nothing if there
 are no vocabularies in the collection.</returns>
	<remarks>
		<para>Gets a new array of CodeSets, with one code set for each vocabulary. Each code set corresponds to 
 the current or best version available for that vocabulary, or a version-less code set if no current or best
 version is available. For each vocabulary, the method gets a CodeSet corresponding to the version that is
 marked as the current version. If a current version does not exist, the method attempts to get the best  
 version available. The best version is either the only version available if there is one version, or the most
 recent if UsesCodeYears is set for the vocabulary. If no best version is available, the CodeSet will be  
 version-less, i.e., have an empty version name.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.VocabularyManager.GetCodes(System.Collections.Generic.ICollection{Quippe.Coding.Vocabulary})">
	<summary>
 Gets a collection of the unique codes of the vocabularies in the specified collection.
 </summary>
	<param name="Vocabularies">Collection of vocabularies from which the unique vocabulary codes will be obtained.</param>
	<returns>Returns a collection of the unique String codes of the vocabularies in the specified collection, or Nothing if
 the specified collection is empty or Nothing.</returns>
	<remarks>Does not determine if all codes within the collection are unique. The codes are not sorted in the returned
 collection.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="T:Quippe.Coding.VocabularyManager">
	<summary>
 Class representing an associative collection of coding system vocabularies.
 </summary>
	<remarks>
		<para>Vocabularies are indexed by their unique String vocabulary code.</para>
		<para>A coding service translation provider (e.g., implementing ITranslator) would typically use a VocabularyManager
 to manage the collection of vocabularies supported for code translation.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="F:Quippe.Coding.Vocabulary.MEDICOMP_VOCAB_SOURCE">
	<summary>The default vocabulary source for vocabularies supplied by Medicomp</summary>
</member><member name="F:Quippe.Coding.Vocabulary.SpecifierUsageEnum.None">
	<summary>Code specifiers are not used.</summary>
</member><member name="F:Quippe.Coding.Vocabulary.SpecifierUsageEnum.Descriptions">
	<summary>Code specifiers are used to qualify descriptions with additional details (e.g., append additional terms/phrases to improve narration)</summary>
</member><member name="F:Quippe.Coding.Vocabulary.SpecifierUsageEnum.Codes">
	<summary>Code specifiers are used to generate more detailed codes and qualify descriptions with additional details</summary>
</member><member name="T:Quippe.Coding.Vocabulary.SpecifierUsageEnum">
	<summary>
 Defines how code specifiers are used by external vocabularies in coding.
 </summary>
</member><member name="F:Quippe.Coding.Vocabulary.CodeYearTypeEnum.None">
	<summary>A value of None means code year is not relevant for the vocabulary.</summary>
</member><member name="F:Quippe.Coding.Vocabulary.CodeYearTypeEnum.Calendar">
	<summary>A value of Calendar indicates the date range of the code year is the calendar year.</summary>
</member><member name="F:Quippe.Coding.Vocabulary.CodeYearTypeEnum.Fiscal">
	<summary>A value of Fiscal indicates the date range of the code year is from 10/1 of prior year (beginning of calendar Q4) to 9/31 of code year (the end of calendar Q3).</summary>
</member><member name="T:Quippe.Coding.Vocabulary.CodeYearTypeEnum">
	<summary>
 Defines the date range (year) types associated with annual releases of reportable vocabularies, such as ICD-10-CM and CPT.
 </summary>
</member><member name="M:Quippe.Coding.Vocabulary.#ctor(System.String,System.String,System.Boolean,System.String,System.String,System.Int32,System.String,System.String,System.Boolean,Quippe.Coding.Vocabulary.SpecifierUsageEnum,Quippe.Coding.Vocabulary.CodeYearTypeEnum)">
	<summary>
 Creates a new Vocabulary object.
 </summary>
	<param name="Code">The string code that uniquely identifies the vocabulary in the API (e.g., "cpt", "icd10" or "rxnorm").</param>
	<param name="Name">Optional short name of the vocabulary, such as an acronym, that is appropriate for
 use in a program user interface (e.g., "CPT", "ICD-10-CM", or "RxNorm").</param>
	<param name="UsesCodeYears">Optional parameter indicating whether versions (version names) of this vocabulary are actually code years (numeric year value in String form, e.g., "2010").</param>
	<param name="LongName">Optional long name of the vocabulary (e.g., "Current Procedural Terminology").</param>
	<param name="Description">Optional description, usually a fully descriptive name of the vocabulary, possibly
 identifying the parent organization (e.g., "Current Procedural Terminology (CPT) of the AMA").</param>
	<param name="Id">Optional (additional) integer identifier of the vocabulary.</param>
	<param name="Source">Optional string identifying the source of the vocabulary.</param>
	<param name="SourceVersion">Optional string identifying the version of the source that provided the vocabulary.</param>
</member><member name="M:Quippe.Coding.Vocabulary.Clone">
	<summary>
 Creates a deep copy of this Vocabulary instance.
 </summary>
	<returns>Returns a deep copy of this Vocabulary instance.</returns>
</member><member name="P:Quippe.Coding.Vocabulary.Code">
	<summary>
 Gets a string value that uniquely identifies the vocabulary.
 </summary>
	<remarks>The Code property is used as the unique vocabulary identifier throughout Quippe.Coding, in the coding service and the
 coding service providers. This value is not designed for use in an application user interface. Valid codes are unique non-empty strings.</remarks>
</member><member name="P:Quippe.Coding.Vocabulary.Name">
	<summary>
 Gets or sets a string value that provides a short name for the vocabulary appropriate for terse display in an 
 application user interface.
 </summary>
	<remarks>The Name is a commonly used abbreviation or acronym for the vocabulary (e.g., "ICD-9-CM" or "SNOMED-CT").</remarks>
</member><member name="P:Quippe.Coding.Vocabulary.LongName">
	<summary>
 Gets or sets a long name for the vocabulary approriate for a more fully 
 descriptive display in an application user interface.
 </summary>
	<remarks>Typically the LongName will spell out the full name that may only appear as an abbreviation or acronym
 in the Name (e.g., "Logical Observation Identifiers Names and Codes (LOINC)" versus "LOINC").</remarks>
</member><member name="P:Quippe.Coding.Vocabulary.Description">
	<summary>
 Gets or sets a string that describes the vocabulary.
 </summary>
	<remarks>The Description of the vocabulary may be more detailed than the full name, possibly including the
 name of the organization that administers or owns the vocabulary.</remarks>
</member><member name="P:Quippe.Coding.Vocabulary.Id">
	<summary>
 Optional integer identifier of the vocabulary.
 </summary>
	<remarks>This integer identifier is an optional value. Uniqueness is not enforced in Quippe.Coding and usage is
 entirely at the discretion of the provider that creates the vocabularies. On the other hand, the Code property 
 must be used to uniquely identify the vocabulary. An Id value of -1 is the default when the Id is undefined.</remarks>
</member><member name="P:Quippe.Coding.Vocabulary.Source">
	<summary>
 Gets or sets a string that identifies the source that provided the vocabulary.
 </summary>
	<remarks>This property is for information only and may identify the source that provided or loaded the 
 vocabulary. Use this property to keep track of which vocabularies you have loaded. Vocabularies loaded by
 Medicomp have the source string given by the constant MEDICOMP_VOCAB_SOURCE.</remarks>
</member><member name="P:Quippe.Coding.Vocabulary.SourceVersion">
	<summary>
 Gets or sets a string that identifies the version of the source that provided the vocabulary.
 </summary>
	<remarks>This property is for information only and may be used with the Source property to identify the 
 version of the source that provided or loaded the vocabulary.</remarks>
</member><member name="P:Quippe.Coding.Vocabulary.UsesCodeYears">
	<summary>
 Gets or sets a value indicating whether the vocabulary has versions that are given in "code years".
 </summary>
	<remarks>
		<para>In some cases, a version is a string representation of a "code year" in the associated vocabulary. A code year 
 is a numeric value, e.g., "2010", identifying a year within the vocabulary for which a given set of codes are valid.
 Not all coding systems or vocabularies are code year based, but typically a coding system used for billing will be
 versioned by year. A coding system that is code year based, may not align the code year with the calendar year.
 For instance, ICD-9-CM code years begin at the start of the 4th quarter (October 1st).
 </para>
		<para>Medicomp distnguishes revisions of its billable code mappings by a "code year" and the process for mapping
 MEDCIN concepts to codes in these vocabularies and performing code translations using these mappings depends
 on these values. This property indicates whether the versions associated with this vocabulary are given by 
 code year and hence determine how mappings are retrieved by the coding service providers. Typically, when given an
 encounter date, and a list of encounter entries containing MEDCIN codes to translate into an external vocabulary
 such as ICD-9-CM, a coding service provider will only look at the maps that have target codes in the
 code year of the encounter or earlier, obtaining the map to the most recent target code available. So the 
 code translation process has some complexity when the vocabulary version is a code year.
 </para>
		<para>If the vocabulary does not use code years, then the code translation process is simpler. In the absence of a
 vocabulary version, a coding service translator would simply return the best mapping available, regardless of version.
 If a version was specified for a vocabulary that doesn't use code years, the code translator would simply return the best
 mapping to a code having the exact same version.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.Vocabulary.IsAutoGenerationCapable">
	<summary>
 Gets or sets a flag that indicates whether the vocabulary is capable of supporting automatic generation of prefixed 
 and qualified mappings.
 </summary>
	<remarks>
		<para>Certain Medicomp code translation providers may support automatic generation of prefixed and qualified mappings
 to vocabularies that support post-coodinated map expressions, such as SNOMED. The providers may check this flag to determine
 which target vocabularies are supported for automatic code generation. If a target vocabulary is supported for
 automatic code generation, and the coding service can find no relevant maps for a qualified MEDCIN code, but there
 is a "base" map for the unqualified MEDCIN code, the coding service may be able to generate a mapping on the fly using
 the base map and domain (term type) of the targeted external code.</para>
	</remarks>
</member><member name="P:Quippe.Coding.Vocabulary.SpecifierUsage">
	<summary>
 Gets or sets a property indicating whether and how the vocabulary uses specifiers.
 </summary>
	<remarks>
		<para>Certain Medicomp code translation providers may support code specifier qualifiers for codes of some external
 vocabularies. Specifiers are used by Medicomp to provide more detailed descriptions or to generate more detailed codes
 when a user selects additional specifiers via specifier lists (picklists). Translation providers may check this flag to 
 determine which target vocabularies use code specifiers, thus allowing them to revoled specifier qualifiers during 
 code translations to either generated more detailed codes or more detailed descriptions.</para>
	</remarks>
</member><member name="P:Quippe.Coding.Vocabulary.UsesSpecifiers">
	<summary>
 Indicates whether the vocabulary uses specifiers (e.g., to qualify code descriptions or generate codes).
 </summary>
	<remarks>
		<para>Certain Medicomp code translation providers may support code specifier qualifiers for codes of some external
 vocabularies. Specifiers are used by Medicomp to provide more detailed descriptions or to generate more detailed codes
 when a user selects additional specifiers via specifier lists (picklists). Translation providers may check this flag to 
 determine which target vocabularies use code specifiers, thus allowing them to revoled specifier qualifiers during 
 code translations to either generated more detailed codes or more detailed descriptions.</para>
	</remarks>
</member><member name="P:Quippe.Coding.Vocabulary.CodeYearType">
	<summary>
 Gets or sets a type associated with the vocabulary that indicates how the date range for the code year is
 determined for the vocabulary.
 </summary>
</member><member name="M:Quippe.Coding.Vocabulary.ToString">
	<summary>
 Returns a string representation of the current vocabulary instance.
 </summary>
	<returns>Returns a string that represents the current vocabulary instance.</returns>
</member><member name="M:Quippe.Coding.Vocabulary.GetCodeSet">
	<summary>
 Gets a new version-less CodeSet object corresponding to this vocabulary.
 </summary>
	<returns>Returns a CodeSet object corresponding to this vocabulary.</returns>
	<remarks>A CodeSet is created from an existing vocabulary for use in the code translation API. The CodeSet has
 an empty version name. If the vocabulary does not exist, one should be created first before requesting a 
 CodeSet.</remarks>
	<seealso cref="T:Quippe.Coding.CodeSet"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
</member><member name="P:Quippe.Coding.Vocabulary.Versions">
	<summary>
 Gets the collection of versions associated with the vocabulary.
 </summary>
	<remarks>
		<para>A vocabulary may have multiple versions. Only one version may be the current version, as 
 indicated by the CurrentVersion property.</para>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.Vocabulary.VersionNames">
	<summary>
 Gets a collection of unique names of the versions associated with this vocabulary. 
 </summary>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.Vocabulary.CurrentVersion">
	<summary>
 Gets the version of this vocabulary that is marked as the current version.
 </summary>
	<returns>The current VocabularyVersion if one exists, or Nothing otherwise.</returns>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.Vocabulary.BestVersion">
	<summary>
 Gets the version of this vocabulary that is the best version.
 </summary>
	<returns>The current, most recent, or only version if one exists, otherwise Nothing.</returns>
	<remarks>
		<para>If there is only one version available, that version is assumed to be the best version. Otherwise, the best 
 version is set to the current version, if one exists (as determined by CurrentVersion property). If the current
 version is not set, and the vocabulary uses code years (UsesCodeYears is set), then the most recent version is
 obtained, determined by comparing the code years stored in the version name. The method returns Nothing if a
 best version cannot be determined.</para>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.Vocabulary.MostRecentVersion">
	<summary>
 Gets the version of this vocabulary that is the most recent version, provided the Vocabulary uses code years as
 version names (UsesCodeYears is set).
 </summary>
	<returns>Returns the most recent version by comparing the code year stored in the version name property and 
 choosing the version with the greatest (most recent) value or returns Nothing if the vocabulary does not use
 code years or if the version names are not numeric.</returns>
	<remarks>
		<para>In some cases, a vocabulary version is a string representation of a "code year" in the associated vocabulary. A code year 
 is a numeric value, e.g., "2010", identifying a year within the vocabulary for which a given set of codes are valid.
 Not all coding systems or vocabularies are code year based, but typically a coding system used for billing will be
 versioned by year. A coding system that is code year based, may not align the code year with the calendar year.
 For instance, ICD-9-CM code years begin at the start of the 4th quarter (October 1st). See the <see cref="P:Quippe.Coding.Vocabulary.UsesCodeYears"/>
 property for more information.
 </para>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.Vocabulary.OldestVersion">
	<summary>
 Gets the version of this vocabulary that is the oldest version, provided the Vocabulary uses code years as
 version names (UsesCodeYears is set).
 </summary>
	<returns>Returns the oldest version by comparing the code year stored in the version name property and 
 choosing the version with the smallest (oldest) value or returns Nothing if the vocabulary does not use
 code years or if the version names are not numeric.</returns>
	<remarks>
		<para>In some cases, a version is a string representation of a "code year" in the associated vocabulary. A code year 
 is a numeric value, e.g., "2010", identifying a year within the vocabulary for which a given set of codes are valid.
 Not all coding systems or vocabularies are code year based, but typically a coding system used for billing will be
 versioned by year. A coding system that is code year based, may not align the code year with the calendar year.
 For instance, ICD-9-CM code years begin at the start of the 4th quarter (October 1st). See the <see cref="P:Quippe.Coding.Vocabulary.UsesCodeYears"/>
 property for more information.
 </para>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="M:Quippe.Coding.Vocabulary.HasVersion(System.String)">
	<summary>
 Determines whether the vocabulary contains a version with the specified name.
 </summary>
	<param name="VersionName">The String name of the version to locate in the voabulary.</param>
	<returns>Returns True if a version with the specified name is contained in the vocabulary and False otherwise.</returns>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="M:Quippe.Coding.Vocabulary.IsCurrentVersion(System.String)">
	<summary>
 Determines whether the specified version name is the name of the current version.
 </summary>
	<param name="VersionName">The version name to check against the current version name.</param>
	<returns>Returns True if a current version exists in the vocabulary and if the specified version name
 matches the name of the current version in a case-insensitive comparison, otherwise returns False.</returns>
	<remarks>
		<para>If the VersionName is null or empty or if CurrentVersion is Nothing, the function returns False.</para>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="M:Quippe.Coding.Vocabulary.CoversVersion(System.String)">
	<summary>
 Determines whether the vocabulary contains the specified named version or handles the specified version as a
 code year within the code years covered by the vocabulary.
 </summary>
	<param name="VersionName">The version name, either a specific version string or a code year.</param>
	<returns>If the vocabulary uses code years, returns True if the specified version name is a code year and is
 between the oldest and most recent code year (inclusive) covered by the vocabulary, and False otherwise. 
 If the vocabulary does not use code years, returns True if the specified version name is contained in the
 vocabulary's collection of versions.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the UsesCodeYears property is True and the specified VersionName
 is not an Integer (i.e., Integer.Parse throws an exception).</exception>
	<remarks>
		<para>This method can be used to validate that the vocabulary handles the specified named version for
 the purposes of code translation. If the version name is a code year, the version name, as a code year is covered 
 by this vocabulary if the version names of the contained versions, as code years, span the specified code year.
 This method only uses the names of versions and does not check the start and end dates of each version.</para>
		<para>In some cases, a version is a string representation of a "code year" in the associated vocabulary. A code year 
 is a numeric value, e.g., "2010", identifying a year within the vocabulary for which a given set of codes are valid.
 Not all coding systems or vocabularies are code year based, but typically a coding system used for billing will be
 versioned by year. A coding system that is code year based, may not align the code year with the calendar year.
 For instance, ICD-9-CM code years begin at the start of the 4th quarter (October 1st). See the <see cref="P:Quippe.Coding.Vocabulary.UsesCodeYears"/>
 property for more information.
 </para>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="M:Quippe.Coding.Vocabulary.CoversCodeYear(System.Int32)">
	<summary>
 Determines whether the vocabulary handles the specified version as a code year within the code years covered
 by the vocabulary.
 </summary>
	<param name="CodeYear">The code year to check against the covered code years of the vocabulary.</param>
	<returns>Returns True if the vocabulary uses code years and the specified code year is between the oldest and
 most recent code year (inclusive), and False otherwise.</returns>
	<remarks>
		<para>This method can be used to validate that the vocabulary handles the specified code year for the
 purposes of translation. To determine coverage this method only uses the names of versions, converted to code 
 years, and does not check the start and end dates of each version. For this reason the method is private as it
 might be confusing.</para>
		<para>In some cases, a version is a string representation of a "code year" in the associated vocabulary. A code year 
 is a numeric value, e.g., "2010", identifying a year within the vocabulary for which a given set of codes are valid.
 Not all coding systems or vocabularies are code year based, but typically a coding system used for billing will be
 versioned by year. A coding system that is code year based, may not align the code year with the calendar year.
 For instance, ICD-9-CM code years begin at the start of the 4th quarter (October 1st). See the <see cref="P:Quippe.Coding.Vocabulary.UsesCodeYears"/>
 property for more information.
 </para>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="M:Quippe.Coding.Vocabulary.AddVersion(Quippe.Coding.VocabularyVersion)">
	<summary>
 Adds the specified version to the vocabulary's collection of versions.
 </summary>
	<param name="Version">The version to add to the vocabulary</param>
	<returns>Returns True, if the version was added and False, otherwise.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown for the following reasons:
 <list type="bullet">
			<item><description>if the Version parameter is Nothing</description></item>
			<item><description>if the specified version has the <see cref="P:Quippe.Coding.VocabularyVersion.IsCurrent"/> property set to True and another version in the vocabulary already
 has the IsCurrent version set to True</description></item>
			<item><description>if the Vocabulary uses code years (UsesCodeYears property is True), but the specified Version does not use
 code years</description></item>
			<item><description>if the Vocabulary uses code years, but the Version's Name property is not a valid code year.</description></item>
		</list>
	</exception>
	<remarks>
		<para>The specified version must have a unique name within the vocabulary, otherwise the version will not
 be added. Only one version within the vocabulary may be the current version, that is, may have the VocabularyVersion.IsCurrent 
 property set to True. If the vocabulary uses code years, then the specified version must be a code year.</para>
		<para>A CodingArgumentException is thrown in these cases:</para>
		<para>In some cases, a version is a string representation of a "code year" in the associated vocabulary. A code year 
 is a numeric value, e.g., "2010", identifying a year within the vocabulary for which a given set of codes are valid.
 Not all coding systems or vocabularies are code year based, but typically a coding system used for billing will be
 versioned by year. A coding system that is code year based, may not align the code year with the calendar year.
 For instance, ICD-9-CM code years begin at the start of the 4th quarter (October 1st). See the <see cref="P:Quippe.Coding.Vocabulary.UsesCodeYears"/>
 property for more information.
 </para>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="M:Quippe.Coding.Vocabulary.GetVersion(System.String)">
	<summary>
 Gets the version of the vocabulary that has the specified name.
 </summary>
	<param name="VersionName">The unique string name of the desired version.</param>
	<returns>Returns a reference to the VocabularyVersion object with the specified name if found, otherwise, 
 returns Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the VersionName parameter is empty or Nothing.</exception>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="M:Quippe.Coding.Vocabulary.GetVersion(System.DateTime)">
	<summary>
 Gets the version of the vocabulary, if any, that is applicable to the specified date.
 </summary>
	<param name="aDate">The date to check against the start and end dates of this vocabulary's versions.</param>
	<returns>Returns a reference to the VocabularyVersion object that is applicable to the specified date, 
 if found, otherwise, returns Nothing. A version is applicable to the date, if the date falls within the
 date range given by the version's start and end dates.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the date specified in aDate is Nothing.</exception>
	<remarks>
		<para>This method searches for the first version that has a start and end date range containing the
 specified date. If start and end date information is not available or incomplete or if the date is not
 contained in any version's start and end date range, then this method returns Nothing.</para>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="M:Quippe.Coding.Vocabulary.RemoveVersion(System.String)">
	<summary>
 Removes the version with the specified name from the vocabulary's version collection.
 </summary>
	<param name="VersionName">The unique String name of the version to remove.</param>
	<returns>Returns a reference to the VocabularyVersion object that was removed, if found, otherwise returns 
 Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the VersionName parameter is empty or Nothing.</exception>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="M:Quippe.Coding.Vocabulary.ClearVersions">
	<summary>
 Removes all versions from the vocabulary and resets version data.
 </summary>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class for more information on vocabulary versions.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.Vocabulary.TermTypes">
	<summary>
 Gets the collection of term types associated with the vocabulary.
 </summary>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.TermType"/> class for more information on term types.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TermType"/>
</member><member name="P:Quippe.Coding.Vocabulary.TermTypeNames">
	<summary>
 Gets a collection of the unique names of the term types associated with this vocabulary.
 </summary>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.TermType"/> class for more information on term types.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TermType"/>
</member><member name="M:Quippe.Coding.Vocabulary.HasTermType(System.String)">
	<summary>
 Determines whether the vocabulary contains a term type with the specified name.
 </summary>
	<param name="TermTypeName">The String name of the term type to locate in the voabulary.</param>
	<returns>Returns True if a term type with the specified name is contained in the vocabulary and False otherwise.</returns>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.TermType"/> class for more information on term types.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TermType"/>
</member><member name="M:Quippe.Coding.Vocabulary.AddTermType(Quippe.Coding.TermType)">
	<summary>
 Adds the specified term type to the vocabulary's collection of term types.
 </summary>
	<param name="TermType">The term type to add to the vocabulary</param>
	<returns>Returns True, if the term type was added and False, otherwise.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the TermType parameter is Nothing.</exception>
	<remarks>
		<para>The specified term type must have a unique name within the vocabulary, otherwise the term type will
 not be added.</para>
		<para>See the <see cref="T:Quippe.Coding.TermType"/> class for more information on term types.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TermType"/>
</member><member name="M:Quippe.Coding.Vocabulary.GetTermType(System.String)">
	<summary>
 Gets the term type of the vocabulary that has the specified name.
 </summary>
	<param name="TermTypeName">The unique string name of the desired term type.</param>
	<returns>Returns a reference to the TermType object with the specified name, if found, otherwise, returns 
 Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the TermTypeName parameter is empty or Nothing.</exception>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.TermType"/> class for more information on term types.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TermType"/>
</member><member name="M:Quippe.Coding.Vocabulary.GetTermType(System.Int32)">
	<summary>
 Gets the term type of the vocabulary that has the specified integer identifier.
 </summary>
	<param name="Id">The unique integer ID of the desired term type.</param>
	<returns>Returns a reference to the TermType object with the specified ID, if found, otherwise, returns 
 Nothing.</returns>
	<remarks>
		<para>The term type ID property is optional. Use the term type Name property for unique identification unless
 you know the vocabulary supports integer IDs for term types. See the <see cref="P:Quippe.Coding.TermType.Id"/> property for 
 more information.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TermType"/>
</member><member name="M:Quippe.Coding.Vocabulary.RemoveTermType(System.String)">
	<summary>
 Removes the term type with the specified name from the vocabulary's term type collection.
 </summary>
	<param name="TermTypeName">The unique String name of the term type to remove.</param>
	<returns>Returns a reference to the TermType object that was removed, if found, otherwise returns Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the TermTypeName parameter is empty or Nothing.</exception>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.TermType"/> class for more information on term types.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TermType"/>
</member><member name="M:Quippe.Coding.Vocabulary.ClearTermTypes">
	<summary>
 Removes all term types from the vocabulary.
 </summary>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.TermType"/> class for more information on term types.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TermType"/>
</member><member name="P:Quippe.Coding.Vocabulary.Qualifiers(Quippe.Coding.CodingQualifier.QualifierTypeEnum)">
	<summary>
 Gets the collection of qualifiers of the specified type associated with the vocabulary.
 </summary>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.CodingQualifier"/> class for more information on qualifiers.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
</member><member name="P:Quippe.Coding.Vocabulary.QualifierNames(Quippe.Coding.CodingQualifier.QualifierTypeEnum)">
	<summary>
 Gets a collection of the unique names of the qualifiers of the specified type associated with this vocabulary.
 </summary>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.CodingQualifier"/> class for more information on qualifiers.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
</member><member name="M:Quippe.Coding.Vocabulary.HasQualifier(Quippe.Coding.CodingQualifier.QualifierTypeEnum,System.String)">
	<summary>
 Determines whether the vocabulary contains a qualifier of the specified type with the specified name.
 </summary>
	<param name="QualifierType">The type of the qualifier to locate in the vocabulary.</param>
	<param name="QualifierName">The String name of the qualifier to locate in the vocabulary.</param>
	<returns>Returns True if a qualifier with the specified type and name is contained in the vocabulary and False otherwise.</returns>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.CodingQualifier"/> class for more information on qualifiers.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
</member><member name="M:Quippe.Coding.Vocabulary.AddQualifier(Quippe.Coding.CodingQualifier)">
	<summary>
 Adds the specified qualifier to the vocabulary's collection of qualifiers.
 </summary>
	<param name="Qualifier">The qualifier to add to the vocabulary.</param>
	<returns>Returns True, if the qualifier was added and False, otherwise.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the Qualifier parameter is Nothing.</exception>
	<remarks>
		<para>The specified qualifier must have a unique name within the qualifier type within the vocabulary, otherwise map qualifier will
 not be added.</para>
		<para>See the <see cref="T:Quippe.Coding.CodingQualifier"/> class for more information on qualifiers.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
</member><member name="M:Quippe.Coding.Vocabulary.GetQualifier(Quippe.Coding.CodingQualifier.QualifierTypeEnum,System.String)">
	<summary>
 Gets the qualifier of the vocabulary that has the specified type and name.
 </summary>
	<param name="QualifierType">The type of the desired qualifier.</param>
	<param name="QualifierName">The string name of the desired qualifier, unique within the qualifier type.</param>
	<returns>Returns a reference to the qualifier object with the specified name, if found, otherwise, 
 returns Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the QualifierName parameter is empty or Nothing.</exception>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.CodingQualifier"/> class for more information on qualifiers.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
</member><member name="M:Quippe.Coding.Vocabulary.GetQualifier(System.Int32,Quippe.Coding.CodingQualifier.QualifierTypeEnum)">
	<summary>
 Gets the qualifier of the vocabulary that has the specified integer identifier.
 </summary>
	<param name="Id">The unique integer ID of the desired qualifier.</param>
	<param name="QualifierType">The type of qualifier to get.</param>
	<returns>Returns a reference to the CodingQualifier object with the specified ID, if found, otherwise, returns 
 Nothing.</returns>
	<remarks>
		<para>The qualifier ID property is optional. Use the qualifier's <see cref="P:Quippe.Coding.CodingQualifier.Name">Name</see> property 
 for unique identification unless you know the vocabulary supports integer IDs for qualifiers. See the 
 <see cref="P:Quippe.Coding.CodingQualifier.Id"/> property for more information.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
</member><member name="M:Quippe.Coding.Vocabulary.RemoveQualifier(Quippe.Coding.CodingQualifier.QualifierTypeEnum,System.String)">
	<summary>
 Removes the qualifier with the specified type and name from the vocabulary's qualifier collection.
 </summary>
	<param name="QualifierType">The type of the qualifier to remove.</param>
	<param name="QualifierName">The string name of the qualifier to remove, unique within the qualifier type.</param>
	<returns>Returns a reference to the qualifier object that was removed, if found, otherwise returns 
 Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the QualifierName parameter is empty or Nothing.</exception>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.CodingQualifier"/> class for more information on qualifiers.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
</member><member name="M:Quippe.Coding.Vocabulary.ClearQualifiers(Quippe.Coding.CodingQualifier.QualifierTypeEnum)">
	<summary>
 Removes all qualifiers of the specified type from the vocabulary.
 </summary>
	<param name="QualifierType">The type of the qualifiers to remove.</param>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.CodingQualifier"/> class for more information on qualifiers.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
</member><member name="P:Quippe.Coding.Vocabulary.Prefixes">
	<summary>
 Gets the collection of Prefixes associated with the vocabulary.
 </summary>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.Prefix"/> class for more information on prefixes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Prefix"/>
</member><member name="P:Quippe.Coding.Vocabulary.PrefixCodes">
	<summary>
 Gets a collection of the unique codes of the prefixes associated with this vocabulary.
 </summary>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.Prefix"/> class for more information on prefixes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Prefix"/>
</member><member name="P:Quippe.Coding.Vocabulary.TopLevelPrefixCodes">
	<summary>
 Gets a collection of the unique codes of the top-level prefixes associated with this vocabulary.
 </summary>
	<remarks><para>A top-level prefix is a prefix that does not have a parent. See the <see cref="T:Quippe.Coding.Prefix"/> class 
 for more information.</para>&gt;</remarks>
	<seealso cref="T:Quippe.Coding.Prefix"/>
</member><member name="M:Quippe.Coding.Vocabulary.HasPrefix(System.String)">
	<summary>
 Determines whether the vocabulary contains a prefix with the specified code.
 </summary>
	<param name="PrefixCode">The String code of the prefix to locate in the vocabulary.</param>
	<returns>Returns True if a prefix with the specified name is contained in the vocabulary and False otherwise.</returns>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.Prefix"/> class for more information on prefixes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Prefix"/>
</member><member name="M:Quippe.Coding.Vocabulary.AddPrefix(Quippe.Coding.Prefix)">
	<summary>
 Adds the specified prefix to the vocabulary's collection of prefixes.
 </summary>
	<param name="Prefix">The prefix to add to the vocabulary</param>
	<returns>Returns True, if the prefix was added and False, otherwise.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the Prefix parameter is Nothing.</exception>
	<remarks>
		<para>The specified prefix must have a unique name within the vocabulary, otherwise the prefix will
 not be added.See the <see cref="T:Quippe.Coding.Prefix"/> class for more information on prefixes.</para>
		<para>See the <see cref="T:Quippe.Coding.Prefix"/> class for more information on prefixes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Prefix"/>
</member><member name="M:Quippe.Coding.Vocabulary.GetPrefix(System.String)">
	<summary>
 Gets the prefix of the vocabulary that has the specified code.
 </summary>
	<param name="PrefixCode">The unique string code of the desired prefix.</param>
	<returns>Returns a reference to the Prefix object with the specified code, if found, otherwise, 
 returns Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the PrefixCode parameter is empty or Nothing.</exception>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.Prefix"/> class for more information on prefixes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Prefix"/>
</member><member name="M:Quippe.Coding.Vocabulary.RemovePrefix(System.String)">
	<summary>
 Removes the prefix with the specified code from the vocabulary's prefix collection.
 </summary>
	<param name="PrefixCode">The unique String code of the prefix to remove.</param>
	<returns>Returns the a reference to the Prefix object that was removed, if found, otherwise returns 
 Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the PrefixCode parameter is empty or Nothing.</exception>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.Prefix"/> class for more information on prefixes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Prefix"/>
</member><member name="M:Quippe.Coding.Vocabulary.ClearPrefixes">
	<summary>
 Removes all prefixes from the vocabulary.
 </summary>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.Prefix"/> class for more information on prefixes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Prefix"/>
</member><member name="T:Quippe.Coding.Vocabulary">
	<summary>
 Represents a medical terminology or coding system vocabulary consisting of medical terms or concepts, each 
 defined by a unique identifier or code.
 </summary>
	<remarks>A vocabulary may have multiple versions, term types and associated code prefixes and map qualifiers.
 MEDCIN server version 2 uses code types to define mappable code sets. The coding service in the CliniTalk SDK 
 defines mappable code sets by coding system vocabulary objects, which may be broader in scope than the MEDCIN
 code type for code mapping purposes. Additional properties of the vocabulary, including term types, MEDCIN 
 prefixes and map qualifiers narrow that scope to provide the same level of detail as MEDCIN but with a more
 flexible and extensible model.
 </remarks>
	<seealso cref="T:Quippe.Coding.CodeSet"/>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
	<seealso cref="T:Quippe.Coding.Prefix"/>
	<seealso cref="T:Quippe.Coding.TermType"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.VocabularyManager"/>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.Vocabularies.CccVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "CCC" and code, "ccc"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.CdtVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "CDT" and code, "cdt"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.CptVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "CPT" and code, "cpt"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.CptmodVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "CPTMod" and code, "cptmod"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.CvxVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "CVX" and code, "cvx"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.DoducVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "DoD Unique Codes" and code, "doduc"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.DsmVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "DSM" and code, "dsm"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.IcdVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "ICD-9-CM" and code, "icd"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.Icd10Vocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "ICD-10-CM" and code, "icd10"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.IcdoVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "ICD-O-3" and code, "icdo"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.LoincVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "LOINC" and code, "loinc"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.MedcinVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "MEDCIN" and code, "medcin"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.RxnormVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "RxNorm" and code, "rxnorm"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.SnomedVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "SNOMED-CT" and code, "snomed"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.UniiVocab">
	<summary>Gets the standard Vocabulary object representing the standard vocabulary that has the name, "SRS UNII" and code, "unii"</summary>
</member><member name="P:Quippe.Coding.Vocabularies.StandardCodes">
	<summary>
 Gets the collection of unique vocabulary codes of the standard vocabularies managed by this class.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.Vocabularies.GetStandardValue(System.String)">
	<summary>
 Gets a deep copy of the standard vocabulary corresponding to the specified unique vocabulary code.
 </summary>
	<param name="VocabCode">String code that uniquely identifies the desired standard vocabulary.</param>
	<returns>Returns a reference to a copy of the standard vocabulary having the specified code or Nothing if a
 standard vocabulary with that code was not found.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.Vocabularies.GetStandardCodeSets">
	<summary>
 Gets an array of code sets that correspond to the standard vocabularies.
 </summary>
	<returns>Returns an array of code sets, one for each standard vocabulary, or Nothing if there are no standard
 vocabularies in the collection.</returns>
	<remarks>Gets a new array of CodeSets, which includes one code set for each standard vocabulary. The code sets 
 have no version specified.</remarks>
	<seealso cref="T:Quippe.Coding.CodeSet"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.Vocabularies.GetStandardCodeSet(System.String)">
	<summary>
 Gets a CodeSet for the standard vocabulary that has the specified unique code.
 </summary>
	<param name="VocabCode">Unique code of the standard vocabulary associated with the desired CodeSet.</param>
	<returns>Returns a CodeSet object corresponding to the requested vocabulary, if it exists, otherwise returns
 Nothing.</returns>
	<remarks>A CodeSet is created from an existing vocabulary for use in the code translation API. The CodeSet has
 an empty version name.</remarks>
	<seealso cref="T:Quippe.Coding.CodeSet"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Vocabularies.MedcinVocabCode">
	<summary>
 Gets the unique vocabulary code for the MEDCIN vocabulary.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.Vocabularies.IsMedcinVocabCode(System.String)">
	<summary>
 Determines if the specified vocabulary code is the MEDCIN vocabulary code.
 </summary>
	<param name="VocabCode">The vocabulary code to check.</param>
	<returns>Returns True if the specified VocabCode is the same as the MEDCIN vocabulary code, using
 a case-insensitive, culture sensitive, String comparison, and returns False otherwise.</returns>
	<remarks></remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.Vocabularies.GetVocabId(System.String)">
	<summary>
 Gets the unique integer identifier of the specified vocabulary.
 </summary>
	<param name="VocabCode">Unique code of the standard vocabulary for which the identifier is desired.</param>
	<returns>Returns the integer identifier of the vocabulary, if the specified vocabulary exists and if the
 vocabulary has a valid integer identifier, otherwise returns -1.</returns>
	<remarks><para>The integer identifier is an optional property of a vocabulary. See the <see cref="P:Quippe.Coding.Vocabulary.Id"/> 
 property for more information.</para></remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.Vocabularies.LoadConditional">
	<summary>
 Creates a new standard vocabulary collection and then adds the standard vocabularies to the collection.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="T:Quippe.Coding.Vocabularies">
	<summary>
 Class that provides access to the standard collection of vocabularies and that provides methods to retrieve standard 
 CodeSets associated with (created from) these vocabularies.
 </summary>
	<remarks>
		<para>This class is basically a singleton instance of a VocabularyManager that contains all the standard
 vocabularies that are loaded or defined within Quippe.Coding.
 The standard vocabularies and associated code sets are accessible through the shared members of this class by 
 specifying either the unique vocabulary code or by using the generated properties (e.g., Icd9Vocab property to
 retireve the standard ICD-9-CM vocabulary). However, the class always returns a copy of the standard vocabulary, 
 thus ensuring it cannot be modified. If additional vocabularies need to be defined to support mappings provided by 
 ITranslator providers other than a standard Medicomp provider, or if a standard vocabulary needs to be modified, then 
 additional Vocabulary instances can be created and stored external to this class.</para>
		<para>The standard vocabularies are created by generated code (a Partial class) in VocabulariesGenerated.vb. This 
 code is generated from the Coding Service Database by the CodeGenerator.Generator project.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSet"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
	<seealso cref="T:Quippe.Coding.VocabularyManager"/>
</member><member name="M:Quippe.Coding.TermType.#ctor(System.String,System.String,System.String,System.Int32,System.String)">
	<summary>
 Creates a new TermType object.
 </summary>
	<param name="Name">Short name that uniquely identifies the term type within an associated vocabulary.</param>
	<param name="DisplayName">Optional string that serves as display name of the term type in the user interface.</param>
	<param name="Description">Description of the term type.</param>
	<param name="Id">Optional (additional) integer identifier of the term type.</param>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.TermType.Name">
	<summary>
 Gets or sets a String value that uniquely identifies the term type within an associated vocabulary.
 </summary>
	<remarks>Name is the primary unique identifier of the term type within an associated vocabulary. The Name may be used 
 for terse display in an application user interface and/or if a DisplayName is not
 provided. Valid names are non-empty strings unique within the vocabulary. Uniqueness by name is enforced within 
 the Vocabulary class to which the TermType instance is assigned.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.TermType.DisplayName">
	<summary>
 Gets a string value that serves as the display name of the term type in the user interface.
 </summary>
	<remarks>If the DisplayName is empty, the Name is returned instead.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.TermType.Description">
	<summary>
 Gets or sets an optional description of the term type.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.TermType.VocabValue">
	<summary>
 Gets or sets the optional alternate value the term type may be assigned in the associated vocabulary, if that differs
 from the term type Name property.
 </summary>
	<remarks>The VocabValue is an optional alternative means of identifying the term type within the associated vocabulary.
 The Name property remains the primary unique identifier of the term type.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.TermType.Id">
	<summary>
 Optional integer identifier of the term type.
 </summary>
	<remarks>This integer identifier is an optional value. The identifier would normally uniquely identify the term
 type across all vocabularies, although uniqueness is not enforced and usage is entirely at the discretion of 
 the provider that creates the vocabularies. On the other hand, the Name property is used to uniquely identify
 the term type within the vocabulary. An Id value of -1 is the default when the Id is undefined.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.TermType.ToString">
	<summary>
 Returns a string representation of the current instance.
 </summary>
	<returns>Returns a string that represents the object.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.TermType.Clone">
	<summary>
 Creates a new object that is a copy of the current instance.
 </summary>
	<remarks>Creates a deep copy of the current TermType instance and returns the copy as an Object.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="T:Quippe.Coding.TermType">
	<summary>
 Class representing a type, domain, or sub-type of a concept within a coding system vocabulary.
 </summary>
	<remarks>
		<para>Certain coding system vocabularies may be best represented as having term types or sub-types that 
 differentiate certains types of concepts within the vocabulary. For instance, ICD for Oncology Rev. 3 
 (ICD-O-3) has a Morhpology axis and a Topography axis which can be represented as separate term types. Also,
 RxNorm defines separate term types for ingredient (IN), semantic clinical drug (SCD), and so on.</para>
		<para>Term types are associated with a Vocabulary object. The Vocabulary object maintains a collection of term
 types that are supported by the vocabulary.</para>
		<para>A term type could be used to represent the domain of a concept. However, in Medicomp coding data, the term type is
 usually a coding system dependent type, whereas domains may be better represented as categories that are
 relevant across all coding systems.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.Prefix.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean,System.Boolean,System.Boolean)">
	<summary>
 Creates a new Prefix object.
 </summary>
	<param name="Code">Unique string code that uniquely identifies the prefix within the associated vocabulary.</param>
	<param name="Name">Optional string name of the prefix that could be used as a terse caption in an application
 user interface.</param>
	<param name="DisplayName">Optional string that serves as display name of the prefix in the user interface.</param>
	<param name="ParentCode">Optional prefix code of the parent prefix, if the prefix is a sub-prefix.</param>
	<param name="Category">Optional category to which the prefix belongs.</param>
	<param name="Description">Optional string description of the prefix.</param>
	<param name="Mappable">Optional flag indicating whether prefix may appear in Medicomp mappings as a qualification of the source Medcin concept.</param>
	<param name="Ignore">Optional flag indicating whether the prefix is ignored when resolving mappings during a code translation.</param>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.Code">
	<summary>
 Gets the unique string code that identifies the prefix within the associated vocabulary. 
 </summary>
	<remarks>MEDCIN prefixes are one or two characters long.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.Name">
	<summary>
 Gets or sets a short string Name for the prefix.
 </summary>
	<remarks>The Name is adequate for a terse display or if no DisplayName is specified.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.DisplayName">
	<summary>
 Gets a string value that serves as the name of the prefix in the user interface.
 </summary>
	<remarks>If the DisplayName is empty, the Name is returned instead.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.ParentCode">
	<summary>
 Gets the unique string code that identifies the parent prefix if this is a sub-prefix. 
 </summary>
	<remarks><para>If a prefix has an empty ParentCode, then the prefix is a top-level prefix.</para>
		<para>There are two types of prefixes, top-level prefixes and sub-prefixes. A top-level prefix has no parent and
 in addition to operating as a prefix for mapping purposes, may also represent the parent of a collection of prefixes
 that refine the parent prefix. A sub-prefix has a non-empty ParentCode property and refines the top-level parent. For instance,
 the top-level "Family history of" prefix may have sub-prefixes "Paternal history of", "Maternal history of" and so on.
 Medicomp mappings use only top-level prefixes. If a MEDCIN concept qualified by a sub-prefix is presented for translation,
 a Medicomp translator will use the parent prefix of the sub-prefix to determine the appropriate mapping records to
 return.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.HasParent">
	<summary>
 Indicates whether the prefix has a parent.
 </summary>
	<returns>Returns True if the prefix has a parent and False otherwise.</returns>
	<remarks><para>If a prefix has an empty <see cref="P:Quippe.Coding.Prefix.ParentCode"/> property, then the prefix is a top-level prefix, and does not have a parent.</para>
		<para>There are two types of prefixes, top-level prefixes and sub-prefixes. A top-level prefix has no parent and
 in addition to operating as a prefix for mapping purposes, may also represent the parent of a collection of prefixes
 that refine the parent prefix. A sub-prefix has a non-empty <see cref="P:Quippe.Coding.Prefix.ParentCode"/> and refines the top-level parent. For instance,
 the top-level "Family history of" prefix may have sub-prefixes "Paternal history of", "Maternal history of" and so on.
 Medicomp mappings use only top-level prefixes. If a MEDCIN concept qualified by a sub-prefix is presented for translation,
 a Medicomp translator will use the parent prefix of the sub-prefix to determine the appropriate mapping records to
 return.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.Category">
	<summary>
 Gets or sets a unique string name that identifies the category of the prefix.
 </summary>
	<remarks>
		<para>Some prefixes may have a purpose that is common to other
 similar prefixes. Prefixes may be grouped in categories using the Category property. The category property may be used to 
 establish a non-hierarchical relationship between prefixes, for example, for grouping prefixes that have a common purpose.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.Description">
	<summary>
 Gets or sets a description of the prefix.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.IsMappable">
	<summary>
 Gets or sets a flag indicating whether the prefix may be used to qualify the source Medcin concept in maps from Medcin 
 to external vocabularies.
 </summary>
	<remarks>
		<para>Only prefixes with the IsMappable property set to True are used to qualify Medcin concepts in Medicomp mappings.
 Prefixes for which IsMappable is False, are either ignored or not when a map is requested for a prefixed Medcin concept.
 Prefixes that are ignored during code translation (i.e.,<see cref="P:Quippe.Coding.Prefix.Ignore"/> property set to True) have no affect on
 translation, meaning the prefix does not filter or restrict the potential mapping results. However, prefixed that are
 not ignored during code translation only match mapping records in which the source Medcin concept is qualified by the
 prefix. Thus, if a Medcin concept is submitted for code translation with a prefix that is not mappable and not ignored,
 no mapping results will be returned.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.Ignore">
	<summary>
 Gets or sets a flag indicating whether the prefix will be ignored during code translation of a source Medcin concept.
 </summary>
	<remarks>
		<para>Only prefixes with the <see cref="P:Quippe.Coding.Prefix.IsMappable"/> property set to True are used to qualify Medcin concepts in 
 Medicomp mappings. Prefixes for which IsMappable is False, are either ignored or not when a map is requested for 
 a prefixed Medcin concept. Prefixes that are ignored during code translation have no affect on
 translation, meaning the prefix does not filter or restrict the potential mapping results. However, prefixed that are
 not ignored during code translation only match mapping records in which the source Medcin concept is qualified by the
 prefix. Thus, if a Medcin concept is submitted for code translation with a prefix that is not mappable and not ignored,
 no mapping results will be returned.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.AutoMapParent">
	<summary>
 Gets or sets a flag indicating whether the parent prefix, if available, will be used in automatic map generation, rather than the
 prefix itself.
 </summary>
	<remarks>
		<para>During automatic map generation, the prefix is used to determine which map template is used to construct the map
 expression. If the AutoMapParent property is True, the parent prefix will be used, if it is available, otherwise the
 prefix itself is used. This property allows the designation of certain prefixes that by default map at the parent level but
 appear in automatic map generation at the prefix level (by setting this property to False for those prefixes). For example, 
 explicit (non-generated) Medicomp mappings are mapped at the parent prefix level for family history concepts (using prefix F,
 "family history of"). However, when this property is set to False, the automatic map generation feature uses the prefix 
 specified in the encounter, which may be a more detailed family history prefix (e.g., F0, "paternal history of"); thus maps
 generated to SNOMED CT will include the code for "parent of subject" in the generated expression. If the property were set
 to True in this example, the generated expression would not include a code indicating the person having the relationship to
 the patient because the map would be at the general family history level (prefix F).</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.HighestLevelCode">
	<summary>
 Gets the highest level prefix code associated with this prefix, either the code of the parent prefix, from the
 <see cref="P:Quippe.Coding.Prefix.ParentCode"/> property, if any, or this prefix's code.
 </summary>
	<remarks>Only parent-level prefixes are used in Medicomp code maps. This property ensures the parent level code
 is returned.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.Prefix.AutoMapCode">
	<summary>
 Gets the prefix code appropriate for automatic map generation, that is associated with this prefix, either the code of the parent prefix, from the
 <see cref="P:Quippe.Coding.Prefix.ParentCode"/> property, if any, or this prefix's code, depending on other property settings such as the <see cref="P:Quippe.Coding.Prefix.AutoMapParent"/> property.
 </summary>
	<remarks><para>Whereas, only parent-level prefixes are used in explicit Medicomp code maps, this is not the case for automatically generated maps. This 
 property returns the appropriate prefix for automatic map generation, which is the parent code if AutoMapParent property is True and the prefix has a 
 parent, otherwise it is the prefix itself.</para></remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.Prefix.ToString">
	<summary>
 Returns a string representation of the current instance.
 </summary>
	<returns>Returns a string that represents the object.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.Prefix.Clone">
	<summary>
 Creates a new object that is a deep copy of the current instance.
 </summary>
	<remarks>Creates a deep copy of the current Prefix instance and returns the copy as an Object.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="T:Quippe.Coding.Prefix">
	<summary>
 Represents a code that may be applied to a medical concept to qualify its meaning or focus in a code mapping.
 </summary>
	<remarks>
		<para>A prefix may be applied to a medical concept to alter its meaning or focus. The combination of prefix and
 concept may be separately mapped to a code in an external vocabulary, independent of a mapping from the concept
 itself. So while there might be a mapping from the MEDCIN concept "Current Smoker" to an external code representing
 that concept, there may also be a mapping from the same MEDCIN concept prefixed with "History of" (prefix code "H")
 that is mapped to a separate concept representing "history of smoking" in the same external vocabulary. At present,
 prefixes in Medicomp code mappings are limited and apply only to MEDCIN concepts.</para>
		<para>Prefixes are associated with a <see cref="T:Quippe.Coding.Vocabulary"/> object. The Vocabulary object maintains a collection of prefixes
 that are supported by the vocabulary.</para>
		<para>There are two types of prefixes, top-level prefixes and sub-prefixes. A top-level prefix has no parent and
 in addition to operating as a prefix for mapping purposes, may also represent the parent of a collection of prefixes
 that refine the parent prefix. A sub-prefix has a non-empty <see cref="P:Quippe.Coding.Prefix.ParentCode"/> property and refines the top-level parent. For instance,
 the top-level "Family history of" prefix may have sub-prefixes "Paternal history of", "Maternal history of" and so on.
 Medicomp mappings use only top-level prefixes. If a MEDCIN concept qualified by a sub-prefix is presented for translation,
 a Medicomp translator will use the parent prefix of the sub-prefix to determine the appropriate mapping records to
 return.
 </para>
		<para>Not all prefixes are necessarily contained in a parent-child relationship with other prefixes. That is, some prefixes
 may simply be top-level prefixes with no sub-prefixes. However, these prefixes may have a purpose that is common to other
 similar prefixes. Prefixes may be grouped in categories using the <see cref="P:Quippe.Coding.Prefix.Category"/> property. The category property may be used to 
 establish a non-hierarchical relationship between prefixes, for example, for grouping prefixes that have a common purpose.  
 </para>
		<para>Prefixes are one way to qualify a MEDCIN concept in a code mapping. MEDCIN concepts may also be qualified by a status
 qualifier (i.e., a <see cref="T:Quippe.Coding.CodingQualifier"/> of type <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.MedcinStatus"/>) that represents the status of a MEDCIN concept.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodingQualifierManager.#ctor">
	<summary>
 Creates a new instance of a CodingQualifierManager.
 </summary>
</member><member name="P:Quippe.Coding.CodingQualifierManager.Qualifiers(Quippe.Coding.CodingQualifier.QualifierTypeEnum)">
	<summary>
 Gets a collection of the managed coding qualifiers that have the specified type.
 </summary>
	<param name="QualifierType">The type of the coding qualifiers to get.</param>
	<returns>Returns a collection of all the qualifiers managed by this manager that have the specified type.</returns>
	<remarks>If there are no qualifiers of the specified type managed by this instance, the returned collection will be empty.</remarks>
</member><member name="P:Quippe.Coding.CodingQualifierManager.QualifierNames(Quippe.Coding.CodingQualifier.QualifierTypeEnum)">
	<summary>
 Gets a collection of the names of the managed coding qualifiers that have the specified type.
 </summary>
	<param name="QualifierType">The type of the coding qualifiers for which names should be returned.</param>
	<returns>Returns a collection of the names of all the qualifiers managed by this manager that have the specified type.</returns>
	<remarks>If there are no qualifiers of the specified type managed by this instance, the returned collection will be empty.</remarks>
</member><member name="M:Quippe.Coding.CodingQualifierManager.Add(Quippe.Coding.CodingQualifier)">
	<summary>
 Adds the specified coding qualifier to the manager.
 </summary>
	<param name="Qualifier">The coding qualifier to add to the manager.</param>
	<returns>Returns True if the specified coding qualifier was successfully added to the manager, and False otherwise. Returns False if the Qualifier is Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if a qualifier with the same name and type value as Qualifier already exists in the manager.</exception>
	<remarks>
		<para>The name of the specified qualifier must be unique to all managed qualifiers of the same type, including those with type, QualifierTypeEnum.Undefined.</para>
	</remarks>
</member><member name="M:Quippe.Coding.CodingQualifierManager.GetQualifier(Quippe.Coding.CodingQualifier.QualifierTypeEnum,System.String)">
	<summary>
 Gets the managed qualifier that has the specified type and name.
 </summary>
	<param name="QualifierType">The type of the desired qualifier.</param>
	<param name="Name">The name of the desired qualifier within the specified type.</param>
	<returns>Returns a reference to the managed qualifier having the specifed type and name, if one exists, otherwise
 returns Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the specified qualifier name is empty.</exception>
</member><member name="M:Quippe.Coding.CodingQualifierManager.Remove(Quippe.Coding.CodingQualifier.QualifierTypeEnum,System.String)">
	<summary>
 Removes the managed qualifier that has the specified type and name.
 </summary>
	<param name="QualifierType">The type of the qualifier to remove from the manager.</param>
	<param name="Name">The name of the qualifier within the specified type to remove from the manager.</param>
	<returns>Returns a reference to the removed qualifier, if a qualifier with the specified type and name was found, otherwise
 returns Nothing.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the specified qualifier name is empty.</exception>
</member><member name="M:Quippe.Coding.CodingQualifierManager.Contains(Quippe.Coding.CodingQualifier.QualifierTypeEnum,System.String)">
	<summary>
 Determines if a qualifier with the specified type and name is contained in the manager.
 </summary>
	<param name="QualifierType">The type of the qualifier for which to determine containment.</param>
	<param name="Name">The name of the qualifier within the specified type for which to determine containment.</param>
	<returns>Returns True if a qualifier with the specified type and name is contained in the manager, or False otherwise.</returns>
</member><member name="M:Quippe.Coding.CodingQualifierManager.Clear(Quippe.Coding.CodingQualifier.QualifierTypeEnum)">
	<summary>
 Removes all qualifiers of the specified type from the manager.
 </summary>
	<param name="QualifierType">The type of qualifiers to remove from the manager.</param>
	<remarks>All qualifiers of the specified type are removed from the manager and the references to those objects are released.</remarks>
</member><member name="M:Quippe.Coding.CodingQualifierManager.GetDictionary(Quippe.Coding.CodingQualifier.QualifierTypeEnum)">
	<summary>
 Gets the QualifierDictionary containing references to all managed qualifiers of the specifited type.
 </summary>
	<param name="QualifierType">The type identifying the desired dictionary of qualifiers.</param>
	<returns>Returns a dictionary containing references to all the managed qualifier objects of the specified type. If there are no qualifiers
 of the specified type, the dictionary will be empty.</returns>
	<remarks></remarks>
</member><member name="M:Quippe.Coding.CodingQualifierManager.Clone">
	<summary>
 Creates a deep copy of this instance.
 </summary>
	<returns>Returns a deep copy of this instance.</returns>
</member><member name="T:Quippe.Coding.CodingQualifierManager">
	<summary>
 Class used to manage a collection of qualifiers of disparate types.
 </summary>
	<remarks>
		<para>This class is designed to manage all of the coding qualifiers relevant to a particular vocabulary. Each
 coding system vocabulary has its own qualifier manager that stores the qualifiers that are relevant to codes and
 maps associated with that vocabulary. See the <see cref="T:Quippe.Coding.Vocabulary"/>class which uses a CodingQualifierManager
 for just this purpose.</para>
	</remarks>
</member><member name="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Undefined">
	<summary>Indicates the qualifier type is undefined, i.e., the qualifier is untyped.</summary>
</member><member name="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Map">
	<summary>Indicates the qualifier applies to code mapping records.</summary>
</member><member name="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Code">
	<summary>Indicates the qualifier applies to codes in an external (non-MEDCIN) vocabulary (i.e., code set).</summary>
</member><member name="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.MedcinStatus">
	<summary>Indicates the qualifier is a status qualifier and applies to MEDCIN concepts.</summary>
</member><member name="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Modifier">
	<summary>Indicates the qualifier is a modifier and applies to MEDCIN concepts.</summary>
</member><member name="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Result">
	<summary>Indicates the qualifier is a result and applies to MEDCIN concepts.</summary>
</member><member name="T:Quippe.Coding.CodingQualifier.QualifierTypeEnum">
	<summary>Defines the qualifier types.</summary>
</member><member name="M:Quippe.Coding.CodingQualifier.#ctor(System.String,System.String,Quippe.Coding.CodingQualifier.QualifierTypeEnum,System.String,System.String,System.Int32)">
	<summary>
 Creates a new CodingQualifier object.
 </summary>
	<param name="Name">The unique name that uniquely identifies the qualifier in its associated qualifier type within an associated vocabulary.</param>
	<param name="DisplayName">Optional string that serves as display name of the qualifier in the user interface.</param>
	<param name="QualifierType">The qualifier type.</param>
	<param name="Category">The optional category within the type to which the qualifier belongs.</param>
	<param name="Description">An optional description of the qualifier.</param>
	<param name="Id">Optional (additional) integer identifier of the qualifier.</param>
	<remarks>If the QualifierType parameter is not specified, it defaults to QualifierTypeEnum.Undefined and the qualifier name given in Name
 should be unique to all qualifiers with type Undefined.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodingQualifier.Name">
	<summary>
 Gets a string value that uniquely identifies the qualifier in its associated qualifier type within an associated vocabulary.
 </summary>
	<remarks>Valid names are non-empty strings unique within the associated qualifier type.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodingQualifier.DisplayName">
	<summary>
 Gets a string value that serves as the name of the qualifier in the user interface.
 </summary>
	<remarks>Returns the empty string is the display name is not defined.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodingQualifier.QualifierType">
	<summary>
 Gets or sets the type of the qualifier.
 </summary>
	<remarks>Qualifier type is used to indicate what type of object the qualifier applies to, for example,
 a "map" qualifier, a "code" or a "medcin status" qualifier.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodingQualifier.Category">
	<summary>
 Gets or sets an optional category of the qualifier.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodingQualifier.Description">
	<summary>
 Gets or sets an optional description of the qualifier.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodingQualifier.Id">
	<summary>
 Optional integer identifier of the qualifier.
 </summary>
	<remarks>
		<para>This integer identifier is an optional value. The identifier would normally uniquely identify the
 qualifier across all qualifier types and vocabularies, although uniqueness is not enforced and usage is entirely at the discretion
 of the provider that creates the vocabularies. On the other hand, the Name property is used to uniquely 
 identify the qualifier within the associated type. An Id value of -1 is the default when the Id is undefined.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodingQualifier.ToString">
	<summary>
 Returns a string representation of the current instance.
 </summary>
	<returns>Returns a string that represents the object.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodingQualifier.Clone">
	<summary>
 Creates a new object that is a copy of the current instance.
 </summary>
	<remarks>Creates a deep copy of the current CodingQualifier instance and returns the copy as an Object.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodingQualifier.QualifierTypeStringToEnum(System.String)">
	<summary>
 Converts a textual representation of a value from <see cref="T:Quippe.Coding.CodingQualifier.QualifierTypeEnum"/> into its equivalent Enum value.
 </summary>
	<param name="QualifierTypeString">The textual representation of a value from the Enum, <see cref="T:Quippe.Coding.CodingQualifier.QualifierTypeEnum"/>, possibly with spaces,
 e.g., "medcin status".</param>
	<returns>Returns the Enum value from <see cref="T:Quippe.Coding.CodingQualifier.QualifierTypeEnum"/> that corresponds to a cleaned up version of the input
 string. If an equivalent Enum value is not found, then <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Undefined"/> is returned.</returns>
	<remarks>The method merely removes spaces from the input string and compares the resulting value, using a case-insensitive
 string comparison, with the name of each Enum value in <see cref="T:Quippe.Coding.CodingQualifier.QualifierTypeEnum"/>.</remarks>
</member><member name="T:Quippe.Coding.CodingQualifier">
	<summary>
 Class representing a qualifier of coding objects, such as external codes, maps and MEDCIN concepts.
 </summary>
	<remarks><para>Qualifiers are used to qualify, refine, or further classify coding objects such as codes or concepts in an external
 coding system, code mapping records, and MEDCIN concepts. Qualifiers are used in Medicomp's code translation service providers and in
 the data underlying the providers. Qualifiers are uniquely identified by a qualifier type and a String name that uniquely identifies
 the qualifier within that type. The remaining qualifier properties are optional.</para>
		<para>Qualifiers are associated with a Vocabulary object. The Vocabulary object contains a CodingQualifierManager that manages
 the qualifiers of each type that are supported by the vocabulary.</para>
		<para>Map qualifiers are used to classify or define the purpose of certain mappings from MEDCIN to external vocabularies that are
 not sufficiently characterized by vocabulary, term type, MEDCIN code prefixes and the mapping relationship. Whereas MEDCIN version 2 
 uses code-types to represent mappable code sets within MEDCIN, CliniTalk defines mappable code sets by the coding system vocabulary, 
 which may be broader in scope than the MEDCIN code type. The addition of term types, MEDCIN prefixes and map qualifiers provides the 
 same level of detailed mapping in CliniTalk as in MEDCIN with the benefit of a more generic coding model. For instance, MEDCIN version
 2 defines a number of ICD-9-CM code types (e.g., "MedCodeICD2" for secondary code mapping, "MedCodeICDALT" for an alternative code 
 mapping). CliniTalk defines a single ICD-9-CM vocabulary and uses map qualifiers (e.g., "Secondary", "Alternate") to further qualify 
 the mapping.</para>
		<para>MEDCIN status qualifiers, modifiers, and result qualifiers apply to MEDCIN concepts. Status qualifiers indicate the status of the 
 associated concept (e.g., "Improving", "Worsening", "Unchanged", "Stable"). Modifiers modify the concept in terms of amount, degree, onset, 
 pattern, quality, severity or urgency (e.g., "Mild", "Intermittent", "Sudden" etc.). Result qualifiers indicate whether the concept was 
 noted normal or abnormal in the patients chart.</para>
		<para>For the purposes of mapping
 from MEDCIN to external vocabularies, an unqualified MEDCIN concept is considered a different concept from the same concept qualified
 by a status qualifier, modifier or result. Thus, if the unqualified concept has a preferred mapping to specific code in an external code set, such as ICD-10-CM, 
 the qualified concept must have its own distinct mapping, if a translation for that qualified mapping is desired. That is, the unqualified
 and qualified MEDCIN findings are distinct concepts, and each will have its own maps.</para>
		<para>Code qualifiers are used to qualify codes in external coding systems.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifierManager"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.Utility.DescriptionToName(System.String)">
	<summary>
 Converts a specified textual description into a name.
 </summary>
	<param name="Description">A descriptive string possibly containing one or more spaces.</param>
	<returns>Returns the descriptive string in name form, that is, with spaces removed and the first letter of each
 word capitalized.</returns>
</member><member name="M:Quippe.Coding.Utility.StripSemanticTag(System.String)">
	<summary>
 Removes the semantic tag from the end of a SNOMED CT description.
 </summary>
	<param name="SnomedDescription">The SNOMED CT terminology description.</param>
	<returns>Returns the specified SNOMED CT description with the closing semantic tag stripped off. If the description
 has no semantic tag, the description is returned unchanged.</returns>
	<remarks><para>Example of a SNOMED CT description with a semantic tag: "Pulse irregular (finding)". Example with
 semantic tag removed: "Pulse irregular".</para></remarks>
</member><member name="T:Quippe.Coding.Utility">
	<summary>
 Class containing shared methods of general utility.
 </summary>
</member><member name="P:Quippe.Coding.ParameterCollection.Item(System.String)">
	<summary>
 Gets the parameter value, as an Object, that is associated with the specified parameter name.
 </summary>
	<param name="Name">The parameter name.</param>
	<returns>Returns the parameter value as an Object.</returns>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="P:Quippe.Coding.ParameterCollection.Count">
	<summary>
 Gets the number of parameters contained in the collection.
 </summary>
	<returns>Returns the number of parameters contained in the collection.</returns>
</member><member name="P:Quippe.Coding.ParameterCollection.Names">
	<summary>
 Gets a String collection containing the parameter names that have an associated Object value in this collection of parameters.
 </summary>
	<returns>Returns a String collection containing the names of parameters in this parameter collection.</returns>
</member><member name="M:Quippe.Coding.ParameterCollection.GetValue(System.String)">
	<summary>
 Gets the Object value, i.e., the parameter value, associated with the specified parameter name.
 </summary>
	<param name="Name">The parameter name.</param>
	<returns>Returns the parameter value as a String.</returns>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="M:Quippe.Coding.ParameterCollection.GetValue``1(System.String,``0)">
	<summary>
 Gets the Object value, i.e., the parameter value, associated with the specified parameter name.
 </summary>
	<typeparam name="T">The Type of the parameter value.</typeparam>
	<param name="Name">The name of the parameter.</param>
	<param name="DefaultValue">The value to return if the named parameter is not contained in the collection.</param>
	<returns>Returns the parameter value of type T associated with the specified parameter name, if the named parameter is contained in
 collection, or the DefaultValue otherwise.</returns>
	<exception cref="T:System.NotSupportedException">Thrown if the conversion of the parameter data to the specified type T cannot be performed.</exception>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="M:Quippe.Coding.ParameterCollection.Add(System.String,System.Object)">
	<summary>
 Adds or replaces the parameter value associated with the specified parameter name.
 </summary>
	<param name="Name">The name of the parameter to add or replace.</param>
	<param name="Value">The value of the parameter to add or replace as an Object.</param>
	<remarks>This method adds the named parameter and value to the collection if the collection does not already
 contain a parameter of that name. If the named parameter is already in the collection, this method replaces
 the value with that specified. The operation is case-insensitive with respect to the parameter name.
 </remarks>
</member><member name="M:Quippe.Coding.ParameterCollection.Remove(System.String)">
	<summary>
 Removes the specified parameter from the collection.
 </summary>
	<param name="Name">The name of the parameter to remove.</param>
	<remarks>If the named parameter is contained in the collection, this method removes the parameter and its
 value, otherwise this method has no effect. The operation is case-insensitive with respect to the parameter
 name.</remarks>
</member><member name="M:Quippe.Coding.ParameterCollection.Contains(System.String)">
	<summary>
 Determines whether the collection contains the a parameter with the specified name.
 </summary>
	<param name="Name">The name of the parameter.</param>
	<returns>Returns True if the named parameter is contained in the collection and False otherwise.</returns>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="M:Quippe.Coding.ParameterCollection.Clear">
	<summary>
 Removes all parameter names and values from the collection.
 </summary>
	<remarks>The count property is set to 0 and references to other objects from elements of the collection are
 also released.</remarks>
</member><member name="M:Quippe.Coding.ParameterCollection.Filter(System.Collections.Generic.ICollection{System.String})">
	<summary>
 Filters the collection of parameters to those specified in the input collection of parameter names.
 </summary>
	<param name="ParameterNames">The collection of names of the parameters that are desired as an ICollection(Of String).</param>
	<returns>Returns a new parameters collection containing only those parameters having a name that is specified in the
 ParameterNames collection. If no parameters in the specified names collection are found, then Nothing is
 returned.</returns>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="M:Quippe.Coding.DomainManager.DoGetDomain(System.String,System.String,System.String,Quippe.IKBService)">
	<summary>
 Gets the domain associated with the MEDCIN entry.
 </summary>
	<returns>Returns the the domain if the term type of the MEDCIN entry can be determined, otherwise returns
 the unknown domain.</returns>
	<remarks>Currently does not distinguish a Lab or Diagnostic test as a Result or not.</remarks>
</member><member name="M:Quippe.Coding.DomainManager.NodekeyToTermType(System.String)">
	<summary>
 Determines the MEDCIN term type from the specified nodekey.
 </summary>
	<param name="Nodekey">The MEDCIN nodekey for which to determine the term type.</param>
	<returns>Returns the MEDCIN term type for the specified nodekey if the nodekey is valid, otherwise returns Nothing.</returns>
	<remarks></remarks>
</member><member name="F:Quippe.Coding.StandardTranslator.PARAMETER_NAME_CODE_RELATIONSHIP_FILTER">
	<summary>Name of the parameter specifying an optional filter on the code relationship of the mappings in the potential translation results.</summary>
</member><member name="F:Quippe.Coding.StandardTranslator.PARAMETER_NAME_MAP_QUALIFIER_FILTER">
	<summary>Name of the parameter specifying an optional filter on the map qualifier of the mappings in the potential translation results.</summary>
</member><member name="F:Quippe.Coding.StandardTranslator.PARAMETER_NAME_PREFIX_CODE_FILTER">
	<summary>Name of the parameter specifying an optional filter on the MEDCIN prefix code of potential translation results.</summary>
</member><member name="F:Quippe.Coding.StandardTranslator.PARAMETER_NAME_TERM_TYPE_FILTER">
	<summary>Name of the parameter specifying an optional filter on the term type of the external vocabularies in the potential translation results.</summary>
</member><member name="F:Quippe.Coding.StandardTranslator.PARAMETER_NAME_STATUS_QUALIFIER_FILTER">
	<summary>Name of the parameter specifying an optional filter on the MEDCIN status qualifier code of potential translation results.</summary>
</member><member name="F:Quippe.Coding.StandardTranslator.PARAMETER_NAME_MODIFIER_FILTER">
	<summary>Name of the parameter specifying an optional filter on the MEDCIN modifier code of potential translation results.</summary>
</member><member name="F:Quippe.Coding.StandardTranslator.PARAMETER_NAME_RESULT_FILTER">
	<summary>Name of the parameter specifying an optional filter on the MEDCIN result qualifier code of potential translation results.</summary>
</member><member name="F:Quippe.Coding.StandardTranslator.PARAMETER_NAME_VOCAB_EXTENSIONS">
	<summary>Name of the parameter specifying an optional vocabulary extension code used to include additional codes, such as those from the SNOMED US extension.</summary>
</member><member name="P:Quippe.Coding.StandardTranslator.CompositeMapEntryComparer.AllowDuplicateMaps">
	<summary>
 Indicates whether the comparer allows duplicate maps based on differences in the intermediate Medcin ID.
 </summary>
</member><member name="T:Quippe.Coding.StandardTranslator.CompositeMapEntryComparer">
	<summary>
 Implements a comparer similar to MapEntry.CompareTo, but which is only used compare map entries that are maps between external
 vocabularies.   
 </summary>
	<remarks><para>Each map entry is expected to have an external vocab as both source and target, so there are no specific Medcin-related
 source or target comparisons as in MapEntry.CompareTo. This class is meant solely to provide a means to eliminate duplicate maps
 when translating from a source external vocab to a target external vocabulary. The map entries for such translations are created
 from two translations with Medcin as the intermediate vocabulary. The duplicate map entries for the composite map might arise if
 the intermediate Medcin concept is different (while the source and target entries are the same).</para></remarks>
</member><member name="T:Quippe.Coding.StandardTranslator.VersionInfo">
	<summary>
 Version information for external code (when target) or code set (when source) for determining which maps to select.
 </summary>
</member><member name="P:Quippe.Coding.StandardTranslator.DataFile">
	<summary>
 Gets or sets the path to the SQLite database file containing the Coding Service Database.
 </summary>
	<remarks>
		<para>This property may be specified in the "DataServices.xml" file as a setting for this provider or it
 defaults to the the file "CodingService.dat" in the folder given by "DataFolder" in the appSettings
 (e.g., in your applications app.config file).</para>
	</remarks>
</member><member name="P:Quippe.Coding.StandardTranslator.ParameterNames">
	<summary>
 Gets a collection of the names of the parameters supported by this coding translation service provider.
 </summary>
	<returns>Returns a collection of zero or more strings containing the names of parameters supported by this provider.</returns>
	<remarks>
		<para>This property returns a collection of the names of the parameters that are supported by the provider's
 Translate methods. The collection is returned as a reference to a <see cref="T:Quippe.Coding.TranslationParameterNames"/> object.
 Use the <see cref="P:Quippe.Coding.TranslationParameterNames.Values"/> property of this object to obtain a collection
 of parameter names to iterate. These parameters include those that may be required to determine mappings based on
 age, sex and test/measurement value.</para>
		<para>A translation service provider's implementation of the <see cref="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> method takes an optional parameter, called Parameters, of
 type <see cref="T:Quippe.Coding.TranslationParameters"/>. TranslationParameters is merely a collection of parameters, each represented by a case-insensitive String key
 (i.e., parameter name) and the associated parameter value of type Object. The implementing translation provider may or may not accept 
 parameters that control the translation. If a provider does accept parameters, the provider should return the accepted parameter names
 via this function. Further, a provider that accepts parameters will retrieve parameters from the collection by the parameter name, 
 and should ignore any parameters with names that do not match the translator’s list of supported parameter names.</para>
		<para>Refer to the <see cref="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> method or <see cref="T:Quippe.Coding.StandardParameters"/> for more information on the parameters that are supported
 by this provider.</para>
	</remarks>
</member><member name="P:Quippe.Coding.StandardTranslator.SupportedVocabularies">
	<summary>
 Gets a collection of vocabulary codes of the vocabularies supported by this translator.
 </summary>
	<remarks>
		<para>The returned collection includes the vocabulary codes of all supported vocabularies, including MEDCIN and all external
 vocabularies that are the target of the underlying forward mappings from MEDCIN. The vocabulary code is the unique
 identifier stored in the <see cref="P:Quippe.Coding.Vocabulary.Code"/> property of the associated <see cref="T:Quippe.Coding.Vocabulary"/> instance.</para>
		<para>The vocabulary code of the source or target vocabulary in a translation is specified in the <see cref="P:Quippe.Coding.CodeSet.VocabCode"/>
 property of a <see cref="T:Quippe.Coding.CodeSet"/> object passed to the <see cref="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> method. The CodeSet is derived from the
 associated vocabulary, and can be obtained from <see cref="M:Quippe.Coding.Vocabulary.GetCodeSet"/>. The <see cref="M:Quippe.Coding.StandardTranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/>
 method can be called to determine the type of support that is available from this provider for a given source and target CodeSet.</para>
	</remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.GetVocabulary(System.String)">
	<summary>
 Gets a copy of the vocabulary supported by this translation provider that has the specified vocabulary code.
 </summary>
	<param name="VocabCode">The unique code of the desired vocabulary.</param>
	<returns>Returns a copy of the supported vocabulary that has the specified vocabulary code or Nothing if the 
 vocabulary is not supported.</returns>
	<remarks>
		<para>This method returns a copy of the <see cref="T:Quippe.Coding.Vocabulary"/> instance the provider has in its collection of
 supported vocabularies, but does not indicate the type of translation support that is available for the vocabulary.
 Translation support is determine from a source and target code set by calling the <see cref="M:Quippe.Coding.StandardTranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/>
 method.</para>
		<para>A vocabulary is supported by the provider if the translator can perform some translation operation with the
 vocabulary as source or target. This provider's underlying mapping data are Medicomp mappings from MEDCIN to
 supported external (non-MEDCIN) vocabularies. A vocabulary is supported if it is the MEDCIN vocabulary or it is one
 of the target external vocabularies to which MEDCIN is mapped in the SQLite provider data. A collection of
 the supported vocabularies can be obtained from the property, <see cref="P:Quippe.Coding.StandardTranslator.SupportedVocabularies"/>.</para>
		<para>The vocabulary code is the unique identifier stored in the <see cref="P:Quippe.Coding.Vocabulary.Code"/> property of the 
 associated <see cref="T:Quippe.Coding.Vocabulary"/> instance. The vocabulary code of the source or target vocabulary in a translation 
 is specified in the <see cref="P:Quippe.Coding.CodeSet.VocabCode"/>
 property of a <see cref="T:Quippe.Coding.CodeSet"/> object passed to the <see cref="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> method. The CodeSet is derived from the
 associated vocabulary, and can be obtained from <see cref="M:Quippe.Coding.Vocabulary.GetCodeSet"/>.
 </para>
	</remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)">
	<summary>
 Determines the type of translation support provided by this translator for the given source and target code sets.
 </summary>
	<param name="SourceCodeSet">The CodeSet corresponding to the coding vocabulary containing the code(s) that will be specified for translation.</param>
	<param name="TargetCodeSet">The CodeSet corresponding to the coding vocabulary that is the target of the translation.</param>
	<returns>Returns an enumerated value from SupportedTranslationTypeEnum that indicates the type of translation
 that is supported for the specified code sets.</returns>
	<exception cref="T:Quippe.Coding.TranslatorArgumentException">Thrown for the following reasons:
 <list type="bullet">
			<item><description>The source or target code set parameter is Nothing.</description></item>
			<item><description>The source or target code set has an empty vocabulary code.</description></item>
		</list>
	</exception>
	<remarks>
		<para>At present, only the vocabulary codes in the specified code sets are used to determine the type of
 translation support provided. This translator provides forward translations from MEDCIN to all supported 
 external vocabularies. Reverse translations are supported when the translation target vocabulary is MEDCIN
 and the source is an external vocabulary. Translation between two external vocabularies is an indirect 
 translation. See <see cref="T:Quippe.Coding.SupportedTranslationTypeEnum">SupportedTranslationTypeEnum</see> for more details 
 regarding supported translation types.</para>
		<para>A vocabulary is supported by the provider if the translator can perform some translation operation with the
 vocabulary as source or target. A collection of
 the supported vocabularies as <see cref="T:Quippe.Coding.Vocabulary"/> objects can be obtained from the property, <see cref="P:Quippe.Coding.StandardTranslator.SupportedVocabularies"/>.</para>
	</remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates a source CodeEntry, representing a clinical concept in a specific vocabulary, to mapped codes in the
 specified target vocabulary, with optional parameters to perform the translation.
 </summary>
	<param name="SourceEntry">The source CodeEntry-derived instance representing the clinical concept in the source vocabulary to be translated.
 A CodeEntry may be passed, but a <see cref="T:Quippe.Coding.MedcinCodeEntry"/> or <see cref="T:Quippe.Coding.ExternalCodeEntry"/> contains more specific data that may be 
 useful to the translator.</param>
	<param name="TargetCodeSet">The target CodeSet (i.e., vocabulary and optional version) to which the source entry will be translated.</param>
	<param name="Parameters">Optional list of parameters used to perform the translation. The supported parameters are described in the Remarks below.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<exception cref="T:Quippe.Coding.TranslatorException">Thrown if there is a problem inherent to the definition or initialization of the translator, including the following:
 <list type="bullet">
			<item><description>the Coding Service Database could not be found at path specified in the DataFile property or setting</description></item>
			<item><description>there was an error loading or accessing the Coding Service Database</description></item>
			<item><description>the was an error loading or initializing coding system vocabularies supported by the translator</description></item>
		</list>
	</exception>
	<exception cref="T:Quippe.Coding.TranslationException">Thrown if a problem occurs during the code translation, including the following:
 <list type="bullet">
			<item><description>the translator does not support translation from codes in the specified source code set</description></item>
			<item><description>the translator does not support translation to the specified target code set</description></item>
			<item><description>an error occurred while determining a parameterized target code from the base code and parameter values</description></item>
			<item><description>an error occurred while retrieving code hints associated with an external code</description></item>
			<item><description>an error occurred while retrieving code specifiers associated with an external code</description></item>
			<item><description>an error occurred while auto-generating maps from qualified source codes</description></item>
		</list>
	</exception>
	<exception cref="T:Quippe.Coding.TranslatorArgumentException">A TranslatorArgumentException is thrown for the following reasons:
 <list type="bullet">
			<item><description>the SourceEntry or the TargetCodeSet parameter is Nothing</description></item>
			<item><description>the vocabulary code in the source or target CodeSet is Nothing or empty</description></item>
			<item><description>the clinical concept code in the source CodeEntry is Nothing or empty</description></item>
			<item><description>the vocabulary version is not a valid version for the specified source vocabulary</description></item>
			<item><description>the vocabulary version is not a valid version for the specified target vocabulary</description></item>
			<item><description>the clinical concept code in the MEDCIN source entry is not a valid MEDCIN ID</description></item>
			<item><description>the prefix code in the MEDCIN source entry is not a valid MEDCIN prefix</description></item>
			<item><description>the term type specified in the source entry is not a valid term type for the external source vocabulary</description></item>
			<item><description>a named parameter value passed to the translator was not of the type expected</description></item>
		</list>
	</exception>
	<remarks>
		<para>The minimum information required to perform a translation is the source vocabulary code, the source code to translate, and the target vocabulary
 code in the target CodeSet object. Additional information to control the translation may be provided by properties of the source CodeEntry or the target
 CodeSet or through the optional parameters.</para>
		<para>The SourceEntry parameter must provide a valid <see cref="T:Quippe.Coding.CodeEntry"/> to translate, which means it must contain at a minimum 
 a CodeSet in its <see cref="P:Quippe.Coding.CodeEntry.CodeSet"/> property, which itself has a valid <see cref="P:Quippe.Coding.CodeSet.VocabCode"/> property containing the
 code of a source vocabulary supported by the translator as well as a valid code to translate in the <see cref="P:Quippe.Coding.CodeEntry.Code"/> property. Preferrably,
 an instance of a derived class of CodeEntry will be passed in the SourceEntry parameter. If the source entry is a MEDCIN code, it
 is best to pass an instance of <see cref="T:Quippe.Coding.MedcinCodeEntry"/>, in which case the <see cref="P:Quippe.Coding.MedcinCodeEntry.MedcinId"/> should contain
 the MEDCIN ID to translate. Using a MedcinCodeEntry instance provides more flexibility. For instance, it provides the means to submit
 prefixed MEDCIN codes for translation, via the <see cref="P:Quippe.Coding.MedcinCodeEntry.PrefixCode"/>. If the source entry is a code from an 
 external (non-MEDCIN) vocabulary, it is best to pass an instance of the <see cref="T:Quippe.Coding.ExternalCodeEntry"/> class.</para>
		<para>The TargetCodeSet parameter must provide a valid <see cref="T:Quippe.Coding.CodeSet"/> instance representing the target vocabulary to which
 to translate the source code, which means the target code set must at a minimum have a valid <see cref="P:Quippe.Coding.CodeSet.VocabCode"/> property containg
 the code of a supported target vocabulary.</para>
		<para>The <see cref="T:Quippe.Coding.MedcinCodeEntry"/> class has properties Age, Sex, Value and Result that may be used to determine codes in an external vocabulary via parameterized tables. 
 If Age, Sex and Value parameters are specified and valid (i.e., Age &gt; 0, Sex not empty, and Value a numeric value) and the target code mapped to the 
 input Medcin ID is parameterized, the translator will attempt to get the resulting parameterized code from the base code that is mapped to MEDCIN. 
 A typical example is translating from the generic Medcin concept for body mass index to specific billable ICD-9-CM or ICD-10-CM codes that require knowledge of the
 patient's age and sex and the BMI measurement value. If only the Result property is specified and the Value property is zero (0), the translator will attempt 
 to resolve the translation to an external code via parameterized tables (i.e., result codes in maps to ICD-9-CM) rather than through the normal map retrieval 
 process (e.g., result codes to ICD-10-CM), provided the target code mapped to the input Medcin ID is parameterized.</para>
		<para>In addition to Age, Sex, Value and Result, the MedcinCodeEntry class also has other properties such as PrefixCode, StatusQualifier, Modifier and Specifier
 that should be specified from patient and encounter data. A coding service translation request (e.g., a call to an implementation of one of the Translate methods
 in the code mapping service) that takes a MEDCIN entry record (<see cref="T:Quippe.IEntry"/>) as an input parameter should pass the Result, Value, PrefixCode, 
 StatusQualifier, Modifier and Specifier property values through to the equivalent properties in the <see cref="T:Quippe.Coding.MedcinCodeEntry"/> instance. A coding service 
 translation request that takes a patient record (<see cref="T:Quippe.IPatient"/>) as an input parameter should pass the patient age and sex to the translator via the 
 <see cref="P:Quippe.Coding.MedcinCodeEntry.Age"/> and <see cref="P:Quippe.Coding.MedcinCodeEntry.Sex"/> properties. If an encounter record is present, age should be determined as the difference 
 between the encounter date and the patient’s birth date, in minutes.</para>
		<para>This translator supports the optional parameters listed in the table below. Parameters are specified as individual items in the
 <see cref="T:Quippe.Coding.TranslationParameters"/> object, which is an associative collection, pairing the parameter value as an Object with a String key 
 containing the name of the parameter. The <see cref="P:Quippe.Coding.StandardTranslator.ParameterNames"/> property of this translator returns the names of the supported
 parameters. Refer also to <see cref="T:Quippe.Coding.StandardParameters"/> for more information on the supported parameters.
 <list type="table">
				<listheader>
					<term>Parameter Name</term>
					<description>Description</description>
				</listheader>
				<item>
					<term>”CodeRelationShipFilter”</term>
					<description>An instance of <see cref="T:Quippe.Coding.TranslationFilter"/> class defining a filter that limits the resulting maps (e.g., <see cref="T:Quippe.Coding.MapEntry"/> objects)
 from the translation to those that have a code relationship (<see cref="P:Quippe.Coding.MapEntry.Relationship"/> property) with a name (<see cref="P:Quippe.Coding.CodeRelationship.Name"/> 
 property) that matches the regular expression in the filter. This parameter is an advanced feature that is optional, but may be useful in limited 
 situations where additional filtering by code relationship is desired.</description>
				</item>
				<item>
					<term>”Date”</term>
					<description>The date of the encounter, as a <see cref="T:System.DateTime"/> type. If the target vocabulary is versioned by code year, the translator will consider
 only target codes in mappings that are valid for the code year on the encounter date. A coding service translation request that takes an encounter record
 (<see cref="T:Quippe.IEncounter"/>) as an input parameter should pass the encounter date to the translator in this parameter.</description>
				</item>
				<item>
					<term>”MapQualifierFilter”</term>
					<description>An instance of <see cref="T:Quippe.Coding.TranslationFilter"/> class defining a filter that limits the resulting maps (e.g., <see cref="T:Quippe.Coding.MapEntry"/> objects)
 from the translation to those that have a map qualifier (<see cref="P:Quippe.Coding.MapEntry.Qualifier"/> property) name (<see cref="P:Quippe.Coding.CodingQualifier.Name"/> property) 
 that matches the regular expression in the filter. This parameter is an advanced feature that is optional but may be useful in limited situations where 
 additional filtering by the map qualifier is desired.</description>
				</item>
				<item>
					<term>”Options”</term>
					<description>An instance of <see cref="T:Quippe.Coding.TranslationOptions"/> indicating special options that should be handled by the translator. This translator checks
 the <see cref="P:Quippe.Coding.TranslationOptions.HintOption"/> and <see cref="P:Quippe.Coding.TranslationOptions.SpecifierOption"/> properties to determine whether (and how) code 
 hints and code specifiers are retrieved with the target codes during the translation. For more information regarding code hints, refer to <see cref="T:Quippe.Coding.CodeHints"/>
 and <see cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>. For more information regarding code specifiers, refer to <see cref="T:Quippe.Coding.CodeSpecifierLists"/> and 
 <see cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>.The SQLite translator also checks the <see cref="P:Quippe.Coding.TranslationOptions.AutoGenerationOption"/> to determine 
 whether maps from qualified MEDCIN concepts are automatically generated to SNOMED. In addition, the <see cref="P:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOption"/>
 determines how Medcin qualifiers on the input Medcin finding instance are matched against qualifiers in the potential maps, and ultimately
 determines which maps are returned (e.g., whether all matches, alternate matches or exact matches only are returned).</description>
				</item>
				<item>
					<term>”PrefixCodeFilter”</term>
					<description>An instance of <see cref="T:Quippe.Coding.TranslationFilter"/> class defining a filter that limits the resulting maps (e.g., <see cref="T:Quippe.Coding.MapEntry"/> objects)
 from the translation to those that have a MEDCIN source or target code entry with a prefix code (<see cref="P:Quippe.Coding.MedcinCodeEntry.PrefixCode"/> property) that
 matches the regular expression in the filter. This parameter is an advanced feature that is optional but may be useful in limited situations where additional
 filtering by the prefix code is desired. However, filtering by MEDCIN prefix code is automatically handled without this parameter when a MEDCIN source entry
 is provided with a prefix code via the <see cref="P:Quippe.Coding.MedcinCodeEntry.PrefixCode"/> property. A coding service translation request that takes a MEDCIN entry record
 (<see cref="T:Quippe.IEntry"/>) as an input parameter should automatically set the <see cref="P:Quippe.Coding.MedcinCodeEntry.PrefixCode"/> property of the source 
 <see cref="T:Quippe.Coding.MedcinCodeEntry"/> passed to the translator, and so a filter is not needed in this case. Likewise, a source <see cref="T:Quippe.Coding.MedcinCodeEntry"/> with an
 empty prefix code will automatically filter to only maps from the un-prefixed MEDCIN concept. This filter might be useful when MEDCIN is the target vocabulary
 or when it is desirable to not specify the prefix code in the MEDCIN entry and return all maps from the MEDCIN concept, prefixed or not.</description>
				</item>
				<item>
					<term>”TermTypeFilter”</term>
					<description>An instance of <see cref="T:Quippe.Coding.TranslationFilter"/> class defining a filter that limits the resulting maps (e.g., <see cref="T:Quippe.Coding.MapEntry"/> objects)
 from the translation to those that have have an external (non-MEDCIN) target entry (<see cref="P:Quippe.Coding.MapEntry.TargetEntry"/> property) with a term type name 
 (<see cref="P:Quippe.Coding.TermType.Name"/> property) that matches the regular expression in the filter. This parameter is an advanced feature that is optional but may
 be useful in limited situations where additional filtering by the term type of an external target code is desired. The filter does not apply to map source
 entries that are external codes, but only to target codes of the map.</description>
				</item>
			</list>
		</para>
	</remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.AddCodeYearToWhereClause(Quippe.Coding.Vocabulary,System.Int32,System.Text.StringBuilder)">
	<summary>
 Modifies the Sql by adding a clause that will filter the potential map records to those that map to an external
 code equal to or prior to the specified code year.
 </summary>
	<param name="Vocab">The external vocabulary containing the specified code year.</param>
	<param name="CodeYear">The code year that will be compared in the part of the where clause added to the sql or -1
 if there is no code year and hence no clause to add.
 </param>
	<param name="Sql">On input Sql contains the SQL upto and including the where clause, which must already contain one
 sub-clause. On output, Sql will have the code year comparison sub-clause appended, if success, or no changes otherwise.</param>
	<returns>Returns True if the code year comparison sub-clause was added to the sql and False otherwise.</returns>
	<remarks>If CodeYear is -1, then there is no code year and no changes will be made to the Sql and the function
 returns False. If CodeYear is not -1, then a sub-clause comparing the parameterized TargetVersion to the specified
 code year will be appended to the SQL.</remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.AddPrefixCodeToWhereClause(Quippe.Coding.Vocabulary,Quippe.Coding.MedcinCodeEntry,System.Text.StringBuilder@,System.Boolean,Quippe.Coding.StandardParameters,System.Boolean@)">
	<summary>
 Validates the prefix code, and if valid, adds the parent prefix code (or the prefix code itself if it has no parent) to the specified where clause.
 </summary>
	<param name="MedcinVocab">The Medcin vocabulary object.</param>
	<param name="MedcinEntry">The Medcin entry containing the MedcinId and the prefix code to validate and to serve as the basis for the parent code to add to the where clause.</param>
	<param name="SqlWhere">The where clause of the SQL statement being built.</param>
	<param name="PrefixFilterWasAdded">Indicates that a prefix filter has already been added to the specified where clause before this
 method was called. If this parameter is True and the prefix code is empty, a clause will not be added to restrict maps to those with
 null prefix code.</param>
	<param name="Parameters">Translation parameters.</param>
	<param name="PrefixIgnored">Return parameter indicating whether prefix can be ignored, when prefix is specified and its
 an ignorable prefix for mapping purposes (e.g. "ordered") and it doesn't change the meaning of the concept (e.g., "rule out"
 changes the meaning and is not ignorable).</param>
	<returns>Returns True if the prefix code was empty, was good for mapping, or was one that could be ignored. Returns False if the
 prefix code was not empty, was not good for mapping and could not be ignored, meaning that no maps exist with this prefix.</returns>
	<remarks>If the method returns False, most likely the caller will not want to run the query as it would return
 no results with an invalid prefix code.</remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.TableToMapList(System.Data.DataTable,Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,System.Int32,System.Boolean,System.Boolean)">
	<summary>
 Takes mapping translation results in the specified DataTable and formats them as a list of MapEntry objects taking into account
 whether the results need to be filtered when the query involves a non-current vocabulary version that is a code year.
 </summary>
	<param name="Table">The DataTable containing the results of the mapping translation query.</param>
	<param name="SourceEntryInput">The CodeEntry for the source of the translation.</param>
	<param name="TargetCodeSet">The CodeSet for the target of the translation.</param>
	<param name="TargetVocabId">The target vocabulary ID used to check whether the target is MEDCIN. Passing it avoids having to compute
 it again from the TargetCodeSet.</param>
	<param name="FilteredByCodeYear">Boolean indicating whether the results were generated by a query that filtered by non-current code year
 vocabulary version (i.e., via an encounter date parameter). Non-current code year versions require additional processing to return only 
 the most recent unique record.</param>
	<returns>The relevant resulting map records as a list of MapEntry objects, possibly filtered for non-current version queries.</returns>
	<remarks>Results are filtered by non-current code year if the external vocabulary uses code years in versioning and if the encounter
 date was specified in the translation parameters. In that case, only the most recent unique records are returned, where uniqueness
 for this purpose is determined by whether any of the following properties of the map entry are different: Medcin ID, prefix, 
 term type of external vocabulary, and map qualifier. </remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.ProcessCodeSpecifiers(Quippe.Coding.MedcinCodeEntry,Quippe.Coding.ExternalCodeEntry,Quippe.Coding.MapEntry,Quippe.Coding.Vocabulary,Quippe.Coding.TranslationOptions.SpecifierOptionEnum,Quippe.Coding.StandardTranslator.VersionInfo,System.Boolean)">
	<summary>
 Gets code specifiers associated with the Medcin source entry and external target vocab entry using the specified options and version information.
 </summary>
	<param name="MedcinEntry">The Medcin code entry that is the source of the mapping.</param>
	<param name="TargetEntry">The external vocab code entry that is the target of the mapping.</param>
	<param name="ExternalVocab">The vocabulary associated with the code set of the external code entry.</param>
	<param name="SpecifierOption">The specifier option, which indicates whether to get the specifiers list or do nothing.</param>
	<param name="ExternalVersionInfo">Contains version information regarding the translation request, including (a) whether the
 version and/or encounter code year are equivalent to the most recent vocab version, (b) a specific external vocabulary version,
 if any, that was specified in the translation request, or (c) a specific code year that has been determined from the encounter
 date if specified in the original translation request (or -1 if no specific version was given).</param>
	<param name="HasSpecifierToResolve">If True, the external vocabulary uses specifiers (e.g., ICD10 specifier tables) AND then
 input MEDCIN entry to the translation has a specifier string to resolve against the specifier tables for the given target vocabulary.</param>
	<remarks>The version information is used to obtain the code specifier lists that are appropriate for the given version or code year. Version
 and code year information is based on the information from the original translation request, rather than on the results of the translation.
 A specific version or code year is used if the CurrentVersion flag is False, otherwise the method simply obtains the code specifiers
 for the most recent version.</remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.FilterCodeSpecifierLists(Quippe.Coding.MedcinCodeEntry,Quippe.Coding.ExternalCodeEntry)">
	<summary>
 The items of certain specifier lists related to fractures are filtered based on the MEDCIN concept.
 </summary>
	<param name="MedcinEntry">The Medcin code entry that is the source of the mapping.</param>
	<param name="TargetEntry">The external vocab code entry that is the target of the mapping.</param>
	<remarks>
		<para>This is a special case to filter certain specifier lists that cannot be easily altered in the database at
 this time. The specifier lists of the target entry are examined to see if any lists are elligible for pruning of
 items, and list items are filtered if necessary.</para>
		<para>Certain encounter instance lists contain a mixture of items related to both "open" and "closed" fractures. ICD-10
 concepts are not detailed enough to include open and closed fractures, except in the encounter instance 7th digit
 tables. However, MEDCIN concepts may be specifically related to "open" and "closed" fractures and in these cases
 the MEDCIN terminology descriptions will include the word "open" or "closed". If the lists are elligible for pruning 
 and the MEDCIN concept description indicates the fracture is either an "open" or "closed" fracture, then the specifier
 list items are pruned to contain only those relevant for the fracture type. That is, we don't want "closed" fracture
 items appearing in the specifier list for a MEDCIN concept that refers to an "open" fracture, and vice versa.</para>
		<para>This issue is not addressed in the database because in the case of open and close fractures, the MEDCIN concepts
 have been mapped to the appropriate, but less detailed, ICD-10 categories. These ICD-10 categories are less detailed because
 they do not distinguish "closed" and "open" fractures in the 6 digit categories; these fracture types are only indicated
 in the 7th digit tables. That is, the 7th digit tables in ICD-10 are overloaded to include both encounter instance data
 (i.e., initial, subsequent and sequela) and fracture type data (e.g., open/closed type). The MEDCIN mappings from 
 "open" and "closed" fracture concepts, or even non-specific concepts, may map to the same ICD-10 category code. Under 
 the current specifier table architecture, which mimics the ICD-10 tabular list structure, each ICD-10 category code may 
 only have a single associated 7th digit table. The fracture encounter instance tables 7A and 7B, have a mixture of "closed" 
 and "open" fracture items. Thus, the code must determine at run time which items are appropriate depending on the MEDCIN 
 concept description, and filter the tables items appropriately.</para>
		<para>Note, this issue only occurs for "open" and "closed" fractures. It is not a problem for open fracture healing types,
 "delayed healing", "routine healing", "malunion" and "nonunion" because MEDCIN concepts do not detail the healing type.
 Also, all MEDCIN concepts for open and closed fractures will have "open" or "closed" as appropriate in the terminology
 description (i.e., the FSN), so it is realiable to parse the description to determine fracture type (there is no flag
 or other means within MEDCIN at this time to indicate fracture type).</para>
	</remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.GetSpecifierType(System.Int32)">
	<summary>
 Gets the code specifier type having the specified TypeId. 
 </summary>
	<param name="TypeId">The unique Integer identifier of the desired code specifier type.</param>
	<returns>Returns an ICodeSpecifierType reference to the type corresponding to the associated TypeId
 parameter, if found, otherwise returns Nothing.
 </returns>
	<remarks></remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
</member><member name="M:Quippe.Coding.StandardTranslator.GetSpecifierItem(System.Int32)">
	<summary>
 Gets the code specifier item having the specified ItemId. 
 </summary>
	<param name="ItemId">The unique Integer identifier of the desired code specifier item.</param>
	<returns>Returns an ICodeSpecifierItem reference to the item corresponding to the associated ItemId
 parameter, if found, otherwise returns Nothing.</returns>
	<remarks></remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
</member><member name="M:Quippe.Coding.StandardTranslator.GetSpecifierList(System.Int32)">
	<summary>
 Gets the specified code specifier list, including its constituent code specifier items. 
 </summary>
	<param name="ListId">The unique Integer identifier of the desired code specifier list.</param>
	<returns>Returns an ICodeSpecifierList reference to the list corresponding to the associated ListId
 parameter, if found, otherwise returns Nothing.
 </returns>
	<remarks></remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
</member><member name="M:Quippe.Coding.StandardTranslator.GetCodeEntry(System.String,System.String)">
	<summary>
 Gets the code entry data for a specific code in a coding system vocabulary.
 </summary>
	<param name="VocabCode">The unique string identifier of the vocabulary.</param>
	<param name="Code">The unique string identifier of the code.</param>
	<returns>Returns an instance of a class implementing <see cref="T:Quippe.Coding.ICodeEntry"/> associated with the specific
 code, or Nothing if the code does not exist in the coding service database. If the input code 
 is in the MEDCIN vocabulary ("medcin" vocabulary code) the return value will be an instance 
 of <see cref="T:Quippe.Coding.MedcinCodeEntry"/>, otherwise, its an instance of <see cref="T:Quippe.Coding.ExternalCodeEntry"/>.</returns>
	<remarks><para>Code entry data includes only the limited set of properties and data associated
 with codes in the coding service database. This does not include mapping entries, but does 
 include textual code hints and code specifier lists.</para></remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.GetExternalEntry(System.String,System.String)">
	<summary>
 Gets the code entry for a specific code in an external (non-MEDCIN) coding system 
 vocabulary.
 </summary>
	<param name="VocabCode">The unique string identifier of the external vocabulary.</param>
	<param name="Code">The unique string identifier of the code.</param>
	<returns>Returns an instance of <see cref="T:Quippe.Coding.ExternalCodeEntry"/> associated with the specific
 code, or Nothing if the vocabulary code is invalid or unsupported, or if code does not 
 exist in the coding service database.</returns>
	<remarks>
		<para>Code entry data includes only the limited set of properties and data associated
 with codes in the coding service database. This does not include mapping entries, but does 
 include textual code hints and code specifier lists.</para>
	</remarks>
</member><member name="M:Quippe.Coding.StandardTranslator.GetMedcinEntry(System.Int32)">
	<summary>
 Gets the code entry for a specific MEDCIN concept.
 </summary>
	<param name="MedcinId">The unique integer ID of the MEDCIN concept.</param>
	<returns>Returns an instance of <see cref="T:Quippe.Coding.MedcinCodeEntry"/> associated with the specific MEDCIN
 ID, or Nothing if the ID is invalid, or if MEDCIN concept does not exist in the coding
 service database.</returns>
	<remarks>
		<para>Code entry data includes only the limited set of properties and data associated
 with MEDCIN concepts in the coding service database. This does not include various flags and
 properties unrelated to coding, but does include the term type and nodekey.</para>
	</remarks>
</member><member name="T:Quippe.Coding.StandardTranslator">
	<summary>
 Coding translation service provider that exposes the Medicomp mappings between source MEDCIN concepts and supported external
 vocabularies that are available via Medicomp's SQLite Coding Service Database.  
 </summary>
	<remarks>
		<para>This code translation service provider implements the <see cref="T:Quippe.Coding.ITranslator"/> interface to expose Medicomp's code
 mappings from MEDCIN concepts to supported external vocabularies. Mappings are exposed via the <see cref="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> method,
 which translates a specified concept in a source vocabulary (e.g., MEDCIN) to the mapped codes in the specified target coding system vocabulary. The 
 results of a translation are the forward mappings from MEDCIN that correspond to the specified source concept
 concept (as a <see cref="T:Quippe.Coding.MedcinCodeEntry"/> instance if MEDCIN or a <see cref="T:Quippe.Coding.ExternalCodeEntry"/> instance if an external non-MEDCIN vocabulary),
 and specified target vocabulary (the CodeSet parameter) after applying whatever options or filters have been specified in the optional 
 TranslationParameters collection. A description of the supported parameters can be found in the documentation of
 the <see cref="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> method and the <see cref="T:Quippe.Coding.StandardParameters"/> class. The translation results are returned as a 
 <see cref="T:Quippe.Coding.MapManager"/> object, from which the individual resulting map records are accessed (e.g., as instances of <see cref="T:Quippe.Coding.MapEntry"/>).</para>
		<para></para>
		<para>A coding system vocabulary is represented by the class, <see cref="T:Quippe.Coding.Vocabulary"/>, and uniquely identified by the vocabulary
 code, <see cref="P:Quippe.Coding.Vocabulary.Code"/>. During translation, the source or target vocabulary is specified using a <see cref="T:Quippe.Coding.CodeSet"/> object
 (primarily a vocabulary code) corresponding to the vocabulary, which can be obtained via the <see cref="M:Quippe.Coding.Vocabulary.GetCodeSet"/>.</para>
		<para>The standard set of vocabularies is available from the collection contained in the <see cref="T:Quippe.Coding.Vocabularies"/> class. However, 
 a translator does not necessarily support all standard vocabularies. To determine which vocabularies are supported by this 
 translator, check the <see cref="P:Quippe.Coding.StandardTranslator.SupportedVocabularies"/> property. Use the <see cref="M:Quippe.Coding.StandardTranslator.GetVocabulary(System.String)"/> 
 method to determine if a vocabulary with the specified vocabulary code is supported. Use the <see cref="M:Quippe.Coding.StandardTranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/>
 method to determine whether the translator supports translation from the specified source and target vocabularies.</para>
		<para>This provider is preferred over the MEDCIN version 2 provider because it is more comprehensive. The SQLite
 database and provider support the concept of mapping relationships, i.e., the relationship that exists between the source
 MEDCIN concept and the mapped concept in the target external vocabulary. Code descriptions are more readily available
 from this provider. The SQLite database provides an improved organization of coding system vocabularies, by using the 
 concepts of term types, map qualifiers, grouped mappings and prefixed mappings. This provider supports more comprenhesive
 filtering of the mapping results of a translation and other translation options. Further, this provider can support 
 reverse translations, i.e., finding MEDCIN codes that are mapped to specified external vocabulary codes.</para>
	</remarks>
</member><member name="F:Quippe.Coding.TranslationFilters.FilterTypeEnum.MapQualifier">
	<summary>Indicates the MapQualifier filter is the target of the method or operation. The MapQualifier 
 filter matches map qualifier names (i.e., <see cref="P:Quippe.Coding.MapEntry.QualifierName"/>).</summary>
</member><member name="F:Quippe.Coding.TranslationFilters.FilterTypeEnum.TermType">
	<summary>Indicates the TermType filter is the target of the method or operation. The TermType filter
 matches term type names (i.e., <see cref="P:Quippe.Coding.CodeEntry.TermTypeName"/>). The TermType filter 
 does not apply to the Medcin vocabulary only to external
 vocabularies as the code maps do not contain MEDCIN term types.</summary>
</member><member name="F:Quippe.Coding.TranslationFilters.FilterTypeEnum.CodeRelationship">
	<summary>Indicates the CodeRelationship filter is the target of the method or operation. This filter
 matches either code relationship names or IDs (i.e., <see cref="P:Quippe.Coding.MapEntry.Relationship"/>) depending 
 on the value of the <see cref="P:Quippe.Coding.TranslationFilters.CodeRelationshipMatchOption"/> property.</summary>
</member><member name="F:Quippe.Coding.TranslationFilters.FilterTypeEnum.PrefixCode">
	<summary>Indicates the PrefixCode filter is the target of the method or operation. This filter matches
 prefix codes in the the MEDCIN vocabulary (i.e., <see cref="P:Quippe.Coding.MedcinCodeEntry.PrefixCode"/>), when 
 MEDCIN is either the target or source vocabulary.</summary>
</member><member name="F:Quippe.Coding.TranslationFilters.FilterTypeEnum.StatusQualifier">
	<summary>Indicates the StatusQualifier filter is the target of the method or operation. This filter matches unique
 codes (names) of status qualifiers that qualify the mapping (i.e., <see cref="P:Quippe.Coding.MedcinCodeEntry.StatusQualifierCode"/>).</summary>
</member><member name="F:Quippe.Coding.TranslationFilters.FilterTypeEnum.Modifier">
	<summary>Indicates the Modifier filter is the target of the method or operation. This filter matches unique
 codes (names) of modifiers that qualify the mapping (i.e., <see cref="P:Quippe.Coding.MedcinCodeEntry.ModifierCode"/>).</summary>
</member><member name="F:Quippe.Coding.TranslationFilters.FilterTypeEnum.Result">
	<summary>Indicates the Result qualifier filter is the target of the method or operation. This filter matches unique
 codes (names) of result qualifiers that qualify the mapping (i.e., <see cref="P:Quippe.Coding.MedcinCodeEntry.ResultCode"/>).</summary>
</member><member name="T:Quippe.Coding.TranslationFilters.FilterTypeEnum">
	<summary>
 Provides enumerated values for each type of string filter. These values may be used in methods to set filter 
 properties.
 </summary>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="F:Quippe.Coding.TranslationFilters.MatchOptionEnum.MatchIds">
	<summary>Indicates the code relationship filter should be matched against the string representation of the
 target code relationship IDs.</summary>
</member><member name="F:Quippe.Coding.TranslationFilters.MatchOptionEnum.MatchNames">
	<summary>Indicates the code relationship filter should be matched against names of the target code
 relationships.</summary>
</member><member name="T:Quippe.Coding.TranslationFilters.MatchOptionEnum">
	<summary>
 Provides enumerated values for each way in which code relationship filters are matched against target code
 relationships.
 </summary>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="M:Quippe.Coding.TranslationFilters.#ctor(System.Boolean,Quippe.Coding.TranslationFilters.MatchOptionEnum)">
	<summary>
 Creates a new TranslationFilters object with empty filters.
 </summary>
	<param name="MatchNull">Optional parameter indicating whether the filters match when the target value is null.
 If true, then maps that have null values for the filters will also be considered a match in addition to the
 matches found in maps that have non-null values.</param>
	<param name="CodeRelationshipMatchOption">Optional parameter indicating how code relationship objects are to be
 matched by the code relationship filter pattern. The default is to match against code relationship IDs.</param>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="P:Quippe.Coding.TranslationFilters.CodeRelationshipMatchOption">
	<summary>
 Gets or sets the way in which code relationships are matched using the code relationship filter pattern.
 </summary>
	<remarks>
		<para>The code relationship pattern can be matched against code relationship names or identifiers. This
 option determines how the pattern is applied to the target code relationships to determine a match. Be sure
 to set the code relationship pattern appropriately, according to the match option. Identifiers will be treated as 
 strings when the match is performed should the MatchIds option be specified.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="P:Quippe.Coding.TranslationFilters.MatchNull">
	<summary>
 Gets or sets an option that controls whether maps with null values in the target filter value will be
 considered matches.
 </summary>
	<remarks>
		<para>If MatchNull is True, then maps that have null values in the target filter value will be considered
 matches in addition to those with values that match the filter pattern. If False, only maps with non-null 
 values that match the filter pattern will be considered matches.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="M:Quippe.Coding.TranslationFilters.SetFilter(Quippe.Coding.TranslationFilters.FilterTypeEnum,Quippe.Coding.TranslationFilter)">
	<summary>
 Sets the specified filter to the specified TranslationFilter instance.
 </summary>
	<param name="FilterType">The type of the filter you wish to set, which must be one of the values from the Enum 
 <see cref="T:Quippe.Coding.TranslationFilters.FilterTypeEnum"/>.</param>
	<param name="Filter">The TranslationFilter instance you wish to set.</param>
	<remarks>
		<para>Use this method to set the filter for the specified filter type to an already existing
 TranslationFilter object instance.</para>
	</remarks>
</member><member name="M:Quippe.Coding.TranslationFilters.GetFilter(Quippe.Coding.TranslationFilters.FilterTypeEnum)">
	<summary>
 Gets the TranslationFilter instance of the specified type, if available.
 </summary>
	<param name="FilterType">The type of the filter to get.</param>
	<returns>Returns the TranslationFilter instance of the specified type, if it exists, and Nothing otherwise.</returns>
</member><member name="M:Quippe.Coding.TranslationFilters.SetPattern(Quippe.Coding.TranslationFilters.FilterTypeEnum,System.String,Quippe.Coding.TranslationFilter.FilterOptionEnum,System.Boolean)">
	<summary>
 Sets the regular expression for the specified filter to the specified filter String using the specified options.
 </summary>
	<param name="FilterType">The type of the filter you wish to set, which must be one of the values from the Enum 
 <see cref="T:Quippe.Coding.TranslationFilters.FilterTypeEnum"/>.</param>
	<param name="FilterString">The string that is the basis for the filter, either a complete regular expression or
 a search tring that will be formatted using a specified option.</param>
	<param name="FilterOption">An Enum value from <see cref="T:Quippe.Coding.TranslationFilter.FilterOptionEnum"/> that indicates how the string pattern should be
 formatted when the regular expression object is created.</param>
	<param name="IgnoreCase">Indicates whether case-insensitive matching is to be used for the specified filter.</param>
	<remarks><para>Use this method if you want to create the filter pattern from scratch.</para>
		<para>Example: If you are translating MEDCIN findings to RxNorm concepts and you only want RxNorm concepts
 of the term type (TTY) "SCD", you would use <see cref="F:Quippe.Coding.TranslationFilters.FilterTypeEnum.TermType"/> for the FilterType, "SCD" for the 
 FilterString, <see cref="F:Quippe.Coding.TranslationFilter.FilterOptionEnum.ExactMatch"/> for the FilterOption and leave IgnoreCase 
 at the default. The method
 would then set the Regex pattern appropriately to match only RxNorm concepts that have the exact string "SCD" 
 in the Name field of their associated term type. If on the other hand, you wanted all associated RxNorm codes 
 regardless of term type, you would leave the filter empty or call <see cref="M:Quippe.Coding.TranslationFilters.ClearPattern(Quippe.Coding.TranslationFilters.FilterTypeEnum)"/> to ensure the pattern is empty.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="M:Quippe.Coding.TranslationFilters.GetPattern(Quippe.Coding.TranslationFilters.FilterTypeEnum)">
	<summary>
 Gets the regular expression object for the specified filter type.
 </summary>
	<param name="FilterType">The type of the filter you wish to get, which must be one of the values from the Enum 
 <see cref="T:Quippe.Coding.TranslationFilters.FilterTypeEnum"/>.</param>
	<returns>Returns the regular expression (Regex) object if the filter is set and Nothing otherwise.</returns>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="M:Quippe.Coding.TranslationFilters.ClearPattern(Quippe.Coding.TranslationFilters.FilterTypeEnum)">
	<summary>
 Deletes the regular expression object for the specified filter type.
 </summary>
	<param name="FilterType">The type of the filter you wish to clear, which must be one of the values from the 
 Enum <see cref="T:Quippe.Coding.TranslationFilters.FilterTypeEnum"/>.</param>
	<remarks>
		<para>After clearing the pattern, there is essentially no filter in effect for the specified type and the 
 default behavior will be used for the filter.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="M:Quippe.Coding.TranslationFilters.HasPattern(Quippe.Coding.TranslationFilters.FilterTypeEnum)">
	<summary>
 Indicates whether a filter pattern for the specified filter exists (i.e., the associated filter pattern is not
 Nothing).
 </summary>
	<param name="FilterType">The type of the filter you are interested in, which must be one of the values from the
 Enum <see cref="T:Quippe.Coding.TranslationFilters.FilterTypeEnum"/>.</param>
	<returns>Returns True if the specified filter type has a pattern and False, otherwise, which means the default
 behavior will be used.</returns>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="P:Quippe.Coding.TranslationFilters.HasExternalPatterns">
	<summary>
 Determines whether a filter pattern exists for a filter that applies to external vocabularies (not MEDCIN).
 </summary>
	<returns>Returns True if there is a pattern for any filter that applies to external vocabularies, and False 
 otherwise.</returns>
	<remarks>
		<para>Some filters like the Prefix pattern apply only to the MEDCIN vocabulary. This function determines if
 any patterns are set other than the MEDCIN-specific filters.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="P:Quippe.Coding.TranslationFilters.HasPatterns">
	<summary>
 Gets a Boolean value indicating whether any of the filter patterns exist (i.e., any one of the filter patterns
 is not Nothing).
 </summary>
	<returns>Returns True if any of the filter patterns is specified, and False otherwise.</returns>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="M:Quippe.Coding.TranslationFilters.HasOnlyPattern(Quippe.Coding.TranslationFilters.FilterTypeEnum)">
	<summary>
 Gets a Boolean value indicating whether only the specified pattern is set.
 </summary>
	<returns>Returns True if the specified pattern has been specified and all other patterns are unspecified
 (clear or Nothing), otherwise returns False.</returns>
	<seealso cref="T:Quippe.Coding.TranslationFilter"/>
</member><member name="T:Quippe.Coding.TranslationFilters">
	<summary>
 Provides translation properties that may be used as filters on the code mapping records and source or target codes
 during code translation so as to focus the translation to return the most relevant target codes.
 </summary>
	<remarks>
		<para>Each String filter is an instance of a the <see cref="T:Quippe.Coding.TranslationFilter"/> class, which contains a regular expression
 pattern (and a <see cref="T:System.Text.RegularExpressions.Regex"/> class instance) that can be used to filter the code translation. You may specify the 
 string pattern for the regular expression or use options to set common filter patterns.</para>
		<para>If a filter is left empty or unspecified, then the default action will take place during translation for that filter.
 Medicomp's SQLite translator, <see cref="T:Quippe.Coding.StandardTranslator"/>, will not attempt to filter by an empty or unspecified filter.</para>
	</remarks>
</member><member name="P:Quippe.Coding.StandardParameters.Filters">
	<summary>
 Gets or sets the translation filters, which contain a set of <see cref="T:Quippe.Coding.TranslationFilter"/> objects, each of which can be a separate
 parameter to the SQLite translator, <see cref="T:Quippe.Coding.StandardTranslator"/>.
 </summary>
	<remarks>
		<para>The Filters property contains a set of translation filters, each of which is a <see cref="T:Quippe.Coding.TranslationFilter"/> object and can be
 a separate parameter to the standard translator's, <see cref="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> member. The translation filters are essentially
 regular expression patterns that are applied to the translation source entry, target entry or mapping data to filter the translation
 results to the desired maps.</para>
		<para>It is possible that the Filters property is set (contains a non-null reference to a TranslationFilters object), but there are 
 no filters defined. Check the <see cref="P:Quippe.Coding.StandardParameters.HasFilters"/> property to determine if at least one filter is defined.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.StandardParameters.EncounterDate">
	<summary>
 Gets or sets the date of the patient encounter.
 </summary>
	<remarks>
		<para>A coding service translation request that takes an encounter record (<see cref="T:Quippe.IEncounter"/>) 
 as an input parameter should pass the encounter date to the translator as an item in the <see cref="T:Quippe.Coding.TranslationParameters"/>
 associative collection that is a parameter of the translator's <see cref="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> member. The item would be assigned to 
 the collection using the String key, <see cref="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_DATE"/>, which contains the parameter name
 appropriate for this parameter.</para>
		<para>If the target vocabulary is versioned by code year, the SQLite translator, <see cref="T:Quippe.Coding.StandardTranslator"/>, 
 will consider only target codes in mappings that are valid for the code year on the encounter date. 
 </para>
		<para>The encounter date is typically obtained from the encounter record (IEncounterRecord) associated with
 the patient for which code translation is desired.
 </para>
	</remarks>
</member><member name="P:Quippe.Coding.StandardParameters.Options">
	<summary>
 Gets or sets a TranslationOptions instance containing options to control the translation.
 </summary>
	<remarks>
		<para>A coding service translation request that wants to obtain code hints (see <see cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>) or code specifiers
 (see <see cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>) for each target code should pass the a TranslationOptions 
 instance as an item in the <see cref="T:Quippe.Coding.TranslationParameters"/>
 associative collection that is a parameter of the translator's <see cref="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> member. The item would be assigned to 
 the collection using the String key, <see cref="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_OPTIONS"/>, which contains the parameter name
 appropriate for this parameter.</para>
		<para>The SQLite translator, <see cref="T:Quippe.Coding.StandardTranslator"/>, checks the <see cref="P:Quippe.Coding.TranslationOptions.HintOption"/> and 
 <see cref="P:Quippe.Coding.TranslationOptions.SpecifierOption"/> properties to determine whether (and how) code hints and code specifiers are 
 retrieved with the target codes during the translation.</para>
		<para>The SQLite translator also checks the <see cref="P:Quippe.Coding.TranslationOptions.AutoGenerationOption"/> property to determine whether maps
 from prefixed and/or qualified MEDCIN concepts should be auto-generated from a base map when explicity specified maps are not available.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
</member><member name="P:Quippe.Coding.StandardParameters.VocabExtensionCode">
	<summary>
 Gets or sets the vocabulary extension code.
 </summary>
	<remarks>
		<para>The vocabulary extension code is used to indicate whether a particular vocabulary extension will be used during the translation
 to include additional possible target codes from the extension to an external vocabulary.</para>
		<para>At present, only a single vocabulary extension code is permitted for the SNOMED vocabulary only.</para>
	</remarks>
</member><member name="P:Quippe.Coding.StandardParameters.HasExternalFilters">
	<summary>
 Indicates whether a value has been specified for the <see cref="P:Quippe.Coding.StandardParameters.Filters"/> property and that filter applies to the
 map data or to an external (non-MEDCIN) target vocabulary.
 </summary>
	<returns>Returns True if the <see cref="P:Quippe.Coding.StandardParameters.Filters"/> property has been specified and the referenced <see cref="T:Quippe.Coding.TranslationFilters"/> object
 in the property contains at least one filter that is applicable to code translation
 results that do not have MEDCIN as the target vocabulary (i.e., <see cref="P:Quippe.Coding.TranslationFilters.HasExternalPatterns"/> returns True), and returns
 False otherwise.</returns>
	<remarks>
		<para>Some filters like the PrefixCode filter apply only to the MEDCIN vocabulary. This function determines if any patterns are set other than the MEDCIN-specific filters.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
	<seealso cref="T:Quippe.Coding.TranslationFilters"/>
	<seealso cref="T:Quippe.Coding.StandardTranslator"/>
</member><member name="P:Quippe.Coding.StandardParameters.HasFilters">
	<summary>
 Indicates whether the <see cref="P:Quippe.Coding.StandardParameters.Filters"/> property contains at least one translation filter.
 </summary>
	<returns>Returns True if the <see cref="P:Quippe.Coding.StandardParameters.Filters"/> property has been specified and the referenced <see cref="T:Quippe.Coding.TranslationFilters"/> object
 in the property contains at least one filter, and returns False otherwise.</returns>
	<remarks>
		<para>The <see cref="P:Quippe.Coding.StandardParameters.Filters"/> property contains a set of translation filters, each of which is a <see cref="T:Quippe.Coding.TranslationFilter"/> object and can be
 a separate parameter to the SQLite translator's, <see cref="M:Quippe.Coding.StandardTranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> member. The translation filters are essentially
 regular expression patterns that are applied to the translation source entry, target entry or mapping data to filter the translation
 results to the desired maps.</para>
		<para>It is possible that the Filters property is set (contains a non-null reference to a TranslationFilters object), but there are 
 no filters defined, in which case the this property (HasFilters) would return False.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.StandardParameters.HasEncounterDate">
	<summary>
 Indicates whether a value has been specified for the <see cref="P:Quippe.Coding.StandardParameters.EncounterDate"/> property.
 </summary>
	<returns>Returns True if the <see cref="P:Quippe.Coding.StandardParameters.EncounterDate"/> property has been specified, i.e., is not Nothing, and
 False otherwise.</returns>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
	<seealso cref="T:Quippe.Coding.StandardTranslator"/>
</member><member name="P:Quippe.Coding.StandardParameters.HasOptions">
	<summary>
 Indicates whether a valid value has been specified for the <see cref="P:Quippe.Coding.StandardParameters.Options"/> property.
 </summary>
	<returns>Returns True if the <see cref="P:Quippe.Coding.StandardParameters.Options"/> property has been specified, i.e., is not Nothing, and
 False otherwise.</returns>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
	<seealso cref="T:Quippe.Coding.StandardTranslator"/>
</member><member name="P:Quippe.Coding.StandardParameters.HasVocabExtension">
	<summary>
 Indicates whether a value has been specified for the <see cref="P:Quippe.Coding.StandardParameters.VocabExtensionCode"/> property.
 </summary>
	<returns>Returns True if the <see cref="P:Quippe.Coding.StandardParameters.VocabExtensionCode"/> property has been specified, and
 False otherwise.</returns>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
	<seealso cref="T:Quippe.Coding.StandardTranslator"/>
</member><member name="P:Quippe.Coding.StandardParameters.ProcessingRequired(Quippe.Coding.MedcinCodeEntry)">
	<summary>
 Indicates whether the SQLite translation service provide will need to perform processing of mapping results after the initial translation has been performed.
 </summary>
	<param name="Entry">The MedcinCodeEntry containing the properties used for resolving translations against parameterized codes.</param>
	<returns>Returns True if post processing should be performed, and False otherwise.</returns>
	<remarks>
		<para>Post processing of the mapping results of a code translation is typically performed to obtain code hints or code specifiers associated with the
 target codes in the mapping results.</para>
		<para>Post processing of translation results by the SQLite translator, <see cref="T:Quippe.Coding.StandardTranslator"/>, is necessary if a 
 code hints option (<see cref="P:Quippe.Coding.TranslationOptions.HintOption"/>) or code specifiers option (<see cref="P:Quippe.Coding.TranslationOptions.SpecifierOption"/>)
 has been set in the <see cref="P:Quippe.Coding.StandardParameters.Options"/> property or if the target codes are base codes from which more parameterized codes can be obtained from parameters
 (see <see cref="P:Quippe.Coding.StandardParameters.CheckForCodeParameters(Quippe.Coding.MedcinCodeEntry)"/>).</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.StandardParameters.CheckForCodeParameters(Quippe.Coding.MedcinCodeEntry)">
	<summary>
 Indicates whether the specified Medcin code entry has properties that warrant searching for parameterized codes of either type, value-style,
 such as ICD9 BMI, or result-style, in cases where both positive ("Abnormal") and negative ("Normal") concepts exist in the target code set.
 </summary>
	<param name="Entry">The MedcinCodeEntry containing the properties used for resolving translations against parameterized codes.</param>
	<returns>Returns True if the parameters required for parameterized code processing have been specified, and False otherwise.</returns>
	<remarks>
		<para>A target code (e.g., a <see cref="T:Quippe.Coding.ExternalCodeEntry"/> instance) referenced in the mapping results 
 (e.g., body mass index, BMI, "V85.0" in ICD-9-CM) may lead to a more detailed 
 code when additional parameters are defined (e.g., result code or gender, age and measurement value).</para>
		<para>The BMI code "V85.0" in ICD-9-CM is an example of a value-style parameterized code, as it requires a measurement value, age and sex, to 
 obtain the detailed code. The <see cref="P:Quippe.Coding.StandardParameters.CheckForValueStyleCodeParameters(Quippe.Coding.MedcinCodeEntry)"/> property indicates whether the required parameters are available for
 processing a value-style parameterized code. If <see cref="P:Quippe.Coding.MedcinCodeEntry.HasAge"/>, <see cref="P:Quippe.Coding.MedcinCodeEntry.HasSex"/> and 
 <see cref="P:Quippe.Coding.MedcinCodeEntry.HasNumericValue"/> properties return True (i.e., Age &gt; 0, Sex not empty, and Value a numeric value) 
 and the target code of the translation is parameterized, the SQLite translator, <see cref="T:Quippe.Coding.StandardTranslator"/>, will attempt
 to get the resulting parameterized code from the base code that is mapped to MEDCIN.
 </para>
		<para>A result-style parameterization requires only a value in the <see cref="P:Quippe.Coding.MedcinCodeEntry.Result"/> property to obtain a more detailed code. 
 The <see cref="P:Quippe.Coding.StandardParameters.CheckForResultStyleCodeParameters(Quippe.Coding.MedcinCodeEntry)"/> indicates whether the required parameters are available for
 processing a result-style parameterized code.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.StandardParameters.CheckForValueStyleCodeParameters(Quippe.Coding.MedcinCodeEntry)">
	<summary>
 Indicates whether the specified Medcin code entry has properties that warrant searching for parameterized codes that depend on measurement values,
 such as body mass index (BMI).
 </summary>
	<param name="Entry">The MedcinCodeEntry containing the properties used for resolving translations against parameterized codes.</param>
	<returns>Returns True if the Medcin code entry properties required for value-style parameterized code processing have been specified, and False otherwise.</returns>
	<remarks>
		<para>A target code (e.g., a <see cref="T:Quippe.Coding.ExternalCodeEntry"/> instance) referenced in the mapping results (e.g., body mass index, BMI, "V85.0" in ICD-9-CM) 
 may lead to a more detailed code when additional parameters are defined (e.g., result code or sex, age and measurement value).</para>
		<para>The BMI code "V85.0" in ICD-9-CM is an example of a value-style parameterized code, as it requires a measurement value, age and sex, to 
 obtain the detailed code.</para>
		<para>This property indicates whether the required code entry properties are available for
 processing a value-style parameterized code. If <see cref="P:Quippe.Coding.MedcinCodeEntry.HasAge"/>, <see cref="P:Quippe.Coding.MedcinCodeEntry.HasSex"/> and <see cref="P:Quippe.Coding.MedcinCodeEntry.HasValue"/> 
 properties return True (i.e., Age &gt; 0, Sex not empty, and Value a numeric value) 
 and the target code of the translation is parameterized, the SQLite translator, <see cref="T:Quippe.Coding.StandardTranslator"/>, will attempt
 to get the resulting parameterized code from the base code that is mapped to MEDCIN.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.StandardParameters.CheckForValueStyleCodeParameters(System.Int32,System.String,System.String)">
	<summary>
 Indicates whether the specified Medcin code entry has properties that warrant searching for parameterized codes that depend on measurement values,
 such as body mass index (BMI).
 </summary>
	<param name="Age">Age of the patient in minutes.</param>
	<param name="Sex">The sex of the patient, either "M" for male, "F" for female, or "U" for unspecified.</param>
	<param name="TestValue">The numeric test value of the finding passed as a String in the standard unit for the finding.</param>
	<returns>Returns True if the Medcin code entry properties required for value-style parameterized code processing have been specified, and False otherwise.</returns>
	<remarks>
		<para>A target code (e.g., a <see cref="T:Quippe.Coding.ExternalCodeEntry"/> instance) referenced in the mapping results (e.g., body mass index, BMI, "V85.0" in ICD-9-CM) 
 may lead to a more detailed code when additional parameters are defined (e.g., result code or sex, age and measurement value).</para>
		<para>The BMI code "V85.0" in ICD-9-CM is an example of a value-style parameterized code, as it requires a measurement value, age and sex, to 
 obtain the detailed code.</para>
		<para>This property indicates whether the required code entry properties are available for
 processing a value-style parameterized code. If Age, Sex and Value parameters are specified and valid(i.e., Age &gt; 0, Sex not empty, and Value a numeric value) 
 and the target code of the translation is parameterized, the SQLite translator, <see cref="T:Quippe.Coding.StandardTranslator"/>, will attempt
 to get the resulting parameterized code from the base code that is mapped to MEDCIN.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.StandardParameters.CheckForResultStyleCodeParameters(Quippe.Coding.MedcinCodeEntry)">
	<summary>
 Indicates whether the specified Medcin code entry has properties that warrant searching for parameterized codes that depend on the result code,
 i.e., abnormal/positive or normal/negative.
 </summary>
	<returns>Returns True if the Medcin code entry properties required for result-style parameterized code processing have been specified, and False otherwise.</returns>
	<remarks>
		<para>This method is no longer necessary because result-style parameterized maps are now represented as normal maps in the coding service DB.</para>
		<para>A result-style parameterization requires only a value in the <see cref="P:Quippe.Coding.MedcinCodeEntry.Result"/> property and no value in the Entry
 to obtain a more detailed code.</para>
		<para>This property indicates whether the required code entry properties are available for
 processing a result-style parameterized code. If the <see cref="P:Quippe.Coding.MedcinCodeEntry.Result"/> property specified and no value is specified in the Entry, i.e., 
 <see cref="P:Quippe.Coding.MedcinCodeEntry.HasValue"/> property is False, and the target code of the translation is parameterized, the SQLite translator, 
 <see cref="T:Quippe.Coding.StandardTranslator"/>, will attempt to get the resulting parameterized code from the base code that is mapped to MEDCIN.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.StandardParameters.CheckForCodeHints">
	<summary>Indicates whether an option has been specified that requires the translator to obtain code hints.</summary>
	<remarks>
		<para>Post processing of the mapping results of a code translation may be performed by the SQLite translator,
 <see cref="T:Quippe.Coding.StandardTranslator"/>, to obtain any available code hints associated with the target codes in the mapping results
 if the <see cref="P:Quippe.Coding.StandardParameters.Options"/> property has a relevant hint option set (see <see cref="P:Quippe.Coding.TranslationOptions.HintOption"/>).</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.StandardParameters.CheckForCodeSpecifiers">
	<summary>Indicates whether an option has been specified that requires the translator to obtain code specifiers.</summary>
	<remarks>
		<para>Post processing of the mapping results of a code translation may be performed by the V2 translator,
 <see cref="T:Quippe.Coding.StandardTranslator"/>, to obtain any available code specifiers associated with the target codes in the mapping results
 if the <see cref="P:Quippe.Coding.StandardParameters.Options"/> property has relevant a code specifier option set (see <see cref="P:Quippe.Coding.TranslationOptions.SpecifierOption"/>).</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.StandardParameters.CheckToGenerateMaps">
	<summary>Indicates whether an option has been specified that requires the translator to auto-generate mappings from prefixed and/or qualified MEDCIN source concepts.</summary>
	<remarks>
		<para>Post processing of the mapping results of a code translation may be performed by the SQLite translator,
 <see cref="T:Quippe.Coding.StandardTranslator"/>, to auto-generate maps from prefixed and/or qualified MEDCIN source concepts
 if the <see cref="P:Quippe.Coding.StandardParameters.Options"/> property has the <see cref="P:Quippe.Coding.TranslationOptions.AutoGenerationOption"/> set and if the
 conditions for auto-generation are met.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="T:Quippe.Coding.StandardParameters">
	<summary>
 Class with explicit properties for each parameter handled by the standard code translation service provider, <see cref="T:Quippe.Coding.StandardTranslator"/>.
 </summary>
	<remarks>
		<para>Each parameter that may be passed to Medicomp's standard translation provider, <see cref="T:Quippe.Coding.StandardTranslator"/>, has a corresponding property in this class.
 These properties are assigned values when the translation parameter values passed to the standard translation provider are parsed prior to translation. This
 makes it easier to pass the parsed parameter values around within the translator while translation is being performed.</para>
		<para>Parameters are passed to a translation provider implementing the <see cref="T:Quippe.Coding.ITranslator"/> interface using the <see cref="T:Quippe.Coding.TranslationParameters"/> class.</para>
	</remarks>
</member><member name="T:Quippe.Coding.TranslatorEntry.TranslatorEntryComparer">
	<summary>
 Class used to sort TranslatorEntry instances by the priority given by their Priority property.
 </summary>
	<remarks><para>The CodeMappingService uses this class to sort available translators by priority.</para>
		<para>A translator's priority is determined by the priority set in the TranslatorAttribute decorating the translator's 
 class declaration.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeMappingService"/>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="P:Quippe.Coding.TranslatorEntry.Priority">
	<summary>
 The priority of the translator, as specified in the TranslatorAttribute decorating the declaration of the translator's class.
 </summary>
	<value>Integer priority indicating the order in which translators are considered for performing a particular code translation.</value>
	<remarks>Higher values indicate higher priority. A code mapping service (implementing ICodeMappingService)
 should use the priority to determine the order in which translators are considered appropriate for performing a particular 
 code translation. The highest priority translator should be considered first. The translator that normally would be used is the
 highest priority translator available that is capable of performing the translation, i.e., that supports
 translation between the source and target vocabularies.</remarks>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="M:Quippe.Coding.CodeMappingService.GetTranslator(System.Type)"/>
	<seealso cref="M:Quippe.Coding.CodeMappingService.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="P:Quippe.Coding.TranslatorEntry.Type">
	<summary>
 Gets or sets the translator's declaring Type, that is an instance of the Type class representing the type specified in the translator's class declaration.
 </summary>
	<returns>Returns an instance of the Type class representing the translator's declaring type.</returns>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
</member><member name="P:Quippe.Coding.TranslatorEntry.Translator">
	<summary>
 Gets or sets an instance of the translation service provider implementing ITranslator associated with this entry.
 </summary>
	<returns>The translator instance of type Type associated with this translator entry.</returns>
	<remarks>When translators are loaded, this property is used to hold the an instance of the translator,
 which can be used to perform the translations.</remarks>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
</member><member name="M:Quippe.Coding.TranslatorEntry.LoadTranslators(Quippe.ScopedServiceManager)">
	<summary>
 Shared function that loads available translation service providers, i.e., translators.
 </summary>
	<returns>Returns the available translators in a collection, List(Of TranslatorEntry), of TranslatorEntry
 instances sorted by the translator's priority.</returns>
	<remarks>This function can be used by a coding service to load the available translators in TranslatorEntry
 objects and sort the loaded entries by translator priority. If no translators are available, an empty
 list is returned.</remarks>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="M:Quippe.Coding.CodeMappingService.GetTranslator(System.Type)"/>
	<seealso cref="M:Quippe.Coding.CodeMappingService.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="M:Quippe.Coding.TranslatorEntry.ToString">
	<summary>
 Returns the string representation of this TranslatorEntry.
 </summary>
	<remarks>By default, the string representation is the full name of the associated translator's declaring Type.</remarks>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
</member><member name="T:Quippe.Coding.TranslatorEntry">
	<summary>
 Class that represents an available code translation service provider, referred to as a translator, and its associated attribute information.
 </summary>
	<remarks>
		<para>This class is used to store information regarding available code translation service providers, or translators, implementing the
 ITranslator interface that have been loaded by a coding service. A collection of TranslatorEntry instances represents the
 translators available to the service. Each entry contains the translator's attributes, its declaring Type and an instance
 of the translator.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeMappingService"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="P:Quippe.Coding.TranslatorAttribute.Priority">
	<summary>
 Gets or sets an integer value indicating the priority given to the translator for any translation between a 
 supported source and target vocabulary.
 </summary>
	<value>The integer priority value. Higher values have higher priority.</value>
	<remarks><para>The standard code mapping service uses the priority value to determine the best ITranslator provider
 to use to perform a code mapping translation.</para></remarks>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="M:Quippe.Coding.CodeMappingService.GetTranslator(System.Type)"/>
	<seealso cref="M:Quippe.Coding.CodeMappingService.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/>
</member><member name="T:Quippe.Coding.TranslatorAttribute">
	<summary>
 Class representing the custom attribute used to decorate service provider classes implementing the ITranslator interface.
 </summary>
	<remarks><para>Use the attribute to give a priority to a translator service provider implementing the ITranslator interface.</para></remarks>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="M:Quippe.Coding.CodeMappingService.GetTranslator(System.Type)"/>
	<seealso cref="M:Quippe.Coding.CodeMappingService.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/>
</member><member name="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_AGE">
	<summary>Name for a parameter specifying the patient's age at the time of the encounter.</summary>
</member><member name="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_DATE">
	<summary>Name for a parameter specifying the encounter date.</summary>
</member><member name="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_MODIFIER">
	<summary>Name for a parameter specifying the modifier code associated with an encounter entry.</summary>
</member><member name="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_PREFIX">
	<summary>Name for a parameter specifying the MEDCIN prefix associated with an encounter entry.</summary>
</member><member name="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_RESULT">
	<summary>Name for a parameter specifying the result code associated with an encounter entry.</summary>
</member><member name="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_SEX">
	<summary>Name for a parameter specifying the patient's sex.</summary>
</member><member name="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_STATUS">
	<summary>Name for a parameter specifying the status code associated with an encounter entry.</summary>
</member><member name="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_UNIT">
	<summary>Name for a parameter specifying the test/measurement value units associated with an encounter entry.</summary>
</member><member name="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_VALUE">
	<summary>Name for a parameter specifying the test/measurement value associated with an encounter entry.</summary>
</member><member name="F:Quippe.Coding.TranslationParameters.PARAMETER_NAME_OPTIONS">
	<summary>Name for a parameter specifying translation options.</summary>
</member><member name="P:Quippe.Coding.TranslationParameters.Item(System.String)">
	<summary>
 Gets the parameter value, as an Object, that is associated with the specified parameter name.
 </summary>
	<param name="Name">The parameter name.</param>
	<returns>Returns the parameter value as an Object.</returns>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="P:Quippe.Coding.TranslationParameters.Count">
	<summary>
 Gets the number of parameters contained in the collection.
 </summary>
	<returns>Returns the number of parameters contained in the collection.</returns>
</member><member name="P:Quippe.Coding.TranslationParameters.Names">
	<summary>
 Gets a TranslationParameterNames object containing the parameter names that have an associated Object value in this collection of parameters.
 </summary>
	<returns>Returns a TranslationParameterNames object containing the names of parameters in this parameter collection.</returns>
</member><member name="M:Quippe.Coding.TranslationParameters.GetValue(System.String)">
	<summary>
 Gets the Object value, i.e., the parameter value, associated with the specified parameter name.
 </summary>
	<param name="Name">The parameter name.</param>
	<returns>Returns the parameter value as a String.</returns>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="M:Quippe.Coding.TranslationParameters.GetValue``1(System.String,``0)">
	<summary>
 Gets the Object value, i.e., the parameter value, associated with the specified parameter name.
 </summary>
	<typeparam name="T">The Type of the parameter value.</typeparam>
	<param name="Name">The name of the parameter.</param>
	<param name="DefaultValue">The value to return if the named parameter is not contained in the collection.</param>
	<returns>Returns the parameter value of type T associated with the specified parameter name, if the named parameter is contained in
 collection, or the DefaultValue otherwise.</returns>
	<exception cref="T:System.NotSupportedException">Thrown if the conversion of the parameter data to the specified type T cannot be performed.</exception>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="M:Quippe.Coding.TranslationParameters.Add(System.String,System.Object)">
	<summary>
 Adds or replaces the parameter value associated with the specified parameter name.
 </summary>
	<param name="Name">The name of the parameter to add or replace.</param>
	<param name="Value">The value of the parameter to add or replace as an Object.</param>
	<remarks>This method adds the named parameter and value to the collection if the collection does not already
 contain a parameter of that name. If the named parameter is already in the collection, this method replaces
 the value with that specified. The operation is case-insensitive with respect to the parameter name.
 </remarks>
</member><member name="M:Quippe.Coding.TranslationParameters.Remove(System.String)">
	<summary>
 Removes the specified parameter from the collection.
 </summary>
	<param name="Name">The name of the parameter to remove.</param>
	<remarks>If the named parameter is contained in the collection, this method removes the parameter and its
 value, otherwise this method has no effect. The operation is case-insensitive with respect to the parameter
 name.</remarks>
</member><member name="M:Quippe.Coding.TranslationParameters.Contains(System.String)">
	<summary>
 Determines whether the collection contains the a parameter with the specified name.
 </summary>
	<param name="Name">The name of the parameter.</param>
	<returns>Returns True if the named parameter is contained in the collection and False otherwise.</returns>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="M:Quippe.Coding.TranslationParameters.Clear">
	<summary>
 Removes all parameter names and values from the collection.
 </summary>
	<remarks>The count property is set to 0 and references to other objects from elements of the collection are
 also released.</remarks>
</member><member name="M:Quippe.Coding.TranslationParameters.Filter(System.Collections.Generic.ICollection{System.String})">
	<summary>
 Filters the collection of parameters to those specified in the input collection of parameter names.
 </summary>
	<param name="ParameterNames">The collection of names of the parameters that are desired as an ICollection(Of String).</param>
	<returns>Returns a new TranslationParameters object containing only those parameters having a name that is specified in the
 ParameterNames collection. If no parameters in the specified collection are found, then Nothing is
 returned.</returns>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="M:Quippe.Coding.TranslationParameters.Filter(Quippe.Coding.TranslationParameterNames)">
	<summary>
 Filters the collection of parameters to those specified in the input collection of parameter names.
 </summary>
	<param name="ParameterNames">The collection of names of the parameters that are desired as a TranslationParameterNames object.</param>
	<returns>Returns a new TranslationParameters object containing only those parameters having a name that is specified in the
 ParameterNames collection. If no parameters in the specified collection are found, then Nothing is
 returned.</returns>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
</member><member name="M:Quippe.Coding.TranslationParameters.NormalizeSex(System.String)">
	<summary>
 Returns a normalized code for sex indicating either female or male based on the input code, which could
 include an unknown value.
 </summary>
	<param name="Code">Input sex code, one of "F" or "f" for female, "M" or "m" for male and "U" or "u" for unknown.</param>
	<returns>Returns "F" if input indicates female or "M" in input indicates male or unknown. Returns the empty string
 if an invalid value is passed as input code.</returns>
	<remarks>
		<para>Male, "M" is the default value if the input code is "U" or "u".</para>
	</remarks>
</member><member name="M:Quippe.Coding.TranslationParameters.ResultToValue(System.String)">
	<summary>
 Converts a MEDCIN result code indicating an abnormal ("A") or a normal ("N") finding and returns an integer equivalent used in searching for
 codes parameterized by result.
 </summary>
	<param name="ResultCode">The String result code to convert.</param>
	<returns>Returns 1 for positive/abnormal result codes, -1 for negative/normal codes, and 0 if the result code is invalid.</returns>
	<remarks></remarks>
</member><member name="T:Quippe.Coding.TranslationParameters">
	<summary>
 Class representing a collection of parameters passed to the translation API of a coding service or coding 
 translation provider (i.e., an implementation of ITranslator).
 </summary>
	<remarks>Translation parameters consist of a collection of name-value pairs. For each parameter, the
 parameter's String name and value, as an Object type, are specified. Parameter names are treated as 
 case-insensitive in all methods and properties.</remarks>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.TranslationOptions"/>
	<seealso cref="T:Quippe.Coding.TranslationParameterNames"/>
</member><member name="M:Quippe.Coding.TranslationParameterNames.#ctor">
	<summary>
 Creates an empty parameter names collection.
 </summary>
	<seealso cref="P:Quippe.Coding.ITranslator.ParameterNames"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="M:Quippe.Coding.TranslationParameterNames.#ctor(System.Collections.Generic.ICollection{System.String})">
	<summary>
 Creates a parameter names collection containing the specified String names.
 </summary>
	<seealso cref="P:Quippe.Coding.ITranslator.ParameterNames"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.TranslationParameterNames.Count">
	<summary>
 Gets the number of parameter names contained in the collection.
 </summary>
	<returns>Returns the number of parameters contained in the collection.</returns>
	<seealso cref="P:Quippe.Coding.ITranslator.ParameterNames"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="P:Quippe.Coding.TranslationParameterNames.Values">
	<summary>
 Gets or sets the names in this collection.
 </summary>
	<remarks>
		<para>If this is a set operation, all existing names are cleared before adding the names in the input
 collection. If the input collection is Nothing, then this collection is not cleared.</para>
		<para>If this is a get operation, all names in the returned collection are in the same case as when
 added and therefore any comparisons to names in the returned collection should be done on a case-insensitive
 basis as parameter names are case-insensitive.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.ITranslator.ParameterNames"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="M:Quippe.Coding.TranslationParameterNames.Add(System.String)">
	<summary>
 Adds the specified parameter name to the collection.
 </summary>
	<param name="Name">The parameter name to add.</param>
	<remarks>Parameter names are case-insensitive and are stored in the collection accordingly.</remarks>
	<seealso cref="P:Quippe.Coding.ITranslator.ParameterNames"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="M:Quippe.Coding.TranslationParameterNames.Remove(System.String)">
	<summary>
 Removes the specified name from the collection.
 </summary>
	<param name="Name">The name of the parameter to remove.</param>
	<remarks>If the name is contained in the collection, this method removes the name, otherwise this method
 has no effect. The operation is case-insensitive with respect to the name.</remarks>
	<seealso cref="P:Quippe.Coding.ITranslator.ParameterNames"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="M:Quippe.Coding.TranslationParameterNames.Contains(System.String)">
	<summary>
 Determines whether the collection contains the specified parameter.
 </summary>
	<param name="Name">The name of the parameter.</param>
	<returns>Returns True if the named parameter is contained in the collection and False otherwise.</returns>
	<remarks>The operation is case-insensitive with respect to the parameter name.</remarks>
	<seealso cref="P:Quippe.Coding.ITranslator.ParameterNames"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="M:Quippe.Coding.TranslationParameterNames.Clear">
	<summary>
 Removes all names from the collection.
 </summary>
	<remarks>The count property is set to 0.</remarks>
	<seealso cref="P:Quippe.Coding.ITranslator.ParameterNames"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="T:Quippe.Coding.TranslationParameterNames">
	<summary>
 Class representing a collection of translation parameter names stored as String objects.
 </summary>
	<remarks>
		<para>Translation service providers implementing the ITranslator interface return the names of the parameters the translator supports in
 an instance of this class from the providers implementation of the <see cref="P:Quippe.Coding.ITranslator.ParameterNames"/> property.</para>
		<para>Parameter names are considered case-insensitive and are treated as such by this class when comparisons are made or
 containment in the collection is checked.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="F:Quippe.Coding.TranslationOptions.HintOptionEnum.Unspecified">
	<summary>Indicates the option has not been specified and the default action will be taken by the translator.</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.HintOptionEnum.None">
	<summary>Indicates that code hints should not be retrieved.</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.HintOptionEnum.Text">
	<summary>Indicates that only the code hint text should be retrieved, if hints are available. This would include both a purely textual type hint and the text for hints that reference codes (e.g., a "code first" hint).</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.HintOptionEnum.TextAndMaps">
	<summary>Indicates that the code hint text should be retrieved, if available, as well as any reverse maps from referenced codes in the target vocabulary back to the source vocabulary (e.g., MEDCIN).</summary>
</member><member name="T:Quippe.Coding.TranslationOptions.HintOptionEnum">
	<summary>
 Defines the options that control whether and how code hints are retrieved during translation. 
 </summary>
	<remarks>
		<para>Certain coding systems, most notably ICD-9-CM, have coding hints associated with certain codes. These hints
 may indicate additional coding requirements associated with the base code, for example, that another code must be coded first.
 These enumerated values provide a means to control whether code hints are retrieved during the code translation process and
 how much detail associated with the hint should be retrieved.</para>
		<para>Each translation provider may handle code hints differently and some may not recognize the code hints option. If an
 option is set to retrieve code hints, and the translator recognizes this option, the translator should retrieve code hints associated
 with the target code when the code translation is performed. Some translators may also retrieve code hints associated with the source
 code of the requested translation.</para>
		<para>Medicomp coding data associates code hints with external vocabularies only and not with MEDCIN.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>
</member><member name="F:Quippe.Coding.TranslationOptions.SpecifierOptionEnum.Unspecified">
	<summary>Indicates the option has not been specified and the default action will be taken by the translator.</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.SpecifierOptionEnum.None">
	<summary>Indicates that code specifiers should not be retrieved.</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.SpecifierOptionEnum.Lists">
	<summary>Indicates the code specifier data should be retrieved, if available.</summary>
</member><member name="T:Quippe.Coding.TranslationOptions.SpecifierOptionEnum">
	<summary>
 Defines the options that control whether and how code specifier data is retrieved during translation.
 </summary>
	<remarks>
		<para>Certain coding systems may have code specifier data associated with certain codes. Code specifier data provides additional
 detail associated with the base code that should be specified to qualify the base concept or to arrive at sufficiently detailed
 code for billing. Code specifier data takes the form of one or more lists of items that may be chosen by the user to refine
 the base code. The items are usually associated with qualifying descriptions, or qualifying concepts (e.g., laterality "left").</para>
		<para>Each translation provider may handle code specifiers differently and some may not recognize the code specifiers option. If an
 option is set to retrieve code specifiers, and the translator recognizes this option, the translator should retrieve code specifiers 
 associated with the target code when the code translation is performed. Some translators may also retrieve code hints associated with the source
 code of the requested translation.</para>
		<para>Medicomp coding data associates code specifier data with external vocabularies only and not with MEDCIN.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
	<seealso cref="P:Quippe.Coding.Vocabulary.SpecifierUsage"/>
</member><member name="F:Quippe.Coding.TranslationOptions.AutoGenerationOptionEnum.Unspecified">
	<summary>Indicates the option has not been specified and the default action will be taken by the translator.</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.AutoGenerationOptionEnum.None">
	<summary>Indicates that maps should not be automatically generated.</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.AutoGenerationOptionEnum.Maps">
	<summary>Indicates that maps should be automatically generated, if possible.</summary>
</member><member name="T:Quippe.Coding.TranslationOptions.AutoGenerationOptionEnum">
	<summary>
 Defines the options that control whether mappings are automatically generated when possible.
 </summary>
	<remarks>
		<para>Medicomp uses this option in its SQLite translation provider to automatically generate mappings from qualified MEDCIN concepts to SNOMED
 when such mappings do not exist in the mapping database and when a base map from the unqualified MEDCIN concept already exists. For instance,
 if a MEDCIN concept representing a disease has a "Same As" map to the equalivent concept in SNOMED, but does not have a map from the prefixed 
 MEDCIN concept (e.g., history of that disease) to SNOMED, in certain situations, the translator can automatically generate the mapping,
 provided this options is set.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.Vocabulary.IsAutoGenerationCapable"/>
</member><member name="F:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOptionEnum.Unspecified">
	<summary>Indicates the option has not been specified and the default action will be taken by the translator.</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOptionEnum.Normal">
	<summary>Indicates a qualifier on the input Medcin concept should match loosely (using Loose option) on the Result
 qualifier and use the Alternate option on the Modifier and Status Qualifier qualifiers.</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOptionEnum.Loose">
	<summary>Indicates a qualifier on the input Medcin concept should be matched loosely to the Medcin concept in the potential maps.
 An empty input qualifier will match all potential maps, qualified on not. A specific input qualifier will match potential maps that
 do not contradict the input qualifier (i.e., no qualifier on map or the match is exact).</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOptionEnum.Strict">
	<summary>Indicates a qualifier on the input Medcin concept should be strictly (exactly) matched to the Medcin concept in the potential maps.
 An empty input qualifier will match potential maps that also have empty qualifiers. A specific input qualifier will match potential maps
 that exactly match the input qualifier.</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOptionEnum.Alternate">
	<summary>This is similar to the Hybrid option, but alternatives may be returned. Indicates that qualifiers on the input Medcin concept 
 should be matched to the qualifiers of the Medcin concept in the potential maps using an alternate method, that is, alternate maps should
 be returned if exact matches to specified input qualifiers cannot be found.
 Empty input qualifiers will match all potential maps, qualified on not. Explicitly specified (i.e., non-empty) qualifiers of the input
 finding instance will be matched strictly (exactly) against the qualifier in the map; these matching maps will be returned, provided the 
 maps have a "Same As" or "Narrow Than" relationship, however if no such exactly matching maps exist, then all potential matching maps 
 will be returned (as in loose option).</summary>
</member><member name="F:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOptionEnum.Hybrid">
	<summary>This option is a hybrid between Strict and Loose. Indicates a qualifier on the input Medcin concept should be matched to the Medcin concept 
 in the potential maps using a hybrid method. An empty input qualifier will match all potential maps, qualified on not. An explicitly specified
 (i.e., non-empty) qualifier of the input finding instance must match strictly (exactly) against the potential maps (it will not match to an empty
 qualifier in the map).
 </summary>
</member><member name="T:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOptionEnum">
	<summary>
 Defines the options that control how input Medcin concepts are matched against maps when Medcin qualifiers such as the status qualifier,
 modifier and result qualifier are defined on the input Medcin concept and/or on the Medcin concept in the map.
 </summary>
	<remarks><para>Medicomp uses this option in the SQLite translation provider to determine which maps to return from the requested
 translation, but only when Medcin qualifiers are defined on the input Medcin concept or in the potential map results. The
 Medcin qualifiers affected by this option are the Medcin status qualifier, Medcin modifier and Medcin result qualifier.</para>
		<para>
 Consider the following example. Suppose we have two maps involving the Medcin concept "Headache" mapped to an 
 external vocabulary:
 <list type="number">
				<item><description>"Headache" ---SameAs---&gt; "Headache" - this is an unqualified map</description></item>
				<item><description>"Headeache" + Modifier="Severe" ---SameAs---&gt; "Severe headache" - this map qualified only by modifier</description></item>
				<item><description>"Headache" + Modifier="Mild" ---SameAs---&gt; "Mild headache"</description></item>
			</list>
 Suppose a translation request contains an unqualified Medcin source entry of "Headache". The translation
 would return different results depending on the match option:
 <list type="bullet">
				<item><description>Strict option: map #1</description></item>
				<item><description>Loose option: map #1 followed by maps #3 and #2 (sort on qualifier code would put 3 before 2)</description></item>
				<item><description>Alternate option: map #1 followed by maps #3 and #2</description></item>
				<item><description>Hybrid option: map #1 followed by maps #3 and #2</description></item>
			</list>
 Next, suppose the translation request contains a qualified Medcin source entry of "Headache" + Modifier="Severe".
 The translation would return these results for each match option:
 <list type="bullet">
				<item><description>Strict option: map #2</description></item>
				<item><description>Loose option: map #2 followed by map #1 (map #3 is skipped because "Mild" contradicts "Severe")</description></item>
				<item><description>Alternate option: map #2 (map #1 would only be returned if map #2 did not exist)</description></item>
				<item><description>Hybrid option: map #2 (no alternate would be returned if map #2 did not exist)</description></item>
			</list>
		</para>
	</remarks>
</member><member name="P:Quippe.Coding.TranslationOptions.HintOption">
	<summary>
 Gets or sets the option that controls whether and how code hints are retrieved during translation.
 </summary>
	<remarks>
		<para>Certain coding systems, most notably ICD-9-CM, have coding hints associated with certain codes. These hints
 may indicate additional coding requirements associated with the base code, for example, that another code must be coded first.
 These enumerated values provide a means to control whether code hints are retrieved during the code translation process and
 how much detail associated with the hint should be retrieved.</para>
		<para>Each translation provider may handle code hints differently and some may not recognize the code hints option. If an
 option is set to retrieve code hints, and the translator recognizes this option, the translator should retrieve code hints associated
 with the target code when the code translation is performed. Some translators may also retrieve code hints associated with the source
 code of the requested translation.</para>
		<para>Medicomp coding data associates code hints with external vocabularies only and not with MEDCIN.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>
</member><member name="P:Quippe.Coding.TranslationOptions.SpecifierOption">
	<summary>
 Gets or sets the option that controls whether code specifiers are retrieved during translation.
 </summary>
	<remarks>
		<para>Certain coding systems may have code specifier data associated with certain codes. Code specifier data provides additional
 detail associated with the base code that should be specified to qualify the base concept or to arrive at sufficiently detailed
 code for billing. Code specifier data takes the form of one or more lists of items that may be chosen by the user to refine
 the base code. The items are usually associated with qualifying descriptions, or qualifying concepts (e.g., laterality "left").</para>
		<para>Each translation provider may handle code specifiers differently and some may not recognize the code specifiers option. If an
 option is set to retrieve code specifiers, and the translator recognizes this option, the translator should retrieve code specifiers 
 associated with the target code when the code translation is performed. Some translators may also retrieve code hints associated with the source
 code of the requested translation.</para>
		<para>Medicomp coding data associates code specifier data with external vocabularies only and not with MEDCIN.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
	<seealso cref="P:Quippe.Coding.Vocabulary.SpecifierUsage"/>
</member><member name="P:Quippe.Coding.TranslationOptions.AutoGenerationOption">
	<summary>
 Gets or sets the option that controls if maps are automatically generated when possible.
 </summary>
	<remarks>
		<para>Medicomp uses this option in its SQLite translation provider to automatically generate mappings from qualified MEDCIN concepts to SNOMED
 when such mappings do not exist in the mapping database and when a base map from the unqualified MEDCIN concept already exists. For instance,
 if a MEDCIN concept representing a disease has a "Same As" map to the equalivent concept in SNOMED, but does not have a map from the prefixed 
 MEDCIN concept (e.g., history of that disease) to SNOMED, in certain situations, the translator can automatically generate the mapping,
 provided this options is set.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.Vocabulary.IsAutoGenerationCapable"/>
</member><member name="P:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOption">
	<summary>
 Gets or sets the options that controls how input Medcin concepts are matched against maps when Medcin qualifiers such as the status qualifier,
 modifier and result qualifier are defined on the input Medcin concept and/or on the Medcin concept in the map.
 </summary>
	<remarks>Medicomp uses this option in the SQLite translation provider to determine which maps to return from the requested
 translation, but only when Medcin qualifiers are defined on the input Medcin concept or in the potential map results. The
 Medcin qualifiers affected by this option are the Medcin status qualifier, Medcin modifier and Medcin result qualifier.
 </remarks>
</member><member name="P:Quippe.Coding.TranslationOptions.UseLoosePrefixMatching">
	<summary>
 Indicates whether loose matching (or strict matching) of the MEDCIN prefix should be used when matching 
 prefix codes of the source MEDCIN entry and the candidate maps. Defaults to False or strict prefix matching.
 </summary>
	<remarks>
		<para>Medicomp uses this option in the SQLite translation provider to determine which maps to return from the requested
 translation, but only when either the input MEDCIN concept or the candidate map has a prefix code defined. The two options for
 prefix matching are the default strict matching, if this property is False, and loose matching if this property is True.</para>
		<para>The default match mode for MEDCIN prefixes is strict matching, meaning (a) an empty prefix in the source MEDCIN entry 
 will only match candidate maps that have an empty prefix code and (b) a specific non-empty prefix in the source MEDCIN entry
 will only match candidate maps that have exactly the same input prefix or an "parent" prefix of the source prefix (e.g., 
 a source prefix of "paternal history" will match the more general parent prefix of "family history" in the candidate map).
 </para>
		<para>If this property is True, a loose matching mode is used to match the prefix code of the
 source MEDCIN entry to the prefix code in the candiate maps. Under loose matching the following holds true: (a) an empty 
 prefix in the source MEDCIN entry will match all candidate maps, regardless of prefix code value and (b) a specific non-empty
 prefix in the source MEDCIN entry will only match candidate maps that have a prefix code that does not contradict the source
 prefix (i.e., candidate map has no prefix, the prefixes match exactly, or the prefix in the map is a "parent" of the source
 prefix).</para>
	</remarks>
</member><member name="P:Quippe.Coding.TranslationOptions.UseLooseCodeParameterMatching">
	<summary>
 Indicates whether loose matching (or strict matching) of the code parameters age, sex, and value should be used when matching 
 the source MEDCIN entry to candidate maps that have external target codes with code parameters (HasParameters flag is True). 
 Defaults to False or strict code parameter matching.
 </summary>
	<remarks>
		<para>Medicomp uses this option in the SQLite translation provider to determine whether maps to parameterized external codes 
 (maps dependent on age, sex and value such as to BMI codes) are returned from the requested translation, either in place of 
 (strict matching) or in addition to (loose matching) the maps to codes without parameters (base maps). The two options for
 matching maps to parameterized codes are the default strict matching, if this property is False, and loose matching if this 
 property is True.</para>
		<para>The default match mode for parameterized codes is strict matching, meaning (a) an empty or unspecified age, sex and value
 property in the source MEDCIN entry will only match candidate maps that do not depend upon age, sex and value, and (b) a specific
 set of non-empty parameters in the source MEDCIN entry will only match candidate maps that have matching parameters or parameter
 ranges.
 </para>
		<para>If this property is True, a loose matching mode is used to match the age, sex, and value properties of the
 source MEDCIN entry to the same parameters in the candiate maps. Under loose matching the following holds true: (a) an empty 
 or unspecified age, sex, and value property in the source MEDCIN entry will match all candidate maps, regardless of the parameter
 values in the maps, and (b) a specific set of non-empty parameters in the source MEDCIN entry will only match candidate base maps 
 (not parameterized) and maps with matching parameters.</para>
	</remarks>
</member><member name="P:Quippe.Coding.TranslationOptions.HasHintOption">
	<summary>
 Indicates whether a hint option is set that specifically requests code hints be retrieved.
 </summary>
	<returns>Returns True if a <see cref="T:Quippe.Coding.TranslationOptions.HintOptionEnum"/> option value other than None or Unspecified is set on the
 <see cref="P:Quippe.Coding.TranslationOptions.HintOption"/> property. Returns False if the option value is None or Unspecified.</returns>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>
</member><member name="P:Quippe.Coding.TranslationOptions.HasSpecifierOption">
	<summary>
 Indicates whether a specifier option is set that specifically requests code specifiers be retrieved.
 </summary>
	<returns>Returns True if a <see cref="T:Quippe.Coding.TranslationOptions.SpecifierOptionEnum"/> option value other than None or Unspecified is set on the 
 <see cref="P:Quippe.Coding.TranslationOptions.SpecifierOption"/> property. Returns False if the option value is None or Unspecified.</returns>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
	<seealso cref="P:Quippe.Coding.Vocabulary.SpecifierUsage"/>
</member><member name="P:Quippe.Coding.TranslationOptions.HasAutoGenerationOption">
	<summary>
 Indicates whether an auto generation option is set that specifically requests that maps be automatically generated.
 </summary>
	<returns>Returns True if an <see cref="T:Quippe.Coding.TranslationOptions.AutoGenerationOptionEnum"/> option value other than None or Unspecified is set on the
 <see cref="P:Quippe.Coding.TranslationOptions.AutoGenerationOption"/> property. Returns False if the option value is None or Unspecified.</returns>
	<seealso cref="P:Quippe.Coding.Vocabulary.IsAutoGenerationCapable"/>
</member><member name="P:Quippe.Coding.TranslationOptions.HasMedcinQualifierMatchOption">
	<summary>
 Indicates whether a Medcin qualifier match option is set.
 </summary>
	<returns>Returns True if a <see cref="T:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOptionEnum"/> value other than Unspecified is set on the <see cref="P:Quippe.Coding.TranslationOptions.MedcinQualifierMatchOption"/>
 property. Returns False if the option value is None or Unspecified.</returns>
</member><member name="T:Quippe.Coding.TranslationOptions">
	<summary>
 Class representing options that may be passed to a translation service provider to control the translation of a
 source code into the target vocabulary.
 </summary>
	<remarks>Medicomp ITranslator providers accept a parameter of this type in their Translate methods. The options
 currently control the post processing of the base translation, by indicating whether code hints and code 
 specfiers should be retrieved, how qualifiers in the source entry and candidate maps are matched, and whether the
 translator should automatically generate maps from qualified MEDCIN concepts to SNOMED, if possible.</remarks>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="F:Quippe.Coding.TranslationFilter.FilterOptionEnum.None">
	<summary>No option is specified and therefore the filter string is to be used unaltered as the regular expression.</summary>
</member><member name="F:Quippe.Coding.TranslationFilter.FilterOptionEnum.ExactMatch">
	<summary>The filter string should match the target exactly.</summary>
</member><member name="F:Quippe.Coding.TranslationFilter.FilterOptionEnum.MatchAll">
	<summary>Any target string except the empty string is a viable result. The filter string is irrelevant in
 this case.</summary>
</member><member name="F:Quippe.Coding.TranslationFilter.FilterOptionEnum.WholeWord">
	<summary>The filter string should match any word in the target exactly.</summary>
</member><member name="F:Quippe.Coding.TranslationFilter.FilterOptionEnum.StartsWith">
	<summary>The filter string should match the beginning of the target string.</summary>
</member><member name="F:Quippe.Coding.TranslationFilter.FilterOptionEnum.EndsWith">
	<summary>The filter string should match the end of the target string.</summary>
</member><member name="F:Quippe.Coding.TranslationFilter.FilterOptionEnum.WordStartsWith">
	<summary>The filter string should match the beginning of any word in the target string.</summary>
</member><member name="F:Quippe.Coding.TranslationFilter.FilterOptionEnum.WordEndsWith">
	<summary>The filter string should match the end of any word in the target string.</summary>
</member><member name="T:Quippe.Coding.TranslationFilter.FilterOptionEnum">
	<summary>
 Provides enumerated values for each option that is available when setting the string filters (i.e., regular 
 expressions).
 </summary>
</member><member name="M:Quippe.Coding.TranslationFilter.#ctor(System.Boolean)">
	<summary>
 Creates a new TranslationFilter object with an empty regular expression pattern.
 </summary>
	<param name="MatchNull">Optional parameter indicating whether the filters match when the target value is null.
 If true, then maps that have null values for the filters will also be considered a match in addition to the
 matches found in maps that have non-null values.</param>
	<remarks>This method creates a TranslationFilter object that has an empty regular expression pattern. To set
 a pattern, use the SetPattern member.</remarks>
</member><member name="M:Quippe.Coding.TranslationFilter.#ctor(System.String,Quippe.Coding.TranslationFilter.FilterOptionEnum,System.Boolean,System.Boolean)">
	<summary>
 Creates a new TranslationFilter object and sets the regular expression pattern using the specified parameters.
 </summary>
	<param name="FilterString">The string that is the basis for the filter, either a complete regular expression or
 a search string that will be formatted using a specified option.</param>
	<param name="FilterOption">A value from FilterOptionEnum that indicates how the string pattern should be
 formatted when the regular expression object is created.</param>
	<param name="IgnoreCase">Indicates whether case-insensitive matching is to be used for the specified filter.</param>
	<param name="MatchNull">Optional parameter indicating whether the filters match when the target value is null.
 If true, then maps that have null values for the filters will also be considered a match in addition to the
 matches found in maps that have non-null values.</param>
	<seealso cref="T:System.Text.RegularExpressions.Regex"/>
</member><member name="P:Quippe.Coding.TranslationFilter.MatchNull">
	<summary>
 Gets or sets an option that controls whether maps with null values in the target filter value will be
 considered matches.
 </summary>
	<remarks>If MatchNull is True, then maps that have null values in the target filter value will be considered
 matches in addition to those with values that match the filter pattern. If False, only maps with non-null 
 values that match the filter pattern will be considered matches.</remarks>
</member><member name="M:Quippe.Coding.TranslationFilter.SetPattern(System.String,Quippe.Coding.TranslationFilter.FilterOptionEnum,System.Boolean)">
	<summary>
 Sets the filter regular expression using the specified options.
 </summary>
	<param name="FilterString">The string that is the basis for the filter, either a complete regular expression or
 a search tring that will be formatted using a specified option.</param>
	<param name="FilterOption">An Enum value from FilterOptionEnum that indicates how the string pattern should be
 formatted when the regular expression object is created.</param>
	<param name="IgnoreCase">Indicates whether case-insensitive matching is to be used for the specified filter.</param>
	<remarks>Example: If you are translating MEDCIN findings to RxNorm concepts and you only want RxNorm concepts
 of the term type "SCD", you would use "SCD" for the FilterString, FilterOptionEnum.ExactMatch for the FilterOption 
 and leave IgnoreCase at the default. When the filter is passed to a translator that supports the "TermTypeFilter" 
 parameter, the filter will be used to match only RxNorm concepts that have the exact string "SCD" in the Name field of their
 associated term type.</remarks>
	<seealso cref="T:System.Text.RegularExpressions.Regex"/>
</member><member name="M:Quippe.Coding.TranslationFilter.GetPattern">
	<summary>
 Gets the filter's regular expression object.
 </summary>
	<returns>Returns the regular expression (Regex) object if the filter pattern has been set and Nothing otherwise.</returns>
</member><member name="M:Quippe.Coding.TranslationFilter.ClearPattern">
	<summary>
 Deletes the regular expression object of the filter.
 </summary>
	<remarks>After clearing the pattern, there is essentially no filter in effect and the default behavior will be
 used if the filter is applied.</remarks>
	<seealso cref="T:System.Text.RegularExpressions.Regex"/>
</member><member name="M:Quippe.Coding.TranslationFilter.HasPattern">
	<summary>
 Indicates whether a filter pattern exists (i.e., the associated filter pattern is defined).
 </summary>
	<returns>Returns True if the specified filter type has a pattern and False, otherwise, which means the default
 behavior will be used if the filter is applied.</returns>
	<seealso cref="T:System.Text.RegularExpressions.Regex"/>
</member><member name="M:Quippe.Coding.TranslationFilter.CreatePattern(System.String,Quippe.Coding.TranslationFilter.FilterOptionEnum)">
	<summary>
 Creates a regular expression pattern string by formatting the specified search filter string according to the 
 specified option.
 </summary>
	<param name="FilterString">The string that is the basis for the filter, either a complete regular expression or
 a search tring that will be formatted using a specified option.</param>
	<param name="FilterOption">An Enum value from FilterOptionEnum that indicates how the string pattern should be
 formatted when the regular expression object is created.</param>
	<returns>Returns the regular expression pattern string corresponding to the specifed filter string and option.</returns>
	<remarks>If FilterOption.None is specified, then FilterString will be unaltered. If FilterOption.MatchAll is 
 specified then the FilterString value is ignored and the regular expression is formatted to match anything.
 </remarks>
	<seealso cref="T:System.Text.RegularExpressions.Regex"/>
</member><member name="M:Quippe.Coding.TranslationFilter.CreateRegex(System.String,Quippe.Coding.TranslationFilter.FilterOptionEnum,System.Boolean)">
	<summary>
 Creates a regular expression object (Regex) using the specified search filter string formatted according to the
 specified option.
 </summary>
	<param name="FilterString">The string that is the basis for the filter, either a complete regular expression or
 a search tring that will be formatted using a specified option.</param>
	<param name="FilterOption">An Enum value from FilterOptionEnum that indicates how the string pattern should be
 formatted when the regular expression object is created.</param>
	<param name="IgnoreCase">Indicates whether case-insensitive matching is to be used for the specified filter.</param>
	<returns>Returns the regular expression object created with the filter string formatted according to the
 specified option.</returns>
</member><member name="M:Quippe.Coding.TranslationFilter.CreatePatternFromAlternatives(System.String,Quippe.Coding.TranslationFilter.FilterOptionEnum,System.Char)">
	<summary>
 Builds a regular expression pattern for matching to one of a given list of alternative strings using a matching scheme
 given by the specified FilterOption.
 </summary>
	<param name="Alternatives">List of alternative strings that are valid matches.</param>
	<param name="FilterOption">An Enum value from FilterOptionEnum that indicates how each alternative string pattern should be
 formatted to form the regular expression pattern.</param>
	<param name="Separator">A Unicode character that delimits the alternatives in the parameter, Alternatives.</param>
	<returns>Returns a regular expression pattern string of alternatives.</returns>
	<remarks><para>The regular expression is intended for use in matching a target string to one of the specified
 alternative strings using the specified matching scheme in FilterOption. If the FilterOption is MatchAll, then
 the Alternatives string is irrelevant and the pattern will match any non-empty target string. If the FilterOption
 is None, then Alternatives string will be returned with no changes. If the FilterOption is ExactMatch then a string
 matches the filter if it is an exact match to one of the alternatives. If the FilterOption is something that
 indicates a partial match, such as StartsWith, then a string will match the filter if it partially matches one of
 the alternatives (e.g., if the string starts with one of the alternatives).</para>
		<para>If the Separator parameter is not specified, the pipe character ("|") is assumed to be the delimiter.
 </para></remarks>
	<seealso cref="T:System.Text.RegularExpressions.Regex"/>
</member><member name="T:Quippe.Coding.TranslationFilter">
	<summary>
 Represents a regular expression filter that may be applied to the code mapping and source and target codes
 during code translation to limit the translation results relevant maps.
 </summary>
	<remarks><para>The filter is a essentially a regular expression that can be configured to filter the code translation
 results by a specific String regular expression pattern property as desired. You may specify the string pattern for the
 regular expression or use options to set common filter patterns on a partially specific pattern string.</para>
		<para>TranslationFilter objects may be passed as parameters to the Translate methods implemented by certain coding service
 translation providers (implementations of ITranslator) in order to filter the results of the translation. If a filter is 
 empty or unspecified, and then passed to a translator that accepts filter parameters, the
 translator should take the default action appropriate for that filter during translation.</para>
		<para></para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:System.Text.RegularExpressions.Regex"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
</member><member name="F:Quippe.Coding.SupportedTranslationTypeEnum.Unsupported">
	<summary>Translations from the source to the target vocabulary are not supported.</summary>
</member><member name="F:Quippe.Coding.SupportedTranslationTypeEnum.Forward">
	<summary>Translations from the source directly to the target vocabulary using forward mappings are supported.</summary>
</member><member name="F:Quippe.Coding.SupportedTranslationTypeEnum.Indirect">
	<summary>Translations from the source indirectly to the target vocabulary via another vocabulary are supported, and may involve a reverse mapping.</summary>
</member><member name="F:Quippe.Coding.SupportedTranslationTypeEnum.NoTranslationRequired">
	<summary>No translation is necessary, e.g., because the source and target vocabularies are identical.</summary>
</member><member name="F:Quippe.Coding.SupportedTranslationTypeEnum.Reverse">
	<summary>Translations from the source directly to the target vocabulary using reverse mappings are supported.</summary>
</member><member name="T:Quippe.Coding.SupportedTranslationTypeEnum">
	<summary>
 Represents the types of translations that may be supported by a Translator for a given source and target
 vocabulary.
 </summary>
	<remarks><para>These enumerated values are used by the translator provider to communicate the type of 
 translation that is supported for given source and target translation vocabularies.</para>
		<para>It is useful to distinguish code translations by how they relate to the underlying code mappings
 that support them. A translation from a source vocabulary to a target vocabulary is most useful when the
 underlying mappings map from the source vocabulary forward to the target vocabulary. This is referred to as
 a forward translation. However, in the absence of a forward mapping, it might be helpful to be able to
 translate backwards from one vocabulary to another. This is referred to as a reverse translation. For instance, 
 Medicomp code mappings map forward from the MEDCIN vocabulary to external vocabularies such as ICD-9-CM,
 CPT and SNOMED-CT. So a forward translation using a Medicomp supplied translator provider would supply results
 based on maps from MEDCIN to one of the supported external vocabularies, such as ICD-9-CM. In such a translation,
 the source vocabulary would be MEDCIN and the target vocabulary the desired external vocabulary (e.g., ICD-9-CM).
 However, it may be desirable to find the MEDCIN codes that are mapped to an external vocabulary code. In that
 case, specifying ICD-9-CM as the translation source vocabulary and MEDCIN as the target vocabulary would
 result in a reverse translation using the forward mappings from MEDCIN to ICD-9-CM.</para>
		<para>Mappings that are created directly from one vocabulary to another are referred to as direct mappings and 
 a translation based on a direct mapping is a direct translation. In the absence of a direct translation a 
 translation provider may support an indirect translation from the source vocabulary to the target via another 
 vocabulary. For instance, a translator may only have forward mappings from MEDCIN to external vocabularies,
 but a translation from one external vocabulary to another via the MEDCIN vocabulary may be desired. Thus if
 the translation source vocabulary was ICD-9-CM and the translation target vocabulary was SNOMED-CT and the
 translator provider only had forward mappings from MEDCIN to both ICD-9-CM and SNOMED-CT, then the translation
 could only be achieved indirectly by going from ICD-9-CM in reverse to MEDCIN and then forward to SNOMED-CT, 
 however, the mapping results might be of questionable value since the method was indirect and involved a 
 reverse mapping.
 </para></remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.ITranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates a source CodeEntry, consisting of a code in a specified source vocabulary, to mapped codes in a 
 target vocabulary, with optional parameters to perform the translation.
 </summary>
	<param name="SourceEntry">A source entry derived from CodeEntry that specifies the source CodeSet (including the source vocabulary code), the source code to be translated and related information about the code to be translated.</param>
	<param name="TargetCodeSet">The target CodeSet (including the target vocabulary code) to which the source entry will be translated.</param>
	<param name="Parameters">Optional list of parameters to control the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<remarks>
		<para>The minimum information required to perform a translation is the source vocabulary code, contained in the source CodeSet object, the source code
 to translate, and the target vocabulary code in the target CodeSet object. Additional information to control the translation may be provided by properties
 of the source CodeEntry or the target CodeSet, but may not necessarily be processed by all implementations. For instance, if the SourceEntry derives from MedcinCodeEntry, 
 then additional information such as the MEDCIN PrefixCode or StatusQualifier may be employed by the translator to limit the translation to maps from with a source 
 MEDCIN concept that is appropriately prefixed or qualified. Alternatively, if the source entry is a code in an external vocabulary, the TermType property may be used 
 to limit the translation to use only maps from the external vocabulary that has the specified term type. Not all implementations necessarily use the Version property of the
 source CodeSet to filter the translation.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, not all implementations necessarily handle the same parameters.</para></remarks>
</member><member name="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)">
	<summary>
 Determines the type of translation support provided by this translator for the given source and target code sets.
 </summary>
	<param name="SourceCodeSet">The CodeSet corresponding to the coding vocabluary containing the source code(s) that will be specified for translation.</param>
	<param name="TargetCodeSet">The CodeSet corresponding to the coding vocabulary that is the target of the translation.</param>
	<returns>Returns an enumerated value from <see cref="T:Quippe.Coding.SupportedTranslationTypeEnum"/> that indicates the type of translation
 that is supported for the specified code sets.</returns>
</member><member name="P:Quippe.Coding.ITranslator.ParameterNames">
	<summary>
 Gets a collection of the names of the parameters supported by the provider's Translation method(s).
 </summary>
	<returns>Returns a list of zero or more names of the parameters supported by the translator.</returns>
	<remarks>
		<para>A translation service provider's implementation of the <see cref="M:Quippe.Coding.ITranslator.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)"/> method takes an optional parameter, called Parameters, of
 type <see cref="T:Quippe.Coding.TranslationParameters"/>. TranslationParameters is merely a collection of parameters, each represented by a case-insensitive String key
 (i.e., parameter name) and the associated parameter value of type Object. The implementing translation provider may or may not accept 
 parameters that control the translation. If a provider does accept parameters, the provider should return the accepted parameter names
 via this function. Further, a provider that accepts parameters will retrieve parameters from the collection by the parameter name, 
 and should ignore any parameters with names that do not match the translator’s list of supported parameter names.</para>
	</remarks>
</member><member name="P:Quippe.Coding.ITranslator.SupportedVocabularies">
	<summary>
 Gets a collection of vocabulary codes of the vocabularies supported by this translator.
 </summary>
	<remarks><para>The returned collection should include all supported vocabularies, including MEDCIN and all external
 vocabularies that are the target of the underlying forward mappings from MEDCIN.</para>
		<para>A vocabulary is supported if 
 the translator can perform some translation operation with the vocabulary as source or target. This method does
 not indicate the type of support that is provided. To find the exact type of support that is offered for a given 
 source and target vocabulary, call the <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)">
	<summary>
 Gets the supported vocabulary associated with the specified vocabulary code.
 </summary>
	<param name="VocabCode">The unique code of the desired vocabulary.</param>
	<remarks>
		<para>A vocabulary is supported if 
 the translator can perform some translation operation with the vocabulary as source or target. This method does
 not indicate the type of support that is provided. To find the exact type of support that is offered for a given 
 source and target vocabulary, call the <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method.</para>
	</remarks>
</member><member name="T:Quippe.Coding.ITranslator">
	<summary>
 Defines the interface for a standard code mapping translation provider that provides simple translation from a source
 code in a source vocabulary to mapped codes in a target vocabulary.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.CodeSet"/>
	<seealso cref="T:Quippe.Coding.MapManager"/>
	<seealso cref="T:Quippe.Coding.TranslationParameters"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ICodeMappingService.SupportedVocabularies">
	<summary>
 Gets a collection of vocabulary codes of the vocabularies supported by the translators implementing the ITranslator 
 interface that are supported by this coding service instance.
 </summary>
	<returns>Returns a sorted collection of the vocabulary codes of the vocabularies supported by the translators implementing the ITranslator
 interface that are supported by this coding service instance.
 </returns>
	<remarks><para>The returned collection should include the unique codes of all supported vocabularies, including MEDCIN and all external
 vocabularies that are the target of the underlying forward mappings from MEDCIN.The collection will not have duplicate vocabularies.</para>
		<para>A vocabulary is supported if one of the supported translators implementing the IExtendedTransator interface can
 perform some translation operation with the vocabulary as source or target. This method does
 not indicate the type of support that is provided. To find the exact type of support that is offered for a given 
 source and target vocabulary, call the <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.ICodeMappingService.GetVocabulary(System.String)">
	<summary>
 Gets the vocabulary associated with the specified vocabulary code that is supported by the highest priority supported translator
 implementing the ITranslator interface.
 </summary>
	<param name="VocabCode">The unique code of the desired vocabulary.</param>
	<returns>Returns the <see cref="T:Quippe.Coding.Vocabulary"/> instance of the highest priority translator implementing the ITranslator interface
 that supports translation operations involving the specified vocabulary.</returns>
	<remarks>
		<para>A vocabulary is supported if one of the supported translators implementing the IExtendedTransator interface can
 perform some translation operation with the vocabulary as source or target. This method does
 not indicate the type of support that is provided. To find the exact type of support that is offered for a given 
 source and target vocabulary, call the <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method.</para>
		<para>A vocabulary may be supported by more than one translator and vocabulary properties may differ from one translator
 to another. The vocabulary, if supported, is obtained from the highest priority supporting translator, which would likely 
 be the translator called on the perform translation operations involving that vocabulary.</para>
	</remarks>
</member><member name="M:Quippe.Coding.ICodeMappingService.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates a source CodeEntry, consisting of a code in a specified source vocabulary, to mapped codes in a 
 target vocabulary, with optional parameters to perform the translation.
 </summary>
	<param name="SourceEntry">A source entry derived from CodeEntry that specifies the source CodeSet (including the source vocabulary code), the source code to be translated and related information about the code to be translated.</param>
	<param name="TargetCodeSet">The target CodeSet (including the target vocabulary code) to which the source entry will be translated.</param>
	<param name="Parameters">Optional list of parameters to control the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<remarks>
		<para>The minimum information required to perform a translation is the source vocabulary code, contained in the source CodeSet object, the source code
 to translate, and the target vocabulary code in the target CodeSet object. Additional information to control the translation may be provided by properties
 of the source CodeEntry or the target CodeSet, but may not necessarily be processed by all implementations. For instance, if the SourceEntry derives from <see cref="T:Quippe.Coding.MedcinCodeEntry"/>, 
 then additional information such as the MEDCIN PrefixCode or StatusQualifier may be employed by the translator to limit the translation to maps from with a source 
 MEDCIN concept that is appropriately prefixed or qualified. Alternatively, if the source entry is a code in an external vocabulary, the <see cref="P:Quippe.Coding.CodeEntry.TermType">TermType</see> property may be used 
 to limit the translation to use only maps from the external vocabulary that has the specified term type. Not all implementations necessarily use the <see cref="P:Quippe.Coding.CodeSet.Version">Version</see> property of the
 source CodeSet to filter the translation.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, not all implementations necessarily handle the same parameters.</para></remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.Prefix"/>
</member><member name="M:Quippe.Coding.ICodeMappingService.Translate(Quippe.Coding.CodeSet,System.String,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates a source code in a source vocabulary to mapped codes in a specified target vocabulary, with optional 
 parameters to perform the translation.
 </summary>
	<param name="SourceCodeSet">The source CodeSet defining the coding system vocabulary (via the vocabulary code) from which the source code is derived.</param>
	<param name="SourceCode">The code within the source code set that is to be translated.</param>
	<param name="TargetCodeSet">The target CodeSet (including the target vocabulary code) to which the source entry will be translated.</param>
	<param name="Parameters">Optional list of parameters to control the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<remarks>
		<para>The minimum information required to perform a translation is the source vocabulary code, contained in the source CodeSet object, the source code
 to translate, and the target vocabulary code in the target CodeSet object. Additional information to control the translation may be provided by properties
 of the source CodeEntry or the target CodeSet, but may not necessarily be processed by all implementations. Not all implementations necessarily use 
 the <see cref="P:Quippe.Coding.CodeSet.Version">Version</see> property of the
 source CodeSet to filter the translation.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, not all implementations necessarily handle the same parameters.</para></remarks>
</member><member name="M:Quippe.Coding.ICodeMappingService.Translate(Quippe.IPatient,Quippe.IEncounter,System.Collections.Generic.List{Quippe.IEntry},Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates the MEDCIN concepts in a patient encounter record to mapped codes in the target vocabulary, with
 optional parameters to perform the translation.
 </summary>
	<param name="Patient">The patient record.</param>
	<param name="Encounter">The patient encounter record.</param>
	<param name="Entries">The list of entry records from the patient encounter that are to be translated.</param>
	<param name="TargetCodeSet">The target CodeSet (i.e., vocabulary and version) to which the source entry will be translated.</param>
	<param name="Parameters">Optional list of parameters to control the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<remarks>
		<para>The minimum information required to perform each translation is the source vocabulary code, in this case MEDCIN, the source MEDCIN code
 to translate, specified in the entry record, and the target vocabulary code, which is determined from the collection of standard vocabularies. 
 Additional information to control the translation may be provided by properties
 of the patient, encounter and entry records, but may not necessarily be processed by all implementations.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, not all implementations necessarily handle the same parameters.</para></remarks>
</member><member name="M:Quippe.Coding.ICodeMappingService.TranslateMedcinToAll(System.Int32,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates a specified MEDCIN ID to the mapped codes in all the standard vocabularies, passing the specified
 parameters to control the translation.
 </summary>
	<param name="MedcinId">The MEDCIN ID of the source concept to translate.</param>
	<param name="Parameters">Optional list of parameters to control the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<remarks>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, not all implementations necessarily handle the same parameters.</para>
	</remarks>
</member><member name="M:Quippe.Coding.ICodeMappingService.TranslateMedcinToAll(Quippe.Coding.MedcinCodeEntry,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates a specified MEDCIN ID to the mapped codes in all the standard vocabularies, passing the specified
 parameters to control the translation.
 </summary>
	<param name="SourceEntry">The MedcinSourceEntry defining the MEDCIN finding to translate.</param>
	<param name="Parameters">Optional list of parameters to control the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<remarks>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, not all implementations necessarily handle the same parameters.</para>
	</remarks>
</member><member name="M:Quippe.Coding.ICodeMappingService.TranslateMedcinToAll(Quippe.IPatient,Quippe.IEncounter,System.Collections.Generic.List{Quippe.IEntry},Quippe.Coding.TranslationParameters)">
	<summary>
 Translates the MEDCIN concepts in a patient encounter record to mapped codes in all the standard vocabularies, 
 passing the specified parameters to control the translation.
 </summary>
	<param name="Patient">The patient record.</param>
	<param name="Encounter">The patient encounter record.</param>
	<param name="Entries">The list of entry records from the patient encounter that are to be translated.</param>
	<param name="Parameters">Optional list of parameters to control the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<remarks>
		<para>The minimum information required to perform each translation is the source vocabulary code, in this case MEDCIN, the source MEDCIN code
 to translate, specified in the entry record, and the target vocabulary code, which is determined from the collection of standard vocabularies. 
 Additional information to control the translation may be provided by properties
 of the patient, encounter and entry records, but may not necessarily be processed by all implementations.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, not all implementations necessarily handle the same parameters.</para>
	</remarks>
</member><member name="M:Quippe.Coding.ICodeMappingService.TranslateMedcinToAll(Quippe.IPatient,Quippe.IEncounter,Quippe.IEntry,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates the MEDCIN concept in a single patient encounter record to mapped codes in all the standard vocabularies, 
 passing the specified parameters to control the translation.
 </summary>
	<param name="Patient">The patient record.</param>
	<param name="Encounter">The patient encounter record.</param>
	<param name="NoteEntry">The entry record from the patient encounter to be translated.</param>
	<param name="Parameters">Optional list of parameters to control the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<remarks>
		<para>The minimum information required to perform each translation is the source vocabulary code, in this case MEDCIN, the source MEDCIN code
 to translate, specified in the entry record, and the target vocabulary code, which is determined from the collection of standard vocabularies. 
 Additional information to control the translation may be provided by properties
 of the patient, encounter and entry records, but may not necessarily be processed by all implementations.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, not all implementations necessarily handle the same parameters.</para>
	</remarks>
</member><member name="P:Quippe.Coding.ICodeMappingService.HasTranslators">
	<summary>
 Indicates whether the service has any translator providers available (loaded).
 </summary>
</member><member name="P:Quippe.Coding.ICodeMappingService.TranslatorTypes">
	<summary>
 Gets a collection of the Type values of the available translator providers.
 </summary>
</member><member name="P:Quippe.Coding.ICodeMappingService.TranslatorEntries">
	<summary>
 Gets the list of TranslatorEntry objects, one for each available and loaded translator provider.
 </summary>
</member><member name="M:Quippe.Coding.ICodeMappingService.GetTranslator(System.Type)">
	<summary>
 Gets the available translator provider that has the specified Type, if any.
 </summary>
	<param name="aType">The Type of the available translator provider to get.</param>
	<returns>Returns the translator as an ITranslator, if found, or Nothing if translator with that Type is
 available and was successfully loaded.</returns>
</member><member name="M:Quippe.Coding.ICodeMappingService.GetTranslator(System.String,System.String)">
	<summary>
 Gets the highest priority ITranslator provider that supports translation from codes in the specified source vocabulary to the specified target vocabulary.
 </summary>
	<param name="SourceVocabCode">The unique String code of the source coding system (or medical terminology) vocabulary the translator must support.</param>
	<param name="TargetVocabCode">The unique String code of the target coding system (or medical terminology) vocabulary the translator must support.</param>
	<returns>Returns the highest priority ITranslator providers that supports the specified source and target vocabularies or Nothing if no translator is found.</returns>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="T:Quippe.Coding.ICodeMappingService">
	<summary>
 Defines the interface for a standard code mapping service that provides simple translation from one CodeSet to
 another.
 </summary>
</member><member name="M:Quippe.Coding.ICodeDataProvider.GetCodeEntry(System.String,System.String)">
	<summary>
 Gets the code entry data for a specific code in a coding system vocabulary.
 </summary>
	<param name="VocabCode">The unique string identifier of the vocabulary.</param>
	<param name="Code">The unique string identifier of the code.</param>
</member><member name="M:Quippe.Coding.ICodeDataProvider.GetSpecifierType(System.Int32)">
	<summary>
 Gets the code specifier type having the specified TypeId. 
 </summary>
	<param name="TypeId">The unique Integer identifier of the desired code specifier type.</param>
</member><member name="M:Quippe.Coding.ICodeDataProvider.GetSpecifierItem(System.Int32)">
	<summary>
 Gets the code specifier item having the specified ItemId. 
 </summary>
	<param name="ItemId">The unique Integer identifier of the desired code specifier item.</param>
</member><member name="M:Quippe.Coding.ICodeDataProvider.GetSpecifierList(System.Int32)">
	<summary>
 Gets the specified code specifier list, including its constituent code specifier items. 
 </summary>
	<param name="ListId">The unique Integer identifier of the desired code specifier list.</param>
</member><member name="T:Quippe.Coding.ICodeDataProvider">
	<summary>
 Defines the interface for classes that provide access to data contained in 
 code entries in the MEDCIN vocabulary or external coding vocabularies.
 </summary>
	<remarks>
		<para>Does not provide access to mappings between vocabularies.</para>
	</remarks>
</member><member name="P:Quippe.Coding.CodeMappingService.SupportedVocabularies">
	<summary>
 Gets a collection of vocabulary codes of the vocabularies supported by the translators that are supported by this coding service instance.
 </summary>
	<returns>Returns a sorted collection of the vocabulary codes of the vocabularies supported by the translators that are supported by this coding service instance.
 </returns>
	<remarks><para>The returned collection includes the unique codes of all supported vocabularies, including MEDCIN and all external
 vocabularies that are the target of the underlying forward mappings from MEDCIN.The collection will not have duplicate vocabularies.</para>
		<para>A vocabulary is supported if one of the supported translators implementing the ITransator interface can
 perform some translation operation with the vocabulary as source or target. This method does
 not indicate the type of support that is provided. To find the exact type of support that is offered for a given 
 source and target vocabulary, call the <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeMappingService.GetVocabulary(System.String)">
	<summary>
 Gets the vocabulary associated with the specified vocabulary code that is supported by the highest priority supported translator.
 </summary>
	<param name="VocabCode">The unique code of the desired vocabulary.</param>
	<returns>Returns the <see cref="T:Quippe.Coding.Vocabulary"/> instance of the highest priority translator that supports translation operations
 involving the specified vocabulary.</returns>
	<remarks>
		<para>A vocabulary is supported if one of the supported translators implementing the ITransator interface can
 perform some translation operation with the vocabulary as source or target. This method does
 not indicate the type of support that is provided. To find the exact type of support that is offered for a given 
 source and target vocabulary, call the <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method.</para>
		<para>A vocabulary may be supported by more than one translator and vocabulary properties may differ from one translator
 to another. The vocabulary, if supported, is obtained from the highest priority supporting translator, which would likely 
 be the translator called on the perform translation operations involving that vocabulary.</para>
	</remarks>
</member><member name="M:Quippe.Coding.CodeMappingService.Translate(Quippe.Coding.CodeEntry,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates a source CodeEntry, consisting of a code in a specified source vocabulary, to mapped codes in a 
 target vocabulary, using mappings from the highest priority ITranslator provider that supports the source 
 and target CodeSets, with optional parameters to pass on to the provider.
 </summary>
	<param name="SourceEntry">A source entry derived from CodeEntry that specifies the source CodeSet (including the source vocabulary code), 
 the source code to be translated and related information about the code to be translated.</param>
	<param name="TargetCodeSet">The target CodeSet (including the target vocabulary code) to which the source entry will be translated.</param>
	<param name="Parameters">Optional list of parameters to be passed to the ITranslator provider that will be used to perform the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the either the SourceEntry or the TargetCodeSet parameter is Nothing.</exception>
	<remarks>
		<para>The code mapping service maintains a collection of available code mapping translators that implement the <see cref="T:Quippe.Coding.ITranslator"/> interface. The translators are
 loaded from the configured ITranslator providers managed by the service manager. The highest priority available translator that supports the translation is
 used. The <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method is used to determine which translators support the requested translation.</para>
		<para>The minimum information required to perform a translation is the source vocabulary code, contained in the source CodeSet object, the source code
 to translate, and the target vocabulary code in the target CodeSet object. Additional information to control the translation may be provided by properties
 of the source CodeEntry or the target CodeSet, but may not necessarily be processed by all translators. For instance, if the SourceEntry derives from <see cref="T:Quippe.Coding.MedcinCodeEntry"/>, 
 then additional information such as the MEDCIN PrefixCode or StatusQualifier may be employed by the translator to limit the translation to maps from with a source 
 MEDCIN concept that is appropriately prefixed or qualified. Alternatively, if the source entry is a code in an external vocabulary, the <see cref="P:Quippe.Coding.CodeEntry.TermType">TermType</see> property may be used 
 to limit the translation to use only maps from the external vocabulary that has the specified term type. Not all translators necessarily use the <see cref="P:Quippe.Coding.CodeSet.Version">Version</see>
 property of the
 source CodeSet to filter the translation. Refer to the documentation for the specific ITranslator provider to determine which additional properties may be used to
 limit the translation results.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, these parameters are passed through to the ITranslator provider that performs the translation. Not all ITranslator providers necessarily handle 
 the same parameters. A translator should ignore any
 parameters that are not supported. The method <see cref="P:Quippe.Coding.ITranslator.ParameterNames"/> may be used to return the names of parameters supported by a translator. Refer to the
 documentation of a specific translator for details regarding the parameters supported. Some translators may support translation filters, <see cref="T:Quippe.Coding.TranslationFilter"/>,
 and translation options provided by the <see cref="T:Quippe.Coding.TranslationOptions"/> class.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.Prefix"/>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="M:Quippe.Coding.CodeMappingService.Translate(Quippe.Coding.CodeSet,System.String,Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates a specified code in a specified source vocabulary to mapped codes in a specified target vocabulary,
 using mappings from the highest priority ITranslator provider that supports the source and target CodeSets, with
 optional parameters to pass on to the provider.
 </summary>
	<param name="SourceCodeSet">The source CodeSet defining the coding system vocabulary (via the vocabulary code) from which the source code is derived.</param>
	<param name="SourceCode">The code within the source code set that is to be translated.</param>
	<param name="TargetCodeSet">The target CodeSet (including the target vocabulary code) to which the source entry will be translated.</param>
	<param name="Parameters">Optional list of parameters to be passed to the ITranslator provider used to perform the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the either the SourceCodeSet or the TargetCodeSet parameter is Nothing.</exception>
	<remarks><para>The code mapping service maintains a collection of available code mapping translators that implement the <see cref="T:Quippe.Coding.ITranslator"/> interface. The translators are
 loaded from the configured ITranslator providers managed by the service manager. The highest priority available translator that supports the translation is
 used. The <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method is used to determine which translators support the requested translation.</para>
		<para>The minimum information required to perform a translation is the source vocabulary code, contained in the source CodeSet object, the source code
 to translate, and the target vocabulary code in the target CodeSet object. Additional information to control the translation may be provided by properties
 of the source CodeSet, but may not necessarily be processed by all translators. Not all translators necessarily use the <see cref="P:Quippe.Coding.CodeSet.Version">Version</see> property of the
 source CodeSet to filter the translation. Refer to the documentation for the specific ITranslator provider to determine which additional properties may be used to
 limit the translation results.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, these parameters are passed through to the ITranslator provider that performs the translation. Not all ITranslator providers necessarily handle 
 the same parameters. A translator should ignore any
 parameters that are not supported. The method <see cref="P:Quippe.Coding.ITranslator.ParameterNames"/> may be used to return the names of parameters supported by a translator. Refer to the
 documentation of a specific translator for details regarding the parameters supported. Some translators may support translation filters, <see cref="T:Quippe.Coding.TranslationFilter"/>,
 and translation options provided by the <see cref="T:Quippe.Coding.TranslationOptions"/> class.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="M:Quippe.Coding.CodeMappingService.Translate(Quippe.IPatient,Quippe.IEncounter,System.Collections.Generic.List{Quippe.IEntry},Quippe.Coding.CodeSet,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates the MEDCIN concepts in a patient encounter record to mapped codes in the target vocabulary, using
 mappings from the the highest priority ITranslator provider that supports the MEDCIN source and specified 
 target CodeSets, with optional parameters to pass on to the provider.
 </summary>
	<param name="Patient">The patient record.</param>
	<param name="Encounter">The patient encounter record.</param>
	<param name="Entries">The list of entry records from the patient encounter that are to be translated.</param>
	<param name="TargetCodeSet">The target CodeSet (i.e., vocabulary and version) to which the source entry will be translated.</param>
	<param name="Parameters">Optional list of parameters to be passed to the ITranslator provider used to perform the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the Entries parameter is Nothing.</exception>
	<exception cref="T:Quippe.Coding.CodingException">Thrown if the no code translator was found that supports translation between MEDCIN and the target vocabulary.</exception>
	<remarks>
		<para>The code mapping service maintains a collection of available code mapping translators that implement the <see cref="T:Quippe.Coding.ITranslator"/> interface. The translators are
 loaded from the configured ITranslator providers managed by the service manager. The highest priority available translator that supports the translation is
 used. The <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method is used to determine which translators support the requested translation.</para>
		<para>The minimum information required to perform each translation is the source vocabulary code, in this case MEDCIN, the source MEDCIN code
 to translate, specified in the entry record, and the target vocabulary code, which is determined from the collection of standard vocabularies. 
 Additional information to control the translation may be provided by properties
 of the patient, encounter and entry records, but may not necessarily be processed by all translators. The age of the patient at the time of the encounter
 is determined from the patient and encounter records. The sex of the patient is determined from the patient record. The age and sex, as well as
 the prefix, result code, and the test/measurement value and units are passed to the translator for use in determining target codes that depend on 
 test/measurement parameters. The following properties of the entry record are used to construct the MedcinCodeEntry used as the source input to
 the translation: Medcin ID, Prefix, Status (Medcin status qualifier), Modifier, ResultCode, Specifier (Medcin specification string), Age,
 Sex, and test measurement Value. Prefix, Status, Modifier, ResultCode, Age, Sex and Value are also passed as parameters. Refer to the documentation for the 
 specific ITranslator provider to determine which additional properties are used to limit the translation results.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, these parameters are passed through to the ITranslator provider that performs the translation. Not all ITranslator providers necessarily handle 
 the same parameters. A translator should ignore any
 parameters that are not supported. The method <see cref="P:Quippe.Coding.ITranslator.ParameterNames"/> may be used to return the names of parameters supported by a translator. Refer to the
 documentation of a specific translator for details regarding the parameters supported. Some translators may support translation filters, <see cref="T:Quippe.Coding.TranslationFilter"/>,
 and translation options provided by the <see cref="T:Quippe.Coding.TranslationOptions"/> class.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="M:Quippe.Coding.CodeMappingService.TranslateMedcinToAll(System.Int32,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates a specified MEDCIN ID to the mapped codes in all the standard vocabularies, using the highest 
 priority ITranslator provider for each translation to a unique target vocabulary, and passing the specified
 parameters on to the translator.
 </summary>
	<param name="MedcinId">The MEDCIN ID of the source concept to translate.</param>
	<param name="Parameters">Optional list of parameters to be passed to each ITranslator provider used to perform
 the translations.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<remarks>
		<para>An attempt will be made to translate the MEDCIN concept indicated by the MEDCIN ID once for each standard vocabulary. </para>
		<para>The code mapping service maintains a collection of available code mapping translators that implement the <see cref="T:Quippe.Coding.ITranslator"/> interface. The translators are
 loaded from the configured ITranslator providers managed by the service manager. The highest priority translator supporting the translation from MEDCIN to the target vocabulary
 will be used in each translation to a distinct target vocabulary. The <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method is used to determine which translators support the requested translation.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, these parameters are passed through to the ITranslator provider that performs the translation. Not all ITranslator providers necessarily handle 
 the same parameters. A translator should ignore any
 parameters that are not supported. The method <see cref="P:Quippe.Coding.ITranslator.ParameterNames"/> may be used to return the names of parameters supported by a translator. Refer to the
 documentation of a specific translation for details regarding the parameters supported. Some translators may support translation filters, <see cref="T:Quippe.Coding.TranslationFilter"/>,
 and translation options provided by the <see cref="T:Quippe.Coding.TranslationOptions"/> class.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="M:Quippe.Coding.CodeMappingService.TranslateMedcinToAll(Quippe.Coding.MedcinCodeEntry,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates a specified MEDCIN ID to the mapped codes in all the standard vocabularies, using the highest 
 priority ITranslator provider for each translation to a unique target vocabulary, and passing the specified
 parameters on to the translator.
 </summary>
	<param name="SourceEntry">The MedcinCodeEntry defining the MEDCIN finding to translate.</param>
	<param name="Parameters">Optional list of parameters to be passed to each ITranslator provider used to perform
 the translations.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<remarks>
		<para>An attempt will be made to translate the MEDCIN concept indicated by the source code entry once for each standard vocabulary. </para>
		<para>The code mapping service maintains a collection of available code mapping translators that implement the <see cref="T:Quippe.Coding.ITranslator"/> interface. The translators are
 loaded from the configured ITranslator providers managed by the service manager. The highest priority translator supporting the translation from MEDCIN to the target vocabulary
 will be used in each translation to a distinct target vocabulary. The <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method is used to determine which translators support the requested translation.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, these parameters are passed through to the ITranslator provider that performs the translation. Not all ITranslator providers necessarily handle 
 the same parameters. A translator should ignore any
 parameters that are not supported. The method <see cref="P:Quippe.Coding.ITranslator.ParameterNames"/> may be used to return the names of parameters supported by a translator. Refer to the
 documentation of a specific translation for details regarding the parameters supported. Some translators may support translation filters, <see cref="T:Quippe.Coding.TranslationFilter"/>,
 and translation options provided by the <see cref="T:Quippe.Coding.TranslationOptions"/> class.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="M:Quippe.Coding.CodeMappingService.TranslateMedcinToAll(Quippe.IPatient,Quippe.IEncounter,System.Collections.Generic.List{Quippe.IEntry},Quippe.Coding.TranslationParameters)">
	<summary>
 Translates the MEDCIN concepts in a patient encounter record to mapped codes in all the standard vocabularies, 
 using the highest priority ITranslator provider for each translation to a unique target vocabulary, and passing the specified
 parameters on to the translator.
 </summary>
	<param name="Patient">The patient record.</param>
	<param name="Encounter">The patient encounter record.</param>
	<param name="Entries">The list of entry records from the patient encounter that are to be translated.</param>
	<param name="Parameters">Optional list of parameters to be passed to the ITranslator provider used to perform the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the Entries parameter is Nothing.</exception>
	<remarks>
		<para>The code mapping service maintains a collection of available code mapping translators that implement the <see cref="T:Quippe.Coding.ITranslator"/> interface. The translators are
 loaded from the configured ITranslator providers managed by the service manager. The highest priority available translator that supports the translation is
 used. The <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method is used to determine which translators support the requested translation.</para>
		<para>The minimum information required to perform each translation is the source vocabulary code, in this case MEDCIN, the source MEDCIN code
 to translate, specified in the entry record, and the target vocabulary code, which is determined from the collection of standard vocabularies. 
 Additional information to control the translation may be provided by properties
 of the patient, encounter and entry records, but may not necessarily be processed by all translators. The age of the patient at the time of the encounter
 is determined from the patient and encounter records. The sex of the patient is determined from the patient record. The age and sex, as well as
 the prefix, result code, and the test/measurement value and units are passed to the translator for use in determining target codes that depend on 
 test/measurement parameters.  Refer to the documentation for the specific ITranslator
 provider to determine which additional properties are used to limit the translation results.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, these parameters are passed through to the ITranslator provider that performs the translation. Not all ITranslator providers necessarily handle 
 the same parameters. A translator should ignore any
 parameters that are not supported. A translator should ignore any parameters that are not supported. The method <see cref="P:Quippe.Coding.ITranslator.ParameterNames"/> may be used to 
 return the names of parameters supported by a translator. Refer to the
 documentation of a specific translation for details regarding the parameters supported. Some translators may support translation filters, <see cref="T:Quippe.Coding.TranslationFilter"/>,
 and translation options provided by the <see cref="T:Quippe.Coding.TranslationOptions"/> class.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="M:Quippe.Coding.CodeMappingService.TranslateMedcinToAll(Quippe.IPatient,Quippe.IEncounter,Quippe.IEntry,Quippe.Coding.TranslationParameters)">
	<summary>
 Translates the MEDCIN concept in a single patient encounter record to mapped codes in all the standard vocabularies, 
 using the highest priority ITranslator provider for each translation to a unique target vocabulary, and passing the specified
 parameters on to the translator..
 </summary>
	<param name="Patient">The patient record.</param>
	<param name="Encounter">The patient encounter record.</param>
	<param name="NoteEntry">The entry record from the patient encounter to be translated.</param>
	<param name="Parameters">Optional list of parameters to be passed to the ITranslator provider used to perform the translation.</param>
	<returns>Returns a MapManager object containing zero or more mapping records resulting from the translation.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if the NoteEntry parameter is Nothing.</exception>
	<remarks>
		<para>The code mapping service maintains a collection of available code mapping translators that implement the <see cref="T:Quippe.Coding.ITranslator"/> interface. The translators are
 loaded from the configured ITranslator providers managed by the service manager. The highest priority available translator that supports the translation is
 used. The <see cref="M:Quippe.Coding.ITranslator.GetTranslationSupport(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)"/> method is used to determine which translators support the requested translation.</para>
		<para>The minimum information required to perform each translation is the source vocabulary code, in this case MEDCIN, the source MEDCIN code
 to translate, specified in the entry record, and the target vocabulary code, which is determined from the collection of standard vocabularies. 
 Additional information to control the translation may be provided by properties
 of the patient, encounter and entry records, but may not necessarily be processed by all translators. The age of the patient at the time of the encounter
 is determined from the patient and encounter records. The sex of the patient is determined from the patient record. The age and sex, as well as
 the prefix, result code, and the test/measurement value and units are passed to the translator for use in determining target codes that depend on 
 test/measurement parameters. The following properties of the entry record are used to construct the MedcinCodeEntry used as the source input to
 the translation: Medcin ID, Prefix, Status (Medcin status qualifier), Modifier, ResultCode, Specifier (Medcin specification string), Age,
 Sex, and test measurement Value. Prefix, Status, Modifier, ResultCode, Age, Sex and Value are also passed as parameters. Refer to the documentation for the specific ITranslator
 provider to determine which additional properties are used to limit the translation results.</para>
		<para>Additional parameters to control the translation may be specified in the Parameters parameter, 
 however, these parameters are passed through to the ITranslator provider that performs the translation. Not all ITranslator providers necessarily handle 
 the same parameters. A translator should ignore any parameters that are not supported. The method <see cref="P:Quippe.Coding.ITranslator.ParameterNames"/> may be used to 
 return the names of parameters supported by a translator. Refer to the documentation of a specific translation for details regarding the parameters supported. 
 Some translators may support translation filters, <see cref="T:Quippe.Coding.TranslationFilter"/>,
 and translation options provided by the <see cref="T:Quippe.Coding.TranslationOptions"/> class.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="P:Quippe.Coding.CodeMappingService.HasTranslators">
	<summary>
 Indicates whether the service has any translator providers available (loaded).
 </summary>
</member><member name="P:Quippe.Coding.CodeMappingService.TranslatorTypes">
	<summary>
 Gets a collection of the Type values of the available translator providers.
 </summary>
</member><member name="P:Quippe.Coding.CodeMappingService.TranslatorEntries">
	<summary>
 Gets the list of TranslatorEntry objects, one for each available and loaded translator provider.
 </summary>
</member><member name="M:Quippe.Coding.CodeMappingService.GetTranslator(System.Type)">
	<summary>
 Gets the available translator provider that has the specified Type, if any.
 </summary>
	<param name="aType">The Type of the available translator provider to get.</param>
	<returns>Returns the translator as an ITranslator, if found, or Nothing if translator with that Type is
 available and was successfully loaded.</returns>
</member><member name="M:Quippe.Coding.CodeMappingService.GetTranslator(System.String,System.String)">
	<summary>
 Gets the highest priority ITranslator provider that supports translation from codes in the specified source vocabulary to the specified target vocabulary.
 </summary>
	<param name="SourceVocabCode">The unique String code of the source coding system (or medical terminology) vocabulary the translator must support.</param>
	<param name="TargetVocabCode">The unique String code of the target coding system (or medical terminology) vocabulary the translator must support.</param>
	<returns>Returns the highest priority ITranslator providers that supports the specified source and target vocabularies or Nothing if no translator is found.</returns>
	<remarks>
		<para>The priority ranking is honored by virtue of the order in which translators are sorted in the Translator collection. If the priority of 
 translators are equal, the translators are ordered according to the order the provider was entered in the configuration settings.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="M:Quippe.Coding.CodeMappingService.GetCodeEntry(System.String,System.String)">
	<summary>
 Gets the code entry data for a specific code in a coding system vocabulary from the highest priority 
 translator that implements the <see cref="T:Quippe.Coding.ICodeDataProvider"/> interface and that also returns a 
 non-empty code entry.
 </summary>
	<param name="VocabCode">The unique string identifier of the vocabulary.</param>
	<param name="Code">The unique string identifier of the code.</param>
	<returns>Returns an instance of a derived class of <see cref="T:Quippe.Coding.CodeEntry"/> associated with the specific
 code, or Nothing if the code does not exist in the coding service database. If the input code 
 is in the MEDCIN vocabulary ("medcin" vocabulary code) the return value will be an instance 
 of <see cref="T:Quippe.Coding.MedcinCodeEntry"/>, otherwise, its an instance of <see cref="T:Quippe.Coding.ExternalCodeEntry"/>.</returns>
	<remarks><para>Code entry data includes only the limited set of properties and data associated
 with codes in the coding service database. This does not include mapping entries, but does 
 include textual code hints and code specifier lists.</para></remarks>
</member><member name="M:Quippe.Coding.CodeMappingService.GetSpecifierType(System.Int32)">
	<summary>
 Gets the code specifier type having the specified TypeId from the highest 
 priority translator that implements the <see cref="T:Quippe.Coding.ICodeDataProvider"/> interface and that also returns
 a non-empty type. 
 </summary>
	<param name="TypeId">The unique Integer identifier of the desired code specifier type.</param>
	<returns>Returns an ICodeSpecifierType reference to the type corresponding to the associated TypeId
 parameter. Returns the first such item found from the highest priority translator that implements the 
 <see cref="T:Quippe.Coding.ICodeDataProvider"/> interface or returns Nothing otherwise.</returns>
	<remarks></remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
</member><member name="M:Quippe.Coding.CodeMappingService.GetSpecifierItem(System.Int32)">
	<summary>
 Gets the code specifier item having the specified ItemId from the highest 
 priority translator that implements the <see cref="T:Quippe.Coding.ICodeDataProvider"/> interface and that also returns
 a non-empty item. 
 </summary>
	<param name="ItemId">The unique Integer identifier of the desired code specifier item.</param>
	<returns>Returns an ICodeSpecifierItem reference to the item corresponding to the associated ItemId
 parameter. Returns the first such item found from the highest priority translator that implements the 
 <see cref="T:Quippe.Coding.ICodeDataProvider"/> interface or returns Nothing otherwise.</returns>
	<remarks></remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
</member><member name="M:Quippe.Coding.CodeMappingService.GetSpecifierList(System.Int32)">
	<summary>
 Gets the specified code specifier list, including its constituent code specifier items, from the highest 
 priority translator that implements the <see cref="T:Quippe.Coding.ICodeDataProvider"/> interface and that also returns
 a non-empty list. 
 </summary>
	<param name="ListId">The unique Integer identifier of the desired code specifier list.</param>
	<returns>Returns an ICodeSpecifierList reference to the list corresponding to the associated ListId
 parameter. Returns the first such list found from the highest priority translator that implements the 
 <see cref="T:Quippe.Coding.ICodeDataProvider"/> interface or returns Nothing  otherwise.</returns>
	<remarks></remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
</member><member name="P:Quippe.Coding.CodeMappingService.Translators">
	<summary>
 Gets List of available translators, loading translators if necessary.
 </summary>
	<remarks>
		<para>The translators are ordered by priority, highest priority first. If priorities are equal, the translators are
 ordered according to the order the provider was entered in the configuration settings.</para>
	</remarks>
</member><member name="M:Quippe.Coding.CodeMappingService.AddTranslatorParameters(Quippe.Coding.ITranslator,Quippe.IEntry,System.Int32,System.String,System.DateTime,Quippe.Coding.TranslationParameters)">
	<summary>
 Adds parameters to the specified parameter collection from the entry record, age, sex, and encounter date parameters, provided
 the parameters are supported by the specified translator.
 </summary>
	<param name="Translator">The translator for which parameters are to be collected.</param>
	<param name="NoteEntry">A note entry record, from which parameters such as Result, Unit, and encounter Date are obtained.</param>
	<param name="Age">The age of the patient in years.</param>
	<param name="Sex">The sex of the patient, either "M" for male, "F" for female, or "U" for unspecified.</param>
	<param name="EncounterDate">The date of the patient encounter.</param>
	<param name="Parameters">The collection of parameters.</param>
	<remarks><para>This method overwrites values for any existing parameters in the parameter collection.</para></remarks>
</member><member name="M:Quippe.Coding.CodeMappingService.GetParametersFromPatientEncounter(Quippe.IPatient,Quippe.IEncounter,System.Int32@,System.String@,System.DateTime@)">
	<summary>
 Gets the Sex, Age, and EncounterDate parameters, if possible, from the specified Patient and Encounter records.
 </summary>
	<param name="Patient">The Patient record from which Age and Sex are determined.</param>
	<param name="Encounter">The encounter record from which EncounterDate is determined.</param>
	<param name="Age">The age of the patient, in years, determined from the Patient record. The value is 0 if the Patient parameter is
 Nothing or if the age is not specified in the record.</param>
	<param name="Sex">A string value indicating the sex of the patient, determined from the Patient record Either "M" if the patient is male, "F" if
 the patient is female, or "U" if the Patient parameter is Nothing or if the sex is unspecified in the record.</param>
	<param name="EncounterDate">The date of the encounter as determined from the Encounter record. The value is Nothing if the
 Encounter parameter is Nothing or the date cannot be determined.</param>
	<remarks></remarks>
</member><member name="M:Quippe.Coding.CodeMappingService.LoadTranslators">
	<summary>
 Loads all available ITranslator providers with available attribute information and stores a
 TranslatorEntry for each one in the collection of translators.
 </summary>
</member><member name="T:Quippe.Coding.CodeMappingService">
	<summary>
 Class representing a basic extended code mapping service that loads available ITranslator providers and uses the highest priority
 translator to "translate" (or provide available mappings) from a source CodeEntry object to a target CodeSet with optional 
 parameters to control the translation.
 </summary>
	<remarks>
		<para>Also translates a list of entry records from a patient encounter to external codes as given by a target CodeSet. As an
 extended code mapping service, this class also provides a method to translate a Medcin ID to all standard CodeSets using the
 highest priority translators for each target CodeSet.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSet"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.ICodeMappingService"/>
	<seealso cref="T:Quippe.Coding.TranslatorAttribute"/>
</member><member name="P:Quippe.Coding.My.Resources.Resources.ResourceManager">
	<summary>
  Returns the cached ResourceManager instance used by this class.
</summary>
</member><member name="P:Quippe.Coding.My.Resources.Resources.Culture">
	<summary>
  Overrides the current thread's CurrentUICulture property for all
  resource lookups using this strongly typed resource class.
</summary>
</member><member name="T:Quippe.Coding.My.Resources.Resources">
	<summary>
  A strongly-typed resource class, for looking up localized strings, etc.
</summary>
</member><member name="F:Quippe.Coding.MapManager.ContentType.All">
	<summary>Indicates that all maps are of interest in the order they were added to the manager.</summary>
</member><member name="F:Quippe.Coding.MapManager.ContentType.Limited">
	<summary>Indicates that the complete set of maps should be filtered to exclude those in secondary groups or those with low value code relationships (e.g., "Contains") and that the resulting maps should be sorted.</summary>
</member><member name="F:Quippe.Coding.MapManager.ContentType.First">
	<summary>Indicates that the map entries in the first map expression in each code set are of interest and that the resulting maps should be sorted.</summary>
</member><member name="F:Quippe.Coding.MapManager.ContentType.AllSorted">
	<summary>Indicates all maps are of interest, but in sorted order.</summary>
</member><member name="T:Quippe.Coding.MapManager.ContentType">
	<summary>
 Provides enumerated values for each way in which the map manager supports filtering the maps or map entries.
 </summary>
	<remarks></remarks>
</member><member name="M:Quippe.Coding.MapManager.#ctor">
	<summary>
 Creates a new instance of MapManager with an empty collection of mapping records.
 </summary>
	<seealso cref="T:Quippe.Coding.MapEntry"/>
</member><member name="P:Quippe.Coding.MapManager.Entries">
	<summary>
 Gets the managed mapping records as a MapEntryList instance.
 </summary>
	<seealso cref="T:Quippe.Coding.MapEntry"/>
</member><member name="P:Quippe.Coding.MapManager.SourceHasQualifiedMaps">
	<summary>
 Gets or sets a property indicating whether the unqualified MEDCIN concept that is the source of the translation has any maps 
 that are qualified by result code.
 </summary>
	<value></value>
	<returns>Returns True if the source MEDCIN concept has associated maps qualified by result code and False otherwise or if unknown.</returns>
	<remarks>This property may be used to indicate whether a MEDCIN translation source should be treated as potentially qualified
 by result code when considering the entire body of mappings for that entry.</remarks>
</member><member name="P:Quippe.Coding.MapManager.Entries(Quippe.Coding.MapManager.ContentType)">
	<summary>
 Gets a possibly filtered collection of mapping records as a MapEntryList instance.
 </summary>
	<param name="DesiredContent">A ContentType value that indicates how the mapping records should be filtered.</param>
	<remarks><para>Returns a MapEntryList containing the mapping records filtered according to the one of the following values as specified in the DesiredContent parameter:
 <list type="bullet">
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.All"/> - all mapping records are returned in the order they were added by the translation provider.</description></item>
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.AllSorted"/> - all mapping records are returned in sorted order as determined by the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function.</description></item>
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.Limited"/> - limited filtering removes all but primary map groups and removes mapping records code relationships of low importance and then sorts the resulting maps using the MapEntry.CompareTo function.</description></item>
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.First"/> - filters mapping records to the first map expression, usually the best, to each distinct target vocabulary (i.e., code set) and then sorts the resulting maps using the MapEntry.CompareTo function.</description></item>
			</list>
		</para>
		<para>Medicomp tranlation providers sort the map records by default, so when using these providers it is sufficient to use ContentType.All instead of
 ContentType.AllSorted to get a sorted map entry list.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.MapEntry"/>
</member><member name="P:Quippe.Coding.MapManager.Maps(Quippe.Coding.MapManager.ContentType,Quippe.Coding.MapExpressionOptionEnum)">
	<summary>
 Gets the collection of maps as a list of <see cref="T:Quippe.Coding.IMap"/> references, filtered according to the specified content type.
 </summary>
	<param name="DesiredContent">A ContentType value that indicates how the code maps should be filtered.</param>
	<param name="ExpressionOption">Optional parameter indicating whether SNOMED CT descriptions will be included in SNOMED CT close-to-user-form expressions
 created for each SNOMED CT map and whether the semantic tag will be stripped off included descriptions. Default value is <see cref="F:Quippe.Coding.MapExpressionOptionEnum.NoSemanticTag"/>.</param>
	<remarks><para>Returns a List of <see cref="T:Quippe.Coding.IMap"/> references containing the grouped code maps filtered according to the one of the 
 following values as specified in the DesiredContent parameter:
 <list type="bullet">
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.All"/>- all maps are returned in sorted order as determined by the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function.</description></item>
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.AllSorted"/> - all maps are returned in sorted order as determined by the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function.</description></item>
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.Limited"/> - limited filtering removes all but primary map groups and removes maps with code relationships of low importance and then sorts the resulting maps using the MapEntry.CompareTo function.</description></item>
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.First"/> - filters maps to the first map expression, usually the best, to each distinct target vocabulary (i.e., code set) and then sorts the resulting maps using the MapEntry.CompareTo function.</description></item>
			</list>
		</para>
		<para>Medicomp tranlation providers sort the map records by default, so when using these providers it is sufficient to use ContentType.All instead of
 ContentType.AllSorted to get a sorted map entry list.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.IMap"/>
	<seealso cref="T:Quippe.Coding.IQualifyingMap"/>
</member><member name="P:Quippe.Coding.MapManager.Maps(System.String,Quippe.Coding.MapManager.ContentType,Quippe.Coding.MapExpressionOptionEnum)">
	<summary>
 Gets the collection of maps that target the specified vocabulary as a list of <see cref="T:Quippe.Coding.IMap"/> references, filtered according to the specified content type.
 </summary>
	<param name="DesiredContent">A ContentType value that indicates how the code maps should be filtered.</param>
	<param name="ExpressionOption">Optional parameter indicating whether SNOMED CT descriptions will be included in SNOMED CT close-to-user-form expressions
 created for each SNOMED CT map and whether the semantic tag will be stripped off included descriptions. Default value is <see cref="F:Quippe.Coding.MapExpressionOptionEnum.NoSemanticTag"/>.</param>
	<remarks><para>Returns a List of <see cref="T:Quippe.Coding.IMap"/> references containing the grouped code maps that target the specified vocabulary, filtered according to the one of the 
 following values as specified in the DesiredContent parameter:
 <list type="bullet">
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.All"/>- all maps are returned in sorted order as determined by the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function.</description></item>
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.AllSorted"/> - all maps are returned in sorted order as determined by the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function.</description></item>
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.Limited"/> - limited filtering removes all but primary map groups and removes maps with code relationships of low importance and then sorts the resulting maps using the MapEntry.CompareTo function.</description></item>
				<item><description><see cref="F:Quippe.Coding.MapManager.ContentType.First"/> - filters maps to the first map expression, usually the best, to each distinct target vocabulary (i.e., code set) and then sorts the resulting maps using the MapEntry.CompareTo function.</description></item>
			</list>
		</para>
		<para>A post-coordinated (grouped) map consists of a preferred map record represented by an <see cref="T:Quippe.Coding.IMap"/> reference and additional map records that
 qualify the preferred map, accessible via the <see cref="P:Quippe.Coding.IMap.QualifyingMaps"/> property. The preferred map and its qualifying maps are all targets of the
 same source entry and togther comprise a single map from the source to the target vocabulary. The preferred map and its qualifying maps should each target
 a different code in the target vocabulary. Each map indicates its relationship to the source entry via the Relationship property, and relationships are
 always from MEDCIN to an external vocabulary.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.IMap"/>
	<seealso cref="T:Quippe.Coding.IQualifyingMap"/>
</member><member name="M:Quippe.Coding.MapManager.Clear">
	<summary>
 Clears the collection of mapping records by removing all records.
 </summary>
	<seealso cref="T:Quippe.Coding.MapEntry"/>
</member><member name="P:Quippe.Coding.MapManager.EntryCount">
	<summary>
 Gets the number of mapping records represented as <see cref="T:Quippe.Coding.MapEntry"/> objects in the managed collection.
 </summary>
	<remarks>The EntryCount is the number of records or MapEntry objects, which might be higher than the
 number of map expressions (if the collection contains mappings to target vocabularies, such as SNOMED-CT,
 that group map entries into expressions).</remarks>
</member><member name="P:Quippe.Coding.MapManager.HasQualifiedEntries">
	<summary>
 Indicates whether any of the managed map entries vary by code parameters or have a source MEDCIN concept
 that is qualified by result, status, or modifier qualifier.
 </summary>
	<returns>Returns True if any of the managed map entries is qualified and False otherwise.</returns>
	<remarks>
		<para>This property indicates whether any of the managed map entries has a source MEDCIN concept that is 
 qualified or an external target code that has code parameters. This can be useful in determining whether
 changes in MEDCIN qualifiers or parameters will require an update of maps.</para>
		<para>If a targeted external code entry has parameters, then more detailed codes are available that vary
 by patient age, sex, and measurement/test value, which are qualifiers of the source MEDCIN concept.</para>
		<para>Note, the Medcin prefix is not considered a qualifier and has no bearing on the result of this function.</para>
	</remarks>
</member><member name="M:Quippe.Coding.MapManager.Add(Quippe.Coding.MapEntry)">
	<summary>
 Adds the specified <see cref="T:Quippe.Coding.MapEntry"/> object to the managed collection of mapping records.
 </summary>
	<param name="Entry">The mapping record to add, specified as MapEntry object.</param>
	<remarks>Allows Nothing to be added and allows duplicate elements.</remarks>
</member><member name="M:Quippe.Coding.MapManager.AddRange(Quippe.Coding.MapManager)">
	<summary>
 Adds the specified managed collection of mapping records to the collection managed by this instance.
 </summary>
	<param name="Maps">The managed collection of mapping records to add.</param>
	<remarks>The method has no effect if Maps is Nothing. The order of the records in Maps is preserved as records are added
 to the end of the managed collection.</remarks>
	<seealso cref="T:Quippe.Coding.MapEntry"/>
</member><member name="M:Quippe.Coding.MapManager.AddRange(Quippe.Coding.MapEntryList)">
	<summary>
 Adds the specified list of <see cref="T:Quippe.Coding.MapEntry"/> objects to the collection managed by this instance.
 </summary>
	<param name="EntriesIn">The list of MapEntry objects to add.</param>
	<remarks>The method has no effect if EntriesIn is Nothing. The order of the records in EntriesIn is preserved as records are
 added to the end of the managed collection.</remarks>
</member><member name="M:Quippe.Coding.MapManager.InsertSort(Quippe.Coding.MapEntry)">
	<summary>
 Inserts the specified <see cref="T:Quippe.Coding.MapEntry"/> instance into the collection in sorted order using the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function for comparisons.
 </summary>
	<param name="Entry">The MapEntry instance to be inserted in order as determined by the MapEntry.CompareTo function.</param>
</member><member name="M:Quippe.Coding.MapManager.InsertSort(Quippe.Coding.MapEntry,System.Collections.Generic.IComparer{Quippe.Coding.MapEntry})">
	<summary>
 Inserts the specified <see cref="T:Quippe.Coding.MapEntry"/> instance into the collection in sorted order using the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function for comparisons.
 </summary>
	<param name="Entry">The MapEntry instance to be inserted in order as determined by the MapEntry.CompareTo function.</param>
	<param name="Comparer">Class instance implementing a comparer of MapEntry objects to be used to sort the entries as they are inserted.</param>
</member><member name="M:Quippe.Coding.MapManager.InsertSortRange(Quippe.Coding.MapManager)">
	<summary>
 Inserts the specified collection of managed mapping records into the managed collection in sorted order using the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function for comparisons.
 </summary>
	<param name="Maps">The collection of <see cref="T:Quippe.Coding.MapEntry"/> objects to be inserted.</param>
	<remarks>The method has no effect if Maps is Nothing.</remarks>
</member><member name="M:Quippe.Coding.MapManager.InsertSortRange(Quippe.Coding.MapEntryList)">
	<summary>
 Inserts the specified list of <see cref="T:Quippe.Coding.MapEntry"/> objects into the managed collection in sorted order using the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function for comparisons.
 </summary>
	<param name="EntriesIn">The lsit of MapEntry objects to be inserted.</param>
	<remarks>The method has no effect if EntriesIn is Nothing.</remarks>
</member><member name="P:Quippe.Coding.MapManager.SortedEntries">
	<summary>
 Returns the managed mapping records in sorted order as a MapEntryList instance.
 </summary>
	<remarks><para>The <see cref="T:Quippe.Coding.MapEntry"/> records in the list are sorted using the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function.</para>
		<para>Medicomp tranlation providers sort the map records by default, so when using these providers it is sufficient to use
 the Entries property to get a sorted map entry list.</para></remarks>
</member><member name="P:Quippe.Coding.MapManager.LimitedEntries">
	<summary>
 Gets a limited (filtered) collection of the managed map records as a list of sorted <see cref="T:Quippe.Coding.MapEntry"/> objects.
 </summary>
	<returns>Returns a sorted list of MapEntry objects filtered to remove any records with the "Contains" code relationship and
 to remove all grouped mapping records except those in the lowest numbered group.</returns>
	<remarks><para>Maps from MEDCIN to certain target vocabularies, such as SNOMED-CT
 are grouped, meaning that a mapping expression may consist of more than one mapping records and the Group property of the mapping 
 record (e.g., MapEntry object) is used to indicate which group the record belongs to. This method returns only ungrouped mapping
 records or records that have the lowest number in the Group property, 1 being the lowest (best) group. A value of zero in the Group
 property indicates the mapping record is not grouped.</para>
		<para>The method also filters out (does not return) mapping records that have the code relationship "Contains".</para>
	</remarks>
</member><member name="P:Quippe.Coding.MapManager.BestEntries">
	<summary>
 Gets a filtered collection of the best managed map records (not fully implemented).
 </summary>
	<returns>Returns a sorted list of the <see cref="T:Quippe.Coding.MapEntry"/> objects filtered to leave only the best records to each target vocabulary.</returns>
	<remarks>At present, this method simply returns the same collection as the <see cref="P:Quippe.Coding.MapManager.LimitedEntries"/> property.</remarks>
</member><member name="M:Quippe.Coding.MapManager.GetSortedEntries">
	<summary>
 Private function to return the collection of <see cref="T:Quippe.Coding.MapEntry"/> objects in sorted order.
 </summary>
</member><member name="M:Quippe.Coding.MapManager.GetLimitedEntries">
	<summary>
 Private function to return a sorted collection of <see cref="T:Quippe.Coding.MapEntry"/> objects filtered according to <see cref="F:Quippe.Coding.MapManager.ContentType.Limited"/>.
 </summary>
</member><member name="M:Quippe.Coding.MapManager.GetEntries(System.String)">
	<summary>
 Returns a sorted list of those managed mapping records that target the specified coding system vocabulary.
 </summary>
	<param name="TargetVocabCode">The target vocabulary code of the desired mapping records.</param>
	<returns>Returns the list of managed mapping records, as a MapEntryList, that target the given vocabulary code.</returns>
	<remarks>All mapping records which have a target code entry containing a <see cref="T:Quippe.Coding.CodeSet"/> with the VocabCode property equal to the
 specified TargetVocabCode are returned.</remarks>
	<seealso cref="T:Quippe.Coding.MapEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MapManager.SortedEntries(System.String)">
	<summary>
 Gets a sorted collection of the managed map records that target the specified vocabulary.
 </summary>
	<param name="VocabCode">The target vocabulary code of the desired mapping records.</param>
	<returns>Returns a sorted list of <see cref="T:Quippe.Coding.MapEntry"/> objects that target the specified vocabulary.</returns>
	<remarks><para>All mapping records which have a target code entry containing a <see cref="T:Quippe.Coding.CodeSet"/> with the VocabCode property equal to the
 specified TargetVocabCode and which meet the conditions of the limited filter are returned.</para>
		<para>Maps from MEDCIN to certain target vocabularies, such as SNOMED-CT
 are grouped, meaning that a mapping expression may consist of more than one mapping record and the Group property of the mapping 
 record (e.g., MapEntry object) is used to indicate which group the record belongs to.</para></remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MapManager.LimitedEntries(System.String)">
	<summary>
 Gets a limited (filtered) collection of the managed map records that target the specified vocabulary.
 </summary>
	<param name="VocabCode">The target vocabulary code of the desired mapping records.</param>
	<returns>Returns a sorted list of <see cref="T:Quippe.Coding.MapEntry"/> objects that target the specified vocabulary and filtered to remove any records with 
 the "Contains" code relationship and to remove all grouped mapping records except those in the lowest numbered group.</returns>
	<remarks><para>All mapping records which have a target code entry containing a <see cref="T:Quippe.Coding.CodeSet"/> with the VocabCode property equal to the
 specified TargetVocabCode and which meet the conditions of the limited filter are returned.</para>
		<para>Maps from MEDCIN to certain target vocabularies, such as SNOMED-CT
 are grouped, meaning that a mapping expression may consist of more than one mapping record and the Group property of the mapping 
 record (e.g., MapEntry object) is used to indicate which group the record belongs to. This method returns only ungrouped mapping
 records or records that have the lowest number in the Group property, 1 being the lowest (best) group. A value of zero in the Group
 property indicates the mapping record is not grouped.</para>
		<para>The method also filters out (does not return) mapping records that have the code relationship "Contains".</para></remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MapManager.FirstEntries">
	<summary>
 Gets a sorted collection of the mapping records in the first mapping expression to each target vocabulary.
 </summary>
	<returns>Returns a sorted list of <see cref="T:Quippe.Coding.MapEntry"/> objects containing the records that comprise the first mapping expression to each target vocabulary.</returns>
	<remarks>The managed collection of mapping records is filtered so that only the records comprising the first mapping expression to each target vocabulary
 are returned. A mapping expression is either the first record in the sort order of a set of records to a target vocabulary that does not group records (Group = 0) or it is
 the lowest numbered group of records (typically Group 1) to a target vocabulary that groups records. Mapping records to each target vocabulary are sorted
 separately using the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function and then the first ungrouped record or the lowest numbered group of records are selected and combined in
 sorted order for return to the caller.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MapManager.FirstEntries(System.String)">
	<summary>
 Gets a sorted collection of the mapping records in the first mapping expression to the specified target vocabulary.
 </summary>
	<returns>Returns a sorted list of <see cref="T:Quippe.Coding.MapEntry"/> objects containing the records that comprise the first mapping expression to the specified target vocabulary.</returns>
	<remarks>The managed collection of mapping records is filtered so that only the records comprising the first mapping expression to the specified target vocabulary
 are returned. A mapping expression is either the first record in the sort order of a set of records to a target vocabulary that does not group records (Group = 0) or it is
 the lowest numbered group of records (typically Group 1) to a target vocabulary that groups records. Mapping records to the specified target vocabulary are sorted
 separately using the MapEntry.CompareTo function and then the first ungrouped record or the lowest numbered group of records are selected and returned.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MapManager.GetEntryVocabCodes">
	<summary>
 Gets a sorted collection of the unique vocabulary codes (VocabCode) of the vocabularies targeted by the 
 managed map entries.
 </summary>
	<remarks><para>The return collection contains the unique string identifiers of the vocabularies 
 that are targeted by the current collection of map entries. Each unique vocab code appears once
 in the returned collection.</para></remarks>
</member><member name="M:Quippe.Coding.MapManager.StringToContentType(System.String)">
	<summary>
 Converts a string representation of a <see cref="T:Quippe.Coding.MapManager.ContentType"/> enum value into its equivalent value from the enum.
 </summary>
	<param name="ContentTypeString">The string value to convert.</param>
	<returns>Returns the MapManager.ContentType enum value that best matches the specified string value by performing
 a case-insensitive comparison of the specified string and the enum values. Returns ContentType.All if a suitable
 match is not found.</returns>
</member><member name="M:Quippe.Coding.MapManager.ContentTypeToString(Quippe.Coding.MapManager.ContentType)">
	<summary>
 Converts a <see cref="T:Quippe.Coding.MapManager.ContentType"/> enum value to its string representation.
 </summary>
	<param name="contentType">The enum value to convert.</param>
	<returns>Returns the string representation of the specified MapManager.ContentType enum value.</returns>
</member><member name="T:Quippe.Coding.MapManager">
	<summary>
 Represents a managed collection of code mappings.
 </summary>
	<remarks><para>The MapManager class represents a managed collection of code mapping records that might result from a translation from one of the
 <see cref="T:Quippe.Coding.ICodeMappingService"/> or <see cref="T:Quippe.Coding.ITranslator"/> translation methods. The internal representation of a mapping record is hidden, but the
 primary means of adding and removing mappings from the managed collection is via the <see cref="T:Quippe.Coding.MapEntry"/> class. Each mapping record in
 the collection in its simplest form represents a mapping from a source code in a source vocabulary to a target code in a 
 target vocabulary, with a <see cref="T:Quippe.Coding.CodeRelationship"/> object that defines the semantic relationship, if one exists or has been defined,
 between the source and target, with optional properties adding further detail to the source, target and mapping record itself. If the
 mapping is from MEDCIN to an external vocabulary, the source code and vocabulary would be defined by an instance of the <see cref="T:Quippe.Coding.MedcinCodeEntry"/>
 class and the target code and vocabulary would be defined by an instance of the <see cref="T:Quippe.Coding.ExternalCodeEntry"/> class.</para>
		<para>Translations results stored in this class can be filtered to return all map entries, the first map entries in each
 target vocabulary, which are usually the best, or a limited set of map entries. The mappings records may also be filtered
 by target vocabulary.</para></remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MapEntryList.InsertSortRange(System.Collections.Generic.IEnumerable{Quippe.Coding.MapEntry})">
	<summary>
 Inserts a collection of MapEntry objects in sorted order using the MapEntry.CompareTo function for comparisons.
 </summary>
	<param name="Maps">The collection of MapEntry objects to be inserted in order determined by the MapEntry.CompareTo function.</param>
	<remarks>The method has no effect if Maps is Nothing.</remarks>
</member><member name="M:Quippe.Coding.MapEntryList.InsertSort(Quippe.Coding.MapEntry)">
	<summary>
 Inserts a MapEntry instance in the list in sorted order using the MapEntry.CompareTo function for comparisons.
 </summary>
	<param name="Map">The MapEntry instance to be inserted in order as determined by the MapEntry.CompareTo function.</param>
</member><member name="M:Quippe.Coding.MapEntryList.InsertSort(Quippe.Coding.MapEntry,System.Collections.Generic.IComparer{Quippe.Coding.MapEntry})">
	<summary>
 Inserts a MapEntry instance in the list in sorted order using the MapEntry.CompareTo function for comparisons.
 </summary>
	<param name="Map">The MapEntry instance to be inserted in order as determined by the MapEntry.CompareTo function.</param>
	<param name="Comparer">Class instance implementing a comparer of MapEntry objects to be used to sort the entries as they are inserted.</param>
</member><member name="T:Quippe.Coding.MapEntryList">
	<summary>
 Represents a list of MapEntry objects.
 </summary>
	<remarks>Derives from List(Of MapEntry) and adds methods that sort MapEntry objects by their CompareTo function as they are added to the list.</remarks>
</member><member name="F:Quippe.Coding.MapEntry.DEFAULT_START_YEAR">
	<summary>The default starting code year of a map entry.</summary>
</member><member name="F:Quippe.Coding.MapEntry.DEFAULT_END_YEAR">
	<summary>The default ending code year of a map entry.</summary>
</member><member name="F:Quippe.Coding.MapEntry.PreferredMapEntryEnum.Unspecified">
	<summary>There is no preference setting specified for the map entry.</summary>
</member><member name="F:Quippe.Coding.MapEntry.PreferredMapEntryEnum.NotPreferred">
	<summary>The map entry is not preferred over others.</summary>
</member><member name="F:Quippe.Coding.MapEntry.PreferredMapEntryEnum.Preferred">
	<summary>The map entry is preferred over others (from the same source or in the same group, if grouped).</summary>
</member><member name="T:Quippe.Coding.MapEntry.PreferredMapEntryEnum">
	<summary>
 Represents the preferred status of a map entry, relative to other map entries in the same expression.
 </summary>
	<remarks>A source concept (e.g., MEDCIN finding) may map to a target concept (e.g., SNOMED-CT concept) through 
 multiple map entries. If the target vocabulary supports complex map expressions (by grouping map entries), one
 map entry should be marked as Preferred, usually the "Same As", "Narrower Than" or "Broader Than" entry, while
 others in the same group would be marked NotPreferred. If complex map expressions are not supported by 
 grouping, the preferred enum value may be used to indicate that a single map entry is the preferred expression.
 If all entries from the same source code to the same target vocabulary are marked NotPreferred or Unspecified,
 then there is no preference.
 </remarks>
</member><member name="F:Quippe.Coding.MapEntry.MapEntryFlagEnum.PrefixIgnored">
	<summary>Prefix code specified as input to MEDCIN source of translation was ignored for mapping purposes.</summary>
</member><member name="F:Quippe.Coding.MapEntry.MapEntryFlagEnum.ResultSpecified">
	<summary>Result qualifier code was specified as input to MEDCIN source of translation.</summary>
</member><member name="T:Quippe.Coding.MapEntry.MapEntryFlagEnum">
	<summary>
 Enum defining flag bit values used in Flags property.
 </summary>
	<remarks>
		<para>The flag bit values are used with the <see cref="P:Quippe.Coding.MapEntry.Flags(Quippe.Coding.MapEntry.MapEntryFlagEnum)"/> property to get or set the relevant flag.
 The available bit flag values include those used to determine if a particular qualifier was applied to the
 MEDCIN source code in the translation. The qualifiers returned in the map entry instance are those that
 were found in the mapping record and not necessarily those that were specified on input, but this depends
 on the current qualifier match algorithm in place. For instance, Result qualifier codes may be found in the
 mapping records and returned in the map entry instance even though the source input code did not have a
 Result code value.</para>
		<para>The PrefixIgnored flag is only relevant when a <see cref="T:Quippe.Coding.MedcinCodeEntry"/> is the translation source and is 
 returned as the output of translation. The purpose of this flag is to allow the results of a translation 
 to be examined and a determination made as to whether the associated map record, in the coding service database
 or other repository for maps, actually has a mappable prefix applied to it. If this flag is set, 
 and the map entry instance is returned as part of the translation output, then it means the map record 
 does not have a prefix (i.e., the source MEDCIN concept in the map is not qualified by a prefix code), and the
 prefix was simply copied over from the translation input MEDCIN code entry. If this Flag is not set, then
 any prefix code specified in the PrefixCode property actually appears in the map.</para>
		<para>Note, only certain prefixes are considered mappable (may be applied to a map source at the time the 
 map between MEDCIN and an external vocabulary is created); examples include "history of", "family history of", 
 "allergy to", and so on. The other prefixes are essentially ignored for mapping purposes, meaning not relevant to
 mapping because they do not change the meaning of the concept (e.g., "considered", "possible", "probable", etc.) 
 or are such that they eliminate the consideration of the finding for mapping purposes (e.g., "rule out", 
 "in remission", "no evidence of", etc.).</para>
	</remarks>
</member><member name="M:Quippe.Coding.MapEntry.#ctor">
	<summary>
 Creates a new MapEntry instance with defaults for all properties.
 </summary>
</member><member name="M:Quippe.Coding.MapEntry.#ctor(Quippe.Coding.CodeEntry,Quippe.Coding.CodeRelationship,Quippe.Coding.CodeEntry,System.Type)">
	<summary>
 Creates a new MapEntry instance with the specified properties.
 </summary>
	<param name="SourceEntry">The CodeEntry for the source concept, defining at a minimum, the source vocabulary and the code for the source concept.</param>
	<param name="Relationship">The map relationship between the source concept and the concept in the target vocabulary, e.g., "Same As".</param>
	<param name="TargetEntry">The CodeEntry for the target concept, defining at a minimum, the target vocabulary and the code for the target concept.</param>
	<param name="TranslatorType">The Type of the <see cref="T:Quippe.Coding.ITranslator"/> provider responsible for this map entry.</param>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.MedcinCodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MapEntry.#ctor(Quippe.Coding.CodeEntry,Quippe.Coding.CodeRelationship,Quippe.Coding.CodeEntry,Quippe.Coding.CodingQualifier,Quippe.Coding.MapEntry.PreferredMapEntryEnum,System.Int32,System.Type,System.String)">
	<summary>
 Creates a new MapEntry instance with the specified properties.
 </summary>
	<param name="SourceEntry">The CodeEntry for the source concept, defining at a minimum, the source vocabulary and the code for the source concept.</param>
	<param name="Relationship">The map relationship between the source concept and the concept in the target vocabulary, e.g., "Same As".</param>
	<param name="TargetEntry">The CodeEntry for the target concept, defining at a minimum, the target vocabulary and the code for the target concept.</param>
	<param name="Qualifier">A map qualifier object representing a qualification on the mapping.</param>
	<param name="Preferred">Indicates whether the map entry is preferred over others from the same source concept.</param>
	<param name="Group">The group number, when greater than zero, indicating the group to which the entry belongs, or 0 if there is no grouping.</param>
	<param name="TranslatorType">The Type of the <see cref="T:Quippe.Coding.ITranslator"/> provider responsible for this map entry.</param>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.MedcinCodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MapEntry.Clone">
	<summary>
 Returns a deep copy of this MapEntry instance.
 </summary>
</member><member name="M:Quippe.Coding.MapEntry.#ctor(Quippe.Coding.MapEntry)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The MapEntry instance to copy when creating a new instance.</param>
</member><member name="P:Quippe.Coding.MapEntry.SourceEntry">
	<summary>
 Gets or sets the CodeEntry that defines the source concept in the map entry.
 </summary>
	<remarks>The source code entry defines the source end point of a single mapping record represented by the
 MapEntry. At a minimum, the source code entry defines the source vocabulary and the unique code of the source 
 concept within that vocabulary.</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.MedcinCodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MapEntry.TargetEntry">
	<summary>
 Gets or sets the CodeEntry defining the target concept in the map entry.
 </summary>
	<remarks>The target code entry defines the target end point of a single mapping record represented by the
 MapEntry. At a minimum, the target code entry defines the target vocabulary and the unique code of the target
 concept within that vocabulary.</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.MedcinCodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MapEntry.Relationship">
	<summary>
 Gets or sets the property defining the relationship between the source code entry and the target code entry.
 </summary>
	<remarks>The preferred map entry within a mapping expression usually uses one of three primary or defining code relationship
 values, either "Same As", "Narrower Than" or "Broader Than".</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.MedcinCodeEntry"/>
</member><member name="P:Quippe.Coding.MapEntry.RelationshipDisplayName">
	<summary>
 Gets a string representation of the code relationship (<see cref="P:Quippe.Coding.MapEntry.Relationship"/> property) that is suitable for display.
 </summary>
	<returns>Returns a String value for the code relationship (defined by the Relationship property) that is suitable for display. 
 </returns>
	<remarks>Use this property to get a convenient display String for the code relationship. If the Relationship is 
 null or the relationship ID is 0, indicating the relationship "None", this property returns the empty string, 
 otherwise this property returns the default string representation of the relationship object.</remarks>
	<seealso cref="T:Quippe.Coding.CodeRelationship"/>
</member><member name="P:Quippe.Coding.MapEntry.Qualifier">
	<summary>
 Gets or sets an object that defines a qualification on the mapping.
 </summary>
	<remarks>
		<para>The qualifier can be used by an <see cref="T:Quippe.Coding.ITranslator"/> provider to define custom qualifications on map entries. For 
 example, the <see cref="T:Quippe.Coding.StandardTranslator"/> provider supplied by Medicomp uses qualifiers to represent the various code types
 used within MEDCIN version 2 to represent mappings to ICD-9-CM (e.g., "Secondary", "Alternate", "Category", etc.).</para>
	</remarks>
</member><member name="P:Quippe.Coding.MapEntry.QualifierName">
	<summary>
 Gets the name of the current map qualifier instance stored in the <see cref="P:Quippe.Coding.MapEntry.Qualifier"/> property, if the property is defined.
 </summary>
	<returns>Returns the map qualifier name, if a qualifier is defined, or the empty string otherwise.</returns>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
</member><member name="P:Quippe.Coding.MapEntry.QualifierDisplayName">
	<summary>
 Gets the display name of the current map qualifier instance stored in the <see cref="P:Quippe.Coding.MapEntry.Qualifier"/> property, if the property is defined.
 </summary>
	<returns>Returns the display name for the map qualifier, if a qualifier is defined, or the empty string otherwise.</returns>
	<seealso cref="T:Quippe.Coding.CodingQualifier"/>
</member><member name="P:Quippe.Coding.MapEntry.Preferred">
	<summary>
 Gets or sets an enum value specifying whether this map entry is preferred.
 </summary>
	<remarks>Use this property to indicate whether a map entry is preferred over other map entries from the same
 source code to the same target vocabulary. Typically, in a group of map entries defining a single mapping
 expression from a source code to the target vocabulary, one map entry is the preferred entry and the others
 are not preferred.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MapEntry.Group">
	<summary>
 Gets or sets the number of the group, if any, to which the map entry belongs.
 </summary>
	<returns>Returns the group number of the group to which the map entry belongs or 0 if the map entry
 does not belong to a group.</returns>
	<remarks>
		<para>Use the IsGrouped property to determine if the map entry belongs to a group. If IsGrouped
 returns True, then use the Group property to determine the group number. Groups of map entries
 form complete map expressions in some vocabularies (notably SNOMED-CT) and groups may contain one or
 more map entries. If a map entry is grouped, then the group number also represents the priority of the
 map expressions from a common MEDCIN source code, where the lowest numbered group (e.g., group 1)
 has the highest priority and is considered the best mapping.</para>
		<para>For example, if there is a map entry from a MEDCIN concept to a pre-coordinated term in 
 SNOMED-CT using the "Same As" CodeRelationship, this map entry would normally belong to the map group
 with Group value of 1 and would normally be the only entry in the map group. Map entries from the same
 MEDCIN ID to a the SNOMED-CT concepts in a post-coordinated term, which together form the next best map, 
 would normally be given Group value of 2. If additional mappings to other post-coordinated terms are 
 available, they would be given a map Group of 3 or higher.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MapEntry.GroupId">
	<summary>
 Gets or sets the unique group identifier of the map group, if any, to which the map entry belongs.
 </summary>
	<returns>Returns the unique identifier of the group to which the map entry belongs or the empty string 
 if the map entry does not belong to a group.</returns>
	<remarks>
		<para>Groups of map entries
 form complete map expressions in some vocabularies (notably SNOMED-CT) and groups may contain one or
 more map entries. Use the IsGrouped property to determine if the map entry belongs to a group. If 
 <see cref="P:Quippe.Coding.MapEntry.IsGrouped"/> returns True, then use this property to determine the unique group identifier.
 This ID is unique across all map groups. Hence, the GroupId can be used to determine uniqueness of map
 groups in reverse translations, i.e., when translating from a source external vocabulary to a MEDCIN
 target. In contrast, the <see cref="P:Quippe.Coding.MapEntry.Group"/> property is used only to determine uniqueness of groups 
 from a common MEDCIN map source, and to obtain the preferred order of those groups, and therefore 
 is not suitable for grouping map records in reverse translations.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MapEntry.GroupDisplayName">
	<summary>
 Gets a string representation of the Group property that is suitable for display.
 </summary>
	<returns>Returns a String representation of the Group property that is suitable for display. 
 </returns>
	<remarks>Use this property to get a convenient display String for the <see cref="P:Quippe.Coding.MapEntry.Group"/> property. If the Group is 
 an invalid group number, the property returns the empty string.</remarks>
</member><member name="P:Quippe.Coding.MapEntry.IsGrouped">
	<summary>
 Indicates whether the map entry belongs to a group of map entries that together form a complete mapping.
 </summary>
	<returns>Returns True if the map entry belongs to a group of map entries or False otherwise.</returns>
	<remarks>
		<para>Use this property, and not the <see cref="P:Quippe.Coding.MapEntry.Group"/> property, to determine if the map entry belongs to a group of map entries 
 that together form a complete mapping. Use the Group property only to determine which group the entry belongs to. If the
 map entry belongs to a group, then the map entry, by itself, does not represent a complete mapping from the source 
 vocabulary to the target vocabulary.</para>
		<para>For example, a mapping from a MEDCIN concept to a post-coordinated SNOMED-CT term
 may be represented by one or more mappings from the same MEDCIN ID to one or more SNOMED-CT terms, each mapping sharing a 
 common Group number. One mapping in each group should be designated as the Preferred mapping and is usually the mapping
 with a "Same As", "Narrower Than" or "Broader Than" CodeRelationship value.</para>
	</remarks>
</member><member name="P:Quippe.Coding.MapEntry.TranslatorType">
	<summary>
 Gets or sets the Type of the <see cref="T:Quippe.Coding.ITranslator"/> provider responsible for this map entry.
 </summary>
</member><member name="P:Quippe.Coding.MapEntry.QualifierMatchCount">
	<summary>
 Gets or sets an Integer representing the number of Medcin qualifiers that match the code translation input source code entry to the map 
 source code entry in the <see cref="P:Quippe.Coding.MapEntry.SourceEntry"/> property when the source of translation is the Medcin vocabulary.
 </summary>
	<value>The number of Medcin qualifiers in the SourceEntry that match the original source code entry in the translation request.</value>
	<remarks>
		<para>This property is only relevant when the source of the translation is the Medcin vocabulary. In that case, the map represented
 by this MapEntry is a result of a translation from a source Medcin concept presented as input to the original translation request to the
 target vocabulary. The resulting source entry in this map entry may not match exactly the original input source entry, because we allow
 Medcin qualifiers to be loosely matched under certain translation options. The QualifierMatchCount property gives an indication of how
 well the source entry in the resulting map matches the original input source entry. Since we do not retain the original input source entry,
 the count is the only way to judge the quality of the map with respect to the Medcin qualifers.</para>
		<para>The Medcin qualifiers that are considered in the qualifier match are the status qualifier, modifier and result. The match is performed
 outside of this class and this property is merely used to record the match count. The match count is used in the <see cref="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)"/> function
 to sort MapEntry objects. The <see cref="T:Quippe.Coding.MapManager"/> object that manages the MapEntry collection resulting from the translation needs to sort 
 results so the best maps are presented first.
 </para>
	</remarks>
</member><member name="P:Quippe.Coding.MapEntry.StartYear">
	<summary>
 Gets or sets the lower limit of the code year range of validity of the map. 
 </summary>
	<value>The code year defining the lower limit of the temporal range within which the map is valid or active (not retired).</value>
	<remarks><para>For certain coding system vocabularies, the concept of "code year" is used to define the period of time
 that a code or map to that code is active. Vocabularies that use code years for this purpose have the 
 <see cref="P:Quippe.Coding.Vocabulary.UsesCodeYears">UsesCodeYears</see> property set. A code in such a vocabulary will have 
 a code year defining the first year the code became active in the <see cref="P:Quippe.Coding.CodeSet.Version">Version</see> property
 of its correspoding <see cref="T:Quippe.Coding.CodeSet"/> instance.</para>
		<para>For external vocabularies that use code years, the StartYear and <see cref="P:Quippe.Coding.MapEntry.EndYear"/> properties of the MapEntry
 define the range of validity of the map. The StartYear is the first code year the map became active. The StartYear is
 considered undefined (typically 0) if the external vocabulary does not use code years.</para>
	</remarks>
</member><member name="P:Quippe.Coding.MapEntry.EndYear">
	<summary>
 Gets or sets the upper limit of the code year range of validity of the map. 
 </summary>
	<value>The code year defining the upper limit of the temporal range within which the map is valid or active (not retired).</value>
	<remarks><para>For certain coding system vocabularies, the concept of "code year" is used to define the period of time
 that a code or map to that code is active. Vocabularies that use code years for this purpose have the 
 <see cref="P:Quippe.Coding.Vocabulary.UsesCodeYears">UsesCodeYears</see> property set. A code in such a vocabulary will have 
 a code year defining the first year the code became active in the <see cref="P:Quippe.Coding.CodeSet.Version">Version</see> property
 of its correspoding <see cref="T:Quippe.Coding.CodeSet"/> instance.</para>
		<para>For external vocabularies that use code years, the StartYear and <see cref="P:Quippe.Coding.MapEntry.EndYear"/> properties of the MapEntry
 define the range of validity of the map. The EndYear is either the last code year the map was active or the value "9999"
 which indicates the map is currently active. The EndYear is considered undefined (typically 9999) if the external vocabulary 
 does not use code years.</para>
	</remarks>
</member><member name="P:Quippe.Coding.MapEntry.IntermediateMedcin">
	<summary>
 Gets or sets the intermediate Medcin code entry associated with a composite map between a source and target code
 in external (non-Medcin) vocabularies. 
 </summary>
	<remarks>
		<para>A composite map is comprised of two base maps, the first from a source code in an external vocabulary to an intermediate
 Medcin concept and the second from the intermediate Medcin concept to a target external code. A composite map is not manually created 
 and reviewed by Medicomp knowledge base experts. However, both base maps are Medicomp reviewed maps and in both cases the relationships
 are defined FROM the Medcin comcept TO the external code.</para>
		<para>A composite map represents a derived relationship between two external codes and may be of dubious quality given such a
 map is created on the fly, without benefit of manual review. In addition, the first leg of a composite map may be less reliable 
 because it follows a reviewed Medicomp base map in the reverse direction from an external code to Medcin. Saving the intermediate
 Medcin code entry (and the source and target relationships of the base maps) gives insight into the quality of the semantic relationship 
 between two external concepts in a composite map, which was inferred from the two base Medicomp mappings.</para>
	</remarks>
</member><member name="P:Quippe.Coding.MapEntry.SourceRelationship">
	<summary>
 Gets or sets the property defining the first relationship in a composite map between a source code in an external 
 vocabulary and an intermediate Medcin concept.
 </summary>
	<remarks>
		<para>This property is used to stored the first relationship in a composite map from one external vocabulary to another 
 external vocabulary via an intermediate Medcin concept, the ID of which is available via the <see cref="P:Quippe.Coding.MapEntry.IntermediateMedcin"/> property.
 A composite map is comprised of two maps, the first from a source code in an external vocabulary to an intermediate Medcin concept 
 and the second from the intermediate Medcin concept to a target external code. A composite map is not manually created 
 and reviewed by Medicomp knowledge base experts. However, both base maps are Medicomp reviewed maps and in both cases the relationships 
 are defined FROM the Medcin concept TO the external code. This first relationship, called the source relationship, is the relationship between 
 an intermediate Medcin concept and a source external concept.</para>
		<para>A composite map represents a derived relationship between two external codes and may be of dubious quality given such a
 map is created on the fly, without benefit of manual review. In addition, the first leg of a composite map may be less reliable 
 because it follows a reviewed Medicomp base map in the reverse direction from an external code to Medcin. Saving the source and
 target relationships of the base maps (and the intermediate Medcin ID) gives insight into the quality of the semantic relationship 
 between the two concepts, which was inferred from the two Medicomp mappings.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.MedcinCodeEntry"/>
</member><member name="P:Quippe.Coding.MapEntry.TargetRelationship">
	<summary>
 Gets or sets the property defining the second relationship in a composite map between an intermediate Medcin concept and a target code 
 in an external vocabulary.
 </summary>
	<remarks>
		<para>This property is used to stored the second relationship in a composite map from one external vocabulary to another 
 external vocabulary via an intermediate Medcin concept, the ID of which is available via the <see cref="P:Quippe.Coding.MapEntry.IntermediateMedcin"/>property.
 A composite map is comprised of two maps, the first to the intermediate Medcin concept and the second from the intermediate Medcin 
 concept to the target external code. A composite map is not manually created and reviewed by Medicomp knowledge base experts. 
 However, both base maps are Medicomp reviewed maps and in both cases the relationships are defined FROM the Medcin concept TO the
 external code. This first relationship, called the source relationship, is the relationship between an intermediate Medcin concept 
 and a source external concept.</para>
		<para>A composite map represents a derived relationship between two external codes and may be of dubious quality given such a
 map is created on the fly, without benefit of manual review. In addition, the first leg of a composite map may be less reliable 
 because it follows a reviewed Medicomp base map in the reverse direction from an external code to Medcin. Saving the source and
 target relationships of the base maps (and the intermediate Medcin ID) gives insight into the quality of the semantic relationship 
 between the two concepts, which was inferred from the two Medicomp mappings.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.MedcinCodeEntry"/>
</member><member name="P:Quippe.Coding.MapEntry.HasMedcinSource">
	<summary>
 Indicates whether the source of the translation is a Medcin code entry.
 </summary>
</member><member name="P:Quippe.Coding.MapEntry.HasMedcinTarget">
	<summary>
 Indicates whether the target of the translation is a Medcin code entry.
 </summary>
</member><member name="P:Quippe.Coding.MapEntry.HasExternalSource">
	<summary>
 Indicates whether the source of the translation is an external code entry.
 </summary>
</member><member name="P:Quippe.Coding.MapEntry.HasExternalTarget">
	<summary>
 Indicates whether the target vocabulary of the translation is an external code entry.
 </summary>
</member><member name="P:Quippe.Coding.MapEntry.PrefixCode">
	<summary>
 Gets the unique code of the optional prefix that qualifies the map, regardles of whether the MEDCIN code
 entry is the source or target of the map.
 </summary>
	<returns>Returns the unique string code of the MEDCIN prefix that qualifies the map, if it exists, or the empty 
 string otherwise.</returns>
	<remarks>
		<para>If this map entry does not have a MedcinCodeEntry instance as the source or target of the map, then
 a prefix does not exist as prefixes only qualify MEDCIN concepts. If the source is a <see cref="T:Quippe.Coding.MedcinCodeEntry"/>
 then the prefix qualifies the map only if the <see cref="P:Quippe.Coding.MapEntry.Flags(Quippe.Coding.MapEntry.MapEntryFlagEnum)"/> property is False for the 
 <see cref="F:Quippe.Coding.MapEntry.MapEntryFlagEnum.PrefixIgnored"/> bit. 
 There is no such requirement if the target is a MedcinCodeEntry.</para>
		<para>If either the source or the target code entry is a MedcinCodeEntry instance and the instance has a
 prefix, and if the instance is in the source and the prefix is not ignored for mapping purposes, then the
 prefix is assumed to have been a property of the original map record in the map repository (e.g., the
 coding service database) and not an input property of a translation request, that is, its a translation result.
 </para>
	</remarks>
</member><member name="P:Quippe.Coding.MapEntry.ModifierCode">
	<summary>
 Gets the unique code of the optional MEDCIN modifier that qualifies the map, regardles of whether the MEDCIN code
 entry is the source or target of the map.
 </summary>
	<returns>Returns the unique string code of the modifier that qualifies the map, if it exists, or the empty 
 string otherwise.</returns>
	<remarks>
		<para>If this map entry does not have a MedcinCodeEntry instance as the source or target of the map, then
 a modifier does not exist as modifiers only qualify MEDCIN concepts.</para>
		<para>If either the source or the target code entry is a MedcinCodeEntry instance and the instance has a
 modifier, then the modifier is assumed to have been a property of the original map record in the map repository (e.g., the
 coding service database) and not an input property of a translation request, that is, its a translation result.</para>
	</remarks>
</member><member name="P:Quippe.Coding.MapEntry.StatusQualifierCode">
	<summary>
 Gets the unique code of the optional MEDCIN status qualifier that qualifies the map, regardles of whether the MEDCIN code
 entry is the source or target of the map.
 </summary>
	<returns>Returns the unique string code of the status qualifier that qualifies the map, if it exists, or the empty 
 string otherwise.</returns>
	<remarks>
		<para>If this map entry does not have a MedcinCodeEntry instance as the source or target of the map, then
 a status qualifier does not exist as status qualifiers only qualify MEDCIN concepts.</para>
		<para>If either the source or the target code entry is a MedcinCodeEntry instance and the instance has a
 status qualifier, then the qualifier is assumed to have been a property of the original map record in the map repository (e.g., the
 coding service database) and not an input property of a translation request, that is, its a translation result.</para>
	</remarks>
</member><member name="P:Quippe.Coding.MapEntry.ResultCode">
	<summary>
 Gets the unique code of the optional MEDCIN result qualifier that qualifies the map, regardles of whether the MEDCIN code
 entry is the source or target of the map.
 </summary>
	<returns>Returns the unique string code of the result qualifier that qualifies the map, if it exists, or the empty 
 string otherwise.</returns>
	<remarks>
		<para>If this map entry does not have a MedcinCodeEntry instance as the source or target of the map, then
 a result qualifier does not exist as result qualifiers only qualify MEDCIN concepts.</para>
		<para>If either the source or the target code entry is a MedcinCodeEntry instance and the instance has a
 result qualifier, then the qualifier is assumed to have been a property of the original map record in the map repository (e.g., the
 coding service database) and not an input property of a translation request, that is, its a translation result.</para>
	</remarks>
</member><member name="P:Quippe.Coding.MapEntry.Flags(Quippe.Coding.MapEntry.MapEntryFlagEnum)">
	<summary>
 Gets or sets the value of the specified bit flag as a Boolean value.
 </summary>
	<param name="FlagType">The enumerated value from <see cref="T:Quippe.Coding.MapEntry.MapEntryFlagEnum"/> that represents the bit flag to get or set.</param>
	<value>A Boolean value indicating whether the bit flag is set or not set.</value>
	<returns>Returns True if the specified bit flag is set and False otherwise.</returns>
</member><member name="M:Quippe.Coding.MapEntry.CompareTo(Quippe.Coding.MapEntry)">
	<summary>
 Compares the this MapEntry with another specified MapEntry.
 </summary>
	<param name="Other">The MapEntry object to compare to this MapEntry object.</param>
	<returns><para>Returns a signed integer that indicates the relative ordering of values of this MapEntry and the map entry in Other.</para></returns>
	<remarks><para>If this
 MapEntry is less than Other, this function returns a negative integer. If this MapEntry equals Other, this function returns 0. If this
 MapEntry is greater than Other, this function returns a positive integer.</para>
		<para>Compares MapEntry properties in the following order:
 <list type="number">
				<item><description>SourceEntry.CodeSet - code set of the map source, primarily sorted by the source vocabulary code, VocabCode</description></item>
				<item><description>SourceEntry.Code - code in the code set of the map source</description></item>
				<item><description>SourceEntry.PrefixCode - prefix code if the map source, SourceEntry, is derived from MedcinCodeEntry</description></item>
				<item><description>TargetEntry.CodeSet - code set of the map target, primarily sorted by the target vocabulary code, VocabCode</description></item>
				<item><description>TargetEntry.PrefixCode - prefix code if the map target, TargetEntry, is derived from MedcinCodeEntry</description></item>
				<item><description>Group - group number of the map entry, if defined, sorted in order of best group, from lowest to highest</description></item>
				<item><description>TargetEntry.TermTypeName - name of the term type in the target vocabulary, if defined</description></item>
				<item><description>QualifierDisplayName - name of the map qualifier, if defined</description></item>
				<item><description>Preferred - preferred flag, with preferred (value 1) entries first over non-preferred (value 0)</description></item>
				<item><description>Relationship.Id - the integer identifier of the code relationship, sorted in ascending order</description></item>
				<item><description>SourceEntry.QualifierMatchCount - number of Medcin qualifiers that match input source entry if source is Medcin</description></item>
				<item><description>SourceEntry - If Medcin is source, the entries are sorted by everything, which means Medcin qualifiers as that's all that should be left not sorted</description></item>
				<item><description>TargetEntry - Sorts by code in the code set of the map target and other properties of the TargetEntry (e.g., Medcin qualifiers if target is Medcin)</description></item>
			</list>
		</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeRelationship"/>
	<seealso cref="T:Quippe.Coding.CodeSet"/>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.MedcinCodeEntry"/>
	<seealso cref="T:Quippe.Coding.Prefix"/>
</member><member name="T:Quippe.Coding.MapEntry">
	<summary>
 Represents a single record or entry in a mapping between a source concept in one medical terminology vocabulary 
 and a target concept in another vocabulary.
 </summary>
	<remarks>
		<para>The minimum information required to define a map entry are the source and target code entries and the
 relationship between them. The end points of the map entry are a source code entry object in the (e.g., a <see cref="T:Quippe.Coding.MedcinCodeEntry"/>
 instance representing a source MEDCIN concept) and a target code entry object (e.g., a <see cref="T:Quippe.Coding.ExternalCodeEntry"/>
 instance representing a code in an external vocabulary), each of which defines at least a vocabulary (e.g., MEDCIN, RxNorm, etc.) 
 and the unique code of a concept within that vocabulary. The relationship, as an instance of the <see cref="T:Quippe.Coding.CodeRelationship"/> class,
 defines how the source concept is related (maps) to the target concept. 
 For instance, a map entry from a source concept to an exact equivalent concept in the target vocabulary would 
 have the "Same As" relationship. </para>
		<para>The remaining properties of the map entry, including Preferred, Group and MapQualifier provide the means for an
 translation provider implementing <see cref="T:Quippe.Coding.ITranslator"/> to represent more complex maps. For instance, 
 mapping expressions between a source code
 and a target vocabulary may consist of one or more map entries. In the simplest case, a single map entry may
 define the complete mapping expression between the source concept and the target vocabulary, such as might be
 the case when mapping a MEDCIN concept to a pre-coordinated SNOMED-CT concept using the "Same As" relationship.
 At the other extreme, a complex mapping expression may be defined by a group of multiple map entries, such as
 when a MEDCIN concept is mapped to a post-coordinated SNOMED-CT expression consisting of multiple SNOMED-CT
 concepts. The Group property provides the means to group multiple map entries that define a single mapping
 expression. The Preferred property provides the means to specify that one map entry within the group is preferred
 over others. The MapQualifier property provides a customizable String property to define any qualification on a
 mapping. For instance, Medicomp uses the MapQualifier property to represent the many different ways that MEDCIN 
 concepts can be mapped to ICD-9-CM concepts in the MEDCIN version 2 server.</para>
		<para>A MapEntry can represent either a base map or a composite map. A base map is a map between a Medcin concept
 and a concept in an external vocabulary. A forward base map is from a source Medcin concept to a target external
 concept. A reverse base map is from a source external concept to a target Medcin concept. A composite map is a map
 between two concepts in external vocabularies, inferred from two base maps, one reverse and one forward, having a 
 common intermediate Medcin concept.</para>
		<para>A composite map is created by a code translation from one external (non-Medcin) vocabulary to another. The 
 coding service uses Medicomp's base mappings from Medcin to external vocabularies such as ICD-10-CM and SNOMED to 
 infer a relationship between a source and target concept in two different external vocabularies (e.g., SNOMED to 
 ICD-10-CM). The base mappings are created and reviewed by Medicomp staff to deliberately establish semantic relationships 
 in the forward direction, FROM Medcin concepts TO concepts in external vocabularies. That is, all relationships in 
 base maps are semantically defined in the forward direction with the Medcin concept as source and the external 
 concept as target. Any relationships between two concepts in external vocabularies must be inferred from the 
 relationships in two base maps having a common intermediate Medcin concept. The properites <see cref="P:Quippe.Coding.MapEntry.IntermediateMedcin"/>,
 <see cref="P:Quippe.Coding.MapEntry.SourceRelationship"/> and <see cref="P:Quippe.Coding.MapEntry.TargetRelationship"/> store the most important
 information about the base maps that comprise a composite map. The <see cref="P:Quippe.Coding.MapEntry.Relationship"/> property of
 a composite map contains the relationship between the source and target external codes that was inferred from the
 source relationship in the associated reverse base map (e.g., <see cref="P:Quippe.Coding.MapEntry.SourceRelationship"/> ) and the target 
 relationship in the associated forward base map (e.g., <see cref="P:Quippe.Coding.MapEntry.TargetRelationship"/>).</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="F:Quippe.Coding.MapExpressionOptionEnum.FullDescription">
	<summary>Indicates the map expression should include the full description with semantic tag, if present</summary>
</member><member name="F:Quippe.Coding.MapExpressionOptionEnum.NoDescription">
	<summary>Indicates the map expression should not include the description</summary>
</member><member name="F:Quippe.Coding.MapExpressionOptionEnum.NoSemanticTag">
	<summary>Indicates the map expression should include the description, but no semantic tag, if present</summary>
</member><member name="T:Quippe.Coding.MapExpressionOptionEnum">
	<summary>
 Enum defining options to control how map expressions are generated.
 </summary>
</member><member name="T:Quippe.Coding.Map">
	<summary>
 Class representing a map between a single source vocabulary code and one or more target codes, including one primary target code
 represented in this class and zero or more qualifying map instances represented by the collection of <see cref="T:Quippe.Coding.IQualifyingMap"/> instances available
 from the <see cref="P:Quippe.Coding.Map.QualifyingMaps"/> property.
 </summary>
	<remarks>
		<para>This class provides a means to represent a post-coordinated map as a complete entity, constructed hierarchically from the related 
 <see cref="T:Quippe.Coding.MapEntry"/> objects (i.e., map records), rather than as a flat collection of <see cref="T:Quippe.Coding.MapEntry"/> objects from which an 
 association must be inferred using group properties of the entries. That is, using this class as a supplement to the <see cref="T:Quippe.Coding.MapEntry"/>
 class, provides a means to access the entirety of each unique map (as identified by the <see cref="P:Quippe.Coding.Map.GroupId"/> property), as opposed to working with multiple 
 ungrouped entry instances.</para>
		<para>The class implements both the IMap interface, representing a primary map entry, and the IQualifyingMap interface representing
 an entry that qualifies the primary entry.</para>
	</remarks>
</member><member name="T:Quippe.Coding.IQualifyingMap">
	<summary>
 Interface representing a qualifying map instance (or record), presumably associated with a primary map instance (record) 
 defined in a parent <see cref="T:Quippe.Coding.IMap"/> instance.
 </summary>
</member><member name="T:Quippe.Coding.IMap">
	<summary>
 Interface representing a map between a single code in a source vocabulary and one or more codes in a target vocabulary, the map
 consisting of a primary map instance (or record) and zero or more qualifying map instances (records).
 </summary>
</member><member name="P:Quippe.Coding.CodeRelationship.SameAs">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Same as"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.BroaderThan">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Broader than"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.NarrowerThan">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Narrower than"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.RelatedTo">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Related to"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.AssociatedMorphology">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Associated morphology"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.FindingSite">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Finding site"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.CausativeAgent">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Causative agent"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.ClinicalCourse">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Clinical course"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Laterality">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Laterality"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Contains">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Contains"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.PartOf">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Part of"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasOccurrence">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has occurrence"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasModifier">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has modifier"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Method">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Method"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.DirectSubstance">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Direct substance"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.AssociatedFinding">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Associated finding"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.AssociatedWith">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Associated with"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.DueTo">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Due to"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Severity">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Severity"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasGrade">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has grade"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.After">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "After"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.AssociatedProcedure">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Associated procedure"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.PathologicalProcess">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Pathological process"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasFocus">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has focus"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasSpecimen">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has specimen"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.ProcedureSite">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Procedure site"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IndirectMorphology">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Indirect morphology"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.DirectMorphology">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Direct morphology"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.AutomatedDirect">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Automated, direct"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.AutomatedIndirect">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Automated, indirect"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsAssociatedMorphologyFor">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Is associated morphology for"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsFindingSiteFor">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Is finding site for"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsLateralityFor">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Is laterality for"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsCausativeAgentFor">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Is causative agent for"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsClinicalCourseFor">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Is clinical course for"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.FindingMethod">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Finding method"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.FindingInformer">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Finding informer"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsFindingFor">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Is Finding for"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasFinding">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has Finding"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.DirectDevice">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Direct device"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsDirectDeviceFor">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Is direct device for"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasFindingMethod">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has finding method"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsSeverityFor">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Is severity for"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsGroupedBy">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Is grouped by"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Groups">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Groups"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasMeasuredComponent">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has measured component"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Access">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Access"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Component">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Component"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Episodicity">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Episodicity"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.FindingContext">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Finding context"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasActiveIngredient">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has active ingredient"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasDefinitionalManifestation">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has definitional manifestation"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasDoseForm">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has dose form"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasIntent">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has intent"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.HasInterpretation">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Has interpretation"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Interprets">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Interprets"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.MeasurementMethod">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Measurement method"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Occurrence">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Occurrence"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Priority">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Priority"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.ProcedureContext">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Procedure context"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.ProcedureDevice">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Procedure device"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IndirectDevice">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Indirect device"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.UsingDevice">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Using device"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.UsingAccessDevice">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Using access device"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.ProcedureMorphology">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Procedure morphology"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.ProcedureSiteDirect">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Procedure site - Direct"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.ProcedureSiteIndirect">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Procedure site - Indirect"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.PropertyRel">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Property"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.RecipientCategory">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Recipient category"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.RevisionStatus">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Revision status"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.RouteOfAdministration">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Route of administration"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.ScaleType">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Scale type"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.SpecimenProcedure">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Specimen procedure"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.SpecimenSourceIdentity">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Specimen source identity"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.SpecimenSourceMorphology">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Specimen source morphology"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.SpecimenSourceTopography">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Specimen source topography"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.SpecimenSubstance">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Specimen substance"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.SubjectOfInformation">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Subject of information"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.SubjectRelationshipContext">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Subject relationship context"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.SurgicalApproach">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Surgical approach"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.TemporalContext">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Temporal context"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.TimeAspect">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Time aspect"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.UsingEnergy">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Using energy"</summary>
</member><member name="P:Quippe.Coding.CodeRelationship.UsingSubstance">
	<summary>Gets the standard CodeRelationship object representing the standard relationship, "Using substance"</summary>
</member><member name="F:Quippe.Coding.CodeRelationship.SortMethod.None">
	<summary>Indicates CodeRelationship objects should not be sorted.</summary>
</member><member name="F:Quippe.Coding.CodeRelationship.SortMethod.DisplayOrder">
	<summary>Indicates CodeRelationship objects should sorted by the DisplayOrder property.</summary>
</member><member name="F:Quippe.Coding.CodeRelationship.SortMethod.Name">
	<summary>Indicates CodeRelationship objects should sorted by the Name property.</summary>
</member><member name="F:Quippe.Coding.CodeRelationship.SortMethod.ID">
	<summary>Indicates CodeRelationship objects should sorted by the Id property.</summary>
</member><member name="T:Quippe.Coding.CodeRelationship.SortMethod">
	<summary>
 Defines the ways that CodeRelationships may be sorted.
 </summary>
</member><member name="M:Quippe.Coding.CodeRelationship.CodeRelationshipComparer.#ctor(Quippe.Coding.CodeRelationship.SortMethod)">
	<summary>
 Creates a new CodeRelationshipComparer object that implements IComparer(Of CodeRelationship) and can be used
 to compare two CodeRelationship objects or sort a collection.
 </summary>
	<param name="CompareType">The method by which two CodeRelationship objects should be compared in the Compare
 function.</param>
	<remarks>The default method is to compare the DisplayOrder property of the CodeRelationship objects.</remarks>
</member><member name="P:Quippe.Coding.CodeRelationship.CodeRelationshipComparer.CompareType">
	<summary>
 Gets the method by which CodeRelationships are compared in the Compare function.
 </summary>
</member><member name="M:Quippe.Coding.CodeRelationship.CodeRelationshipComparer.Compare(Quippe.Coding.CodeRelationship,Quippe.Coding.CodeRelationship)">
	<summary>
 Compare function used in sorting CodeRelationship results in List.
 </summary>
	<param name="x">The first CodeRelationship object to compare.</param>
	<param name="y">The second CodeRelationship object to compare.</param>
	<returns>Returns a signed integer that indicates the relative ordering of values of x and y. If x is less than
 y, this function returns a negative integer. If x equals y, this function returns 0. If x is greater than y,
 this function returns a positive integer.</returns>
	<remarks>CodeRelationship objects are sorted using the method specified in the CompareType property.</remarks>
</member><member name="T:Quippe.Coding.CodeRelationship.CodeRelationshipComparer">
	<summary>
 Class implementing IComparer that provides a Compare function used to sort CodeRelationship objects.
 </summary>
	<remarks>CodeRelationship objects can be compared using the DisplayOrder, Name or Id property. The default
 compare method is to use DisplayOrder.</remarks>
</member><member name="M:Quippe.Coding.CodeRelationship.LoadAll">
	<summary>
 Loads the standard values collection and name index if they have not been created yet.
 </summary>
	<remarks>The name index indexes standard relationship IDs by standard relationship names.</remarks>
</member><member name="M:Quippe.Coding.CodeRelationship.#ctor(System.Int32,System.String,System.Int32,System.Int32,System.String,System.Boolean)">
	<summary>
 Creates a new CodeRelationship instance.
 </summary>
	<param name="Id">The unique Integer identifier of the relationship.</param>
	<param name="Name">The unique String name of the relationship.</param>
	<param name="DisplayOrder">An optional number indicating the position the relationship should occupy in a displayed list of relationships.</param>
	<param name="SnomedId">The (optional) unique ID of the concept associated with the relationship in the SNOMED-CT system, or 0 if not a SNOMED-CT relationship.</param>
	<param name="Description">An optional description of the relationship.</param>
</member><member name="P:Quippe.Coding.CodeRelationship.Id">
	<summary>
 Gets the unique Integer identifier of this relationship.
 </summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Name">
	<summary>
 Gets the unique String name of this relationship.
 </summary>
</member><member name="P:Quippe.Coding.CodeRelationship.DisplayOrder">
	<summary>
 Gets a number indicating the position the relationship should occupy in a displayed list of relationships.
 </summary>
</member><member name="P:Quippe.Coding.CodeRelationship.SnomedId">
	<summary>
 Gets the SnomedId of the relationship, if the relationship is defined as a concept in SNOMED-CT, or 0 otherwise, as specified in the constructor.
 </summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Description">
	<summary>
 Gets the description of the relationship.
 </summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsPrimaryRelationship">
	<summary>
 Returns True if the relationship is one of the defining relationships, SameAs, NarrowerThan or BroaderThan and False otherwise.
 </summary>
</member><member name="P:Quippe.Coding.CodeRelationship.IsSameOrNarrowerThan">
	<summary>
 Returns True if the relationship is SameAs or NarrowerThan.
 </summary>
</member><member name="P:Quippe.Coding.CodeRelationship.Reserved">
	<summary>
 Gets a Boolean value indicating whether the code relationship ID is reserved.
 </summary>
	<value>True if the code relationship ID assigned to this instance is reserved and False if the code relationship
 ID is a valid ID for a standard relationship that is currently in use.</value>
	<remarks>Standard code relationships that are in use are not reserved. Several code relationship IDs may be reserved
 for future use and the Reserved property of the associated code relationship instance will be True in that case.</remarks>
</member><member name="M:Quippe.Coding.CodeRelationship.ToString">
	<summary>
 Returns a String representation of an instance of this class. The default is the Name property. 
 </summary>
</member><member name="P:Quippe.Coding.CodeRelationship.None">
	<summary>
 Gets the CodeRelationship instance that represents the absence of a relationship between two codes.
 </summary>
	<remarks>This is the standard relationship with ID, 0, and name, "None", that indicates the absence of a
 relationship between the two codes (e.g., maybe no relationship exists or has been defined by the code 
 mappers).</remarks>
</member><member name="P:Quippe.Coding.CodeRelationship.StandardValuesCount">
	<summary>
 Gets the total number of standard code relationships, including those that are reserved.
 </summary>
</member><member name="M:Quippe.Coding.CodeRelationship.GetStandardNames(System.Boolean,Quippe.Coding.CodeRelationship.SortMethod)">
	<summary>
 Gets a collection of the unique String names of the standard pre-defined code relationships, ignoring reserved 
 relationships, if desired.
 </summary>
	<param name="IgnoreReserved">Optional parameter indicating whether relationships that are marked as reserved should not 
 be added to the collection of standard names.</param>
	<param name="SortMethod">Optional parameter indicating how the returned collection of is sorted.</param>
	<returns>Returns a collection of string names of the standard code relationships as an ICollection(Of String), sorted
 by the specified SortMethod.</returns>
	<remarks><para>The collection of code relationship names is not sorted by default, meaning the names are returned in the
 order the associated standard CodeRelationship objects were added.</para>
		<para>Code relationships marked as reserved are not used and therefore the default is to not add reserved names to
 the collection of names returned. However, if IgnoreReserved is False, then reserved names will be included in the list.
 </para></remarks>
</member><member name="M:Quippe.Coding.CodeRelationship.GetStandardNamesUnsorted(System.Boolean)">
	<summary>
 Gets a collection of the unique String names of the standard pre-defined code relationships, ignoring reserved 
 relationships, if desired.
 </summary>
	<param name="IgnoreReserved">Indicates whether relationships that are marked as reserved should not 
 be added to the collection of standard names.</param>
	<returns>Returns an unsorted collection of string names of the standard code relationships as an ICollection(Of String).
 </returns>
	<remarks><para>The collection of names is not sorted. Names will appear in the order their associated standard
 CodeRelationship object was loaded.</para>
		<para>Code relationships marked as reserved are not used and therefore the default is to not add reserved names to
 the collection of names returned. However, if IgnoreReserved is False, then reserved names will be included in the list.
 </para></remarks>
</member><member name="M:Quippe.Coding.CodeRelationship.GetStandardNamesSorted(System.Boolean,Quippe.Coding.CodeRelationship.SortMethod)">
	<summary>
 Gets a sorted collection of the unique String names of the standard pre-defined code relationships, ignoring reserved 
 relationships, if desired.
 </summary>
	<param name="IgnoreReserved">Indicates whether relationships that are marked as reserved should not 
 be added to the collection of standard names.</param>
	<param name="SortMethod">Indicates how the returned collection of is sorted.</param>
	<returns>Returns a collection of string names of the standard code relationships as an ICollection(Of String), sorted
 by the specified SortMethod.</returns>
	<remarks>
		<para>Code relationships marked as reserved are not used and therefore the default is to not add reserved names to
 the collection of names returned. However, if IgnoreReserved is False, then reserved names will be included in the list.
 </para></remarks>
</member><member name="M:Quippe.Coding.CodeRelationship.GetStandardIds(System.Boolean)">
	<summary>
 Gets a collection of the unique Integer IDs of the standard pre-defined code relationships, ignoring reserved 
 relationships, if desired.
 </summary>
	<param name="IgnoreReserved">Indicates whether relationships that are marked as reserved should not be added to the
 collection of standard IDs.</param>
	<returns>Returns a collection of Integer IDs of the standard code relationships as an ICollection(Of Integer).</returns>
	<remarks><para>IDs in the returned collection are not sorted before they are returned. They appear in the order
 the standard CodeRelationship objects were loaded, which is in ID order.</para>
		<para>Code relationships marked as reserved are not used and therefore the default is to not add reserved IDs to
 the collection of IDs returned. However, if IgnoreReserved is False, then reserved names will be included in the list.
 </para></remarks>
</member><member name="M:Quippe.Coding.CodeRelationship.GetStandardValue(System.Int32)">
	<summary>
 Returns a copy of the standard pre-defined relationship that has the specified ID.
 </summary>
	<param name="Id">The unique Integer ID of the desired standard relationship. Standard relationship IDs are
 greater than or equal to zero (&gt;= 0).</param>
	<returns>Returns a copy of the standard relationship having the specified ID, if one exists, or Nothing if a 
 standard relationship with that ID does not exist.</returns>
</member><member name="M:Quippe.Coding.CodeRelationship.GetStandardValue(System.String)">
	<summary>
 Returns a copy of the standard pre-defined relationship that has the specified name.
 </summary>
	<param name="Name">The unique String name of the desired standard relationship.</param>
	<returns>Returns a copy of the standard relationship having the specified name, if one exists, or Nothing if a
 standard relationship with that name does not exist.</returns>
	<remarks></remarks>
</member><member name="M:Quippe.Coding.CodeRelationship.GetStandardValueBySnomedId(System.Int32)">
	<summary>
 Returns a copy of the standard pre-defined relationship that has the specified SNOMED ID.
 </summary>
	<param name="SnomedId">The unique Integer SNOMED ID of the desired standard relationship. Standard relationship IDs are
 greater than or equal to zero (&gt;= 0).</param>
	<returns>Returns a copy of the standard relationship having the specified SNOMED ID, if one exists, or Nothing if a 
 standard relationship with that SNOMED ID does not exist.</returns>
</member><member name="M:Quippe.Coding.CodeRelationship.GetStandardValueHelper(System.Int32)">
	<summary>
 Helper method that returns a copy of the standard relationship having the specified ID or a new relationship 
 if one with that ID does not already exist.
 </summary>
</member><member name="M:Quippe.Coding.CodeRelationship.DeriveRelationship(System.Int32,System.Int32)">
	<summary>
 Given the two relationships of the two base maps in a composite map from a source concept in an external vocabulary to a target concept in another external
 vocabulary, via a common Medcin concept, derive a single relationship that describes as best as possible the relationship between the source and the
 target external concepts.
 </summary>
	<param name="SourceRelationshipId">The unique identifier of a <see cref="T:Quippe.Coding.CodeRelationship"/> instance defining the relationship between the 
 intermediate Medcin concept and the concept in the source external vocabulary. The relationship is assumed to be FROM the intermediate concept 
 TO the source external concept.</param>
	<param name="TargetRelationshipId">The unique identifier of a <see cref="T:Quippe.Coding.CodeRelationship"/> instance defining the relationship between the 
 intermediate Medcin concept and the concept in the target external vocabulary. The relationship is assumed to be FROM the intermediate concept 
 TO the target external concept.</param>
	<returns>Returns a <see cref="T:Quippe.Coding.CodeRelationship"/> instance defining the relationship derived from the two relationships in the base maps that 
 represents the best estimate of the relationship between the source and target concepts in the external vocabularies referenced by the composite map.</returns>
	<remarks>
		<para>A composite map is created by a code translation from one external (non-Medcin) vocabulary to another. The coding service uses Medicomp's
 base mappings from Medcin to external vocabularies such as ICD-10-CM and SNOMED to infer a relationship between a source and target concept in
 two different external vocabularies (e.g., SNOMED to ICD-10-CM). The base mappings are created and reviewed by Medicomp staff to deliberately
 establish relationships FROM Medcin concepts TO concepts in external vocabularies. That is, all relationships in base maps are defined with the
 Medcin concept as source and the external concept as target. Any relationships between two concepts in external vocabularies
 must be inferred from the relationships in the base maps.</para>
		<para>Two base maps from a common intermediate Medcin concept are needed to create a composite map. The source relationship is the relationship 
 between the source external concept and the intermediate Medcin concept, but semantically the direction is from Medcin to the external concept.
 For example, a source relationship of "Narrower Than" between an external concept and a Medcin concept means the Medcin concept is narrower in
 clinical meaning than the external concept. The target relationship is the relationship between (from) the intermediate Medcin concept and (to)
 the target external concept. 
 </para>
		<para>This function takes two deliberately defined relationship from two base maps and created a derived relationship that is the best estimate
 of the relationship between the source concept in the source external vocabulary and the target concept in the target external vocabulary.</para>
	</remarks>
</member><member name="M:Quippe.Coding.CodeRelationship.DeriveRelationship(Quippe.Coding.CodeRelationship,Quippe.Coding.CodeRelationship)">
	<summary>
 Given the two relationships of the two base maps in a composite map from a source concept in an external vocabulary to a target concept in another external
 vocabulary, via a common Medcin concept, derive a single relationship that describes as best as possible the relationship between the source and the
 target external concepts.
 </summary>
	<param name="SourceRelationship">A <see cref="T:Quippe.Coding.CodeRelationship"/> instance defining the relationship between the intermediate Medcin concept 
 and the concept in the source external vocabulary. The relationship is assumed to be FROM the intermediate concept TO the source external concept.</param>
	<param name="TargetRelationship">A <see cref="T:Quippe.Coding.CodeRelationship"/> instance defining the relationship between the intermediate Medcin concept and 
 the concept in the target external vocabulary. The relationship is assumed to be FROM the intermediate concept TO the target external concept.</param>
	<returns>Returns a <see cref="T:Quippe.Coding.CodeRelationship"/> instance defining the relationship derived from the two relationships in the base maps that 
 represents the best estimate of the relationship between the source and target concepts in the external vocabularies referenced by the composite map.</returns>
	<remarks>
		<para>A composite map is created by a code translation from one external (non-Medcin) vocabulary to another. The coding service uses Medicomp's
 base mappings from Medcin to external vocabularies such as ICD-10-CM and SNOMED to infer a relationship between a source and target concept in
 two different external vocabularies (e.g., SNOMED to ICD-10-CM). The base mappings are created and reviewed by Medicomp staff to deliberately
 establish relationships FROM Medcin concepts TO concepts in external vocabularies. That is, all relationships in base maps are defined with the
 Medcin concept as source and the external concept as target. Any relationships between two concepts in external vocabularies
 must be inferred from the relationships in the base maps.</para>
		<para>Two base maps from a common intermediate Medcin concept are needed to create a composite map. The source relationship is the relationship 
 between the source external concept and the intermediate Medcin concept, but semantically the direction is from Medcin to the external concept.
 For example, a source relationship of "Narrower Than" between an external concept and a Medcin concept means the Medcin concept is narrower in
 clinical meaning than the external concept. The target relationship is the relationship between (from) the intermediate Medcin concept and (to)
 the target external concept. 
 </para>
		<para>This function takes two deliberately defined relationship from two base maps and created a derived relationship that is the best estimate
 of the relationship between the source concept in the source external vocabulary and the target concept in the target external vocabulary.</para>
	</remarks>
</member><member name="M:Quippe.Coding.CodeRelationship.Clone">
	<summary>
 Returns a deep copy of this instance of CodeRelationship.
 </summary>
</member><member name="T:Quippe.Coding.CodeRelationship">
	<summary>
 Class representing the code mapping relationships that may exist between pairs of clinical codes, a source and
 target code, in two coding system (or medical terminology) vocabularies.
 </summary>
	<remarks><para>CodeRelationship instances define the code mapping relationships that exist between a source code in a 
 vocabulary (as represented by a source code entry such as a <see cref="T:Quippe.Coding.MedcinCodeEntry"/> instance) to a target code 
 in another vocabulary (as represented by a target code entry such as a <see cref="T:Quippe.Coding.ExternalCodeEntry"/> instance). 
 The relationships are defined by the code mappings provided by an
 <see cref="T:Quippe.Coding.ITranslator"/> derived provider. For instance, Medicomp supplies an ITranslator provider, 
 <see cref="T:Quippe.Coding.StandardTranslator"/>,
 that includes Medicomp's mappings from MEDCIN to a variety of external coding system vocabularies, including
 ICD-9-CM, SNOMED-CT, RxNorm, etc. Each mapping between a MEDCIN concept and a concept in an external vocabulary
 is qualified by a relationship ID that indicates the type of relationship deemed to exist between the two
 concepts. Typical code relationships include the primary defining relationships, "Same As, "Narrower Than", and 
 "Broader Than" as well as various secondary relationships, including those defined within the SNOMED-CT system. 
 </para>
		<para>A standard collection of code relationships are defined by this class in an internal collection. These standard
 relationships are accessible through the shared members of this class by specifying either the relationship name 
 (e.g., "Same As"), the relationship Id (e.g., integer value 1), or by using the generated properties (e.g., SameAs
 property). However, the class always returns a copy of the standard relationship, thus ensuring it cannot be
 modified. If additional relationships need to be defined to support mappings provided by other ITranslator
 providers, or if a standard relationship needs to be modified, then additional CodeRelationship instances can be 
 created and stored external to this class.</para>
		<para>The standard relationships are created by generated code (a Partial class) in CodeRelationshipsGenerated.vb. This 
 code is generated from the Coding Service Database by the CodeGenerator.Generator project.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.MapEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="F:Quippe.Coding.TranslatorException.TranslationLocationEnum.NotApplicable">
	<summary>The problem did not occur during translation or the location is unknown.</summary>
</member><member name="F:Quippe.Coding.TranslatorException.TranslationLocationEnum.Source">
	<summary>The exception is associated with the source (e.g. source <see cref="T:Quippe.Coding.CodeEntry"/>) in an attempted translation.</summary>
</member><member name="F:Quippe.Coding.TranslatorException.TranslationLocationEnum.Target">
	<summary>The exception is associated with the target (e.g. target <see cref="T:Quippe.Coding.CodeEntry"/>) in an attempted translation.</summary>
</member><member name="T:Quippe.Coding.TranslatorException.TranslationLocationEnum">
	<summary>
 Type indicating the location of the problem, if it occurred during translation.
 </summary>
</member><member name="M:Quippe.Coding.TranslatorException.#ctor(System.String,System.Type,Quippe.Coding.CodingException.ExceptionTypeEnum,System.String,Quippe.Coding.TranslatorException.TranslationLocationEnum)">
	<summary>
 Creates a new TranslatorException based on an exception message, translator Type and optional parameters.
 </summary>
	<param name="Message">The exception message.</param>
	<param name="TranslatorType">The Type of the translator in which the exception occurred.</param>
	<param name="ExceptionType">An optional type further clarifying the exception.</param>
	<param name="Value">An optional value, usually associated with the ExceptionType, that further clarifies the exception.</param>
	<param name="Location">A value indicating the location of the problem during translation, or the default if not a translation problem or unknown.</param>
</member><member name="M:Quippe.Coding.TranslatorException.#ctor(System.String,System.Exception,System.Type,Quippe.Coding.CodingException.ExceptionTypeEnum,System.String,Quippe.Coding.TranslatorException.TranslationLocationEnum)">
	<summary>
 Creates a new TranslatorException based on an existing exception.
 </summary>
	<param name="Message">The exception message.</param>
	<param name="InnerException">An associated exception, usually the original exception that caused this TranslatorException to be raised.</param>
	<param name="TranslatorType">The Type of the translator in which the exception occurred.</param>
	<param name="ExceptionType">An optional type further clarifying the exception.</param>
	<param name="Value">An optional value, usually associated with the ExceptionType, that further clarifies the exception.</param>
	<param name="Location">A value indicating the location of the problem during translation, or the default if not a translation problem or unknown.</param>
</member><member name="P:Quippe.Coding.TranslatorException.TranslatorName">
	<summary>
 Gets the type name of the translation provider implementing <see cref="T:Quippe.Coding.ITranslator"/> in which the exception was thrown or the problem was found.
 </summary>
</member><member name="P:Quippe.Coding.TranslatorException.TranslatorType">
	<summary>
 Gets the Type of the translation provider implementing <see cref="T:Quippe.Coding.ITranslator"/> in which the exception was thrown or the problem was found.
 </summary>
</member><member name="P:Quippe.Coding.TranslatorException.Location">
	<summary>
 Gets a value indicating the location of the problem during translation as specified in the constructor.
 </summary>
</member><member name="T:Quippe.Coding.TranslatorException">
	<summary>
 Class representing a generic exception occurring in a coding translator implementing the <see cref="T:Quippe.Coding.ITranslator"/> interface.
 </summary>
	<remarks>Exceptions of this type are typically problems found in translator initialization or during translation.
 If the problem occurred during translation, then the location can be specified as either the source or target
 (<see cref="T:Quippe.Coding.CodeEntry"/>). The Type of the translator that caused the problem is required to define this exception.</remarks>
</member><member name="M:Quippe.Coding.TranslatorArgumentException.#ctor(System.String,System.Type,Quippe.Coding.CodingException.ExceptionTypeEnum,System.String,System.String)">
	<summary>
 Creates a new TranslatorArgumentException from the specified Message, translator Type, and optional parameters.
 </summary>
	<param name="Message">The exception message.</param>
	<param name="TranslatorType">The Type of the translator in which the exception occurred.</param>
	<param name="ExceptionType">An optional type further clarifying the exception.</param>
	<param name="ArgumentName">The name of the argument associated with the exception.</param>
	<param name="ArgumentValue">The value of the argument associated with the exception.</param>
	<remarks>The Value property of the base class is set to the value specified in ArgumentValue.</remarks>
</member><member name="M:Quippe.Coding.TranslatorArgumentException.#ctor(System.String,System.Exception,System.Type,Quippe.Coding.CodingException.ExceptionTypeEnum,System.String,System.String)">
	<summary>
 Creates a new TranslatorArgumentException based on an existing exception.
 </summary>
	<param name="Message">The exception message.</param>
	<param name="InnerException">An associated exception, usually the original exception that caused this TranslatorArgumentException to be raised.</param>
	<param name="TranslatorType">The Type of the translator in which the exception occurred.</param>
	<param name="ExceptionType">An optional type further clarifying the exception.</param>
	<param name="ArgumentName">The name of the argument associated with the exception.</param>
	<param name="ArgumentValue">The value of the argument associated with the exception.</param>
	<remarks>The Value property of the base class is set to the value specified in ArgumentValue.</remarks>
</member><member name="P:Quippe.Coding.TranslatorArgumentException.ArgumentName">
	<summary>
 Gets the argument name specified in the constructor.
 </summary>
</member><member name="P:Quippe.Coding.TranslatorArgumentException.ArgumentValue">
	<summary>
 Gets the argument value specified in the constructor.
 </summary>
</member><member name="T:Quippe.Coding.TranslatorArgumentException">
	<summary>
 Class representing an exception associated with a method or property argument in a coding translator implementing the <see cref="T:Quippe.Coding.ITranslator"/> interface.
 </summary>
</member><member name="M:Quippe.Coding.TranslationException.#ctor(System.String,System.Type,System.String,System.String,Quippe.Coding.CodingException.ExceptionTypeEnum,System.String,Quippe.Coding.TranslatorException.TranslationLocationEnum)">
	<summary>
 Creates a new TranslationException based on an exception message, a translator Type, and the source and target vocabulary codes involved in the translation.
 </summary>
	<param name="Message">The exception message.</param>
	<param name="TranslatorType">The Type of the translator in which the exception occurred.</param>
	<param name="SourceVocabCode">Unique code of the coding vocabulary (i.e., the <see cref="T:Quippe.Coding.CodeSet"/>) of the source code that was to be translated.</param>
	<param name="TargetVocabCode">Unique code of the coding vocabulary (i.e., the <see cref="T:Quippe.Coding.CodeSet"/>) that was the target of the translation.</param>
	<param name="ExceptionType">An optional type further clarifying the exception.</param>
	<param name="Value">An optional value, usually associated with the ExceptionType, that further clarifies the exception.</param>
	<param name="Location">A value indicating the location of the problem during translation, or the default if not a translation problem or unknown.</param>
</member><member name="M:Quippe.Coding.TranslationException.#ctor(System.String,System.Exception,System.Type,System.String,System.String,Quippe.Coding.CodingException.ExceptionTypeEnum,System.String,Quippe.Coding.TranslatorException.TranslationLocationEnum)">
	<summary>
 Creates a new TranslationException based on an existing exception.
 </summary>
	<param name="Message">The exception message.</param>
	<param name="InnerException">An associated exception, usually the original exception that caused this TranslatorArgumentException to be raised.</param>
	<param name="TranslatorType">The Type of the translator in which the exception occurred.</param>
	<param name="SourceVocabCode">Unique code of the coding vocabulary (i.e., the <see cref="T:Quippe.Coding.CodeSet"/>) of the source code that was to be translated.</param>
	<param name="TargetVocabCode">Unique code of the coding vocabulary (i.e., the <see cref="T:Quippe.Coding.CodeSet"/>) that was the target of the translation.</param>
	<param name="ExceptionType">An optional type further clarifying the exception.</param>
	<param name="Value">An optional value, usually associated with the ExceptionType, that further clarifies the exception.</param>
	<param name="Location">A value indicating the location of the problem during translation, or the default if not a translation problem or unknown.</param>
</member><member name="P:Quippe.Coding.TranslationException.SourceVocabCode">
	<summary>
 Gets the unique code of the coding vocabulary (i.e., the <see cref="T:Quippe.Coding.CodeSet"/>) of the source code that was to be translated.
 </summary>
</member><member name="P:Quippe.Coding.TranslationException.TargetVocabCode">
	<summary>
 Gets the unique code of the coding vocabulary that was the target of the translation.
 </summary>
</member><member name="T:Quippe.Coding.TranslationException">
	<summary>
 Class representing an exception occurring during translation by a translation provider implementing the <see cref="T:Quippe.Coding.ITranslator"/> interface.
 </summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.Unspecified">
	<summary>The exception type is not specified or a suitable type is not available.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.Code">
	<summary>A problem was found that was associated with a clinical concept code (e.g., source code in translation).</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.CodingQualifier">
	<summary>A problem was found that was associated with a MapQualifier.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.Initialization">
	<summary>An exception was thrown during initialization (e.g., coding service initialization).</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.MedcinId">
	<summary>A problem was found that was associated with a MedcinId.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.Parameter">
	<summary>A problem was found that was associated with a coding translation parameter.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.Prefix">
	<summary>A problem was found that was associated with a Prefix.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.Service">
	<summary>A generic coding service problem was encountered.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.Source">
	<summary>A problem with the translation source was encountered.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.Specifier">
	<summary>A problem with a specifier was encountered.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.Target">
	<summary>A problem with the translation target was encountered.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.Translator">
	<summary>A generic translator problem was encountered.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.TermType">
	<summary>A problem was found that was associated with a TermType.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.VocabCode">
	<summary>A problem was found that was associated with a vocabulary.</summary>
</member><member name="F:Quippe.Coding.CodingException.ExceptionTypeEnum.VocabVersion">
	<summary>A problem was found that was associated with a vocabulary version.</summary>
</member><member name="T:Quippe.Coding.CodingException.ExceptionTypeEnum">
	<summary>
 Represents the type of coding exceptions that can occur.
 </summary>
</member><member name="M:Quippe.Coding.CodingException.#ctor(System.String,Quippe.Coding.CodingException.ExceptionTypeEnum,System.String)">
	<summary>
 Creates a new CodingException by specifying the exception message and optional exception type and associated value.
 </summary>
	<param name="Message">The exception message.</param>
	<param name="ExceptionType">An optional type further clarifying the exception.</param>
	<param name="Value">An optional value, usually associated with the ExceptionType, that further clarifies the exception.</param>
</member><member name="M:Quippe.Coding.CodingException.#ctor(System.String,System.Exception,Quippe.Coding.CodingException.ExceptionTypeEnum,System.String)">
	<summary>
 Creates a new CodingException based on an existing exception.
 </summary>
	<param name="Message">The exception message.</param>
	<param name="InnerException">An associated exception, usually the original exception that caused this CodingException to be raised.</param>
	<param name="ExceptionType">An optional type further clarifying the exception.</param>
	<param name="Value">An optional value, usually associated with the ExceptionType, that further clarifies the exception.</param>
</member><member name="P:Quippe.Coding.CodingException.ExceptionType">
	<summary>
 Gets the optional ExceptionType assocated with this exception.
 </summary>
</member><member name="P:Quippe.Coding.CodingException.Value">
	<summary>
 Gets the optional String value assocated with this exception.
 </summary>
</member><member name="T:Quippe.Coding.CodingException">
	<summary>
 Class representing a generic exception in Quippe.Coding.
 </summary>
	<remarks>Exceptions are defined by a String message, an optional exception type and a value, usually associated
 with the type, that further clarifies the reason for the exception. For example, an exception of type "VersionName"
 would indicate an exception associated with a vocabulary version (e.g., version is not unique) and the value would
 likely be set to the version name.</remarks>
</member><member name="M:Quippe.Coding.CodingArgumentException.#ctor(System.String,Quippe.Coding.CodingException.ExceptionTypeEnum,System.String,System.String)">
	<summary>
 Creates a new CodingArgumentException from the specified Message and optional parameters.
 </summary>
	<param name="Message">The exception message.</param>
	<param name="ExceptionType">An optional type further clarifying the exception.</param>
	<param name="ArgumentName">The name of the argument associated with the exception.</param>
	<param name="ArgumentValue">The value of the argument associated with the exception.</param>
	<remarks>The Value property of the base class is set to the value specified in ArgumentValue.</remarks>
</member><member name="M:Quippe.Coding.CodingArgumentException.#ctor(System.String,System.Exception,Quippe.Coding.CodingException.ExceptionTypeEnum,System.String,System.String)">
	<summary>
 Creates a new CodingArgumentException based on an existing exception.
 </summary>
	<param name="Message">The exception message.</param>
	<param name="InnerException">An associated exception, usually the original exception that caused this CodingArgumentException to be raised.</param>
	<param name="ExceptionType">An optional type further clarifying the exception.</param>
	<param name="ArgumentName">The name of the argument associated with the exception.</param>
	<param name="ArgumentValue">The value of the argument associated with the exception.</param>
	<remarks>The Value property of the base class is set to the value specified in ArgumentValue.</remarks>
</member><member name="P:Quippe.Coding.CodingArgumentException.ArgumentName">
	<summary>
 Gets the argument name specified in the constructor.
 </summary>
</member><member name="P:Quippe.Coding.CodingArgumentException.ArgumentValue">
	<summary>
 Gets the argument value specified in the constructor.
 </summary>
</member><member name="T:Quippe.Coding.CodingArgumentException">
	<summary>
 Class representing an exception associated with a method or property argument in Medcin.Coding.
 </summary>
</member><member name="M:Quippe.Coding.Specifier.Clone">
	<summary>
 Function a derived class must override to returns a deep copy of the instance.
 </summary>
</member><member name="M:Quippe.Coding.MedcinSpecifiers.Clone">
	<summary>
 Returns a deep copy of this MedcinSpecifiers instance.
 </summary>
</member><member name="M:Quippe.Coding.MedcinSpecifiers.#ctor(Quippe.Coding.MedcinSpecifiers)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The MedcinSpecifiers instance to copy when creating a new instance.</param>
</member><member name="T:Quippe.Coding.MedcinSpecifiers">
	<summary>
 Class representing a specification string that qualifies a Medcin concept.
 </summary>
	<remarks><para>This class is the representation of a parsed specification string that qualifies a Medcin concept
 for use in code mapping and translation to and from specific target vocabularies. The specification string 
 is used to construct the MedcinSpecifier and consists of at most one specifier for each vocabulary that
 supports specifiers. At present, specifiers are used with ICD-10-CM and DSM, and therefore a MedcinSpecifier
 will contain at most two specifiers.</para>
	</remarks>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.#ctor(System.Int32)">
	<summary>
 Creates a new MedcinCodeEntry object from the specified base MEDCIN concept.
 </summary>
	<param name="MedcinId">The unique identifier of the MEDCIN concept.</param>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.#ctor(System.Int32,System.String)">
	<summary>
 Creates a new MedcinCodeEntry object from the specified MEDCIN concept qualified by a prefix.
 </summary>
	<param name="MedcinId">The unique integer identifier of the MEDCIN concept associated with this coded entry.</param>
	<param name="Prefix">A MEDCIN prefix code that qualifies the meaning of the base MEDCIN concept.</param>
	<remarks>
		<para>The Prefix parameter is the prefix code of an instance of <see cref="T:Quippe.Coding.Prefix"/> associated with the MEDCIN
 vocabulary. Only certain MEDCIN prefixes are available for use in code mapping and may be obtained from a Medicomp
 translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/> method using the MEDCIN
 vocabulary code, "medcin". Use the property, <see cref="P:Quippe.Coding.Vocabulary.Prefixes"/> to obtain the collection of available 
 prefixes. The property <see cref="P:Quippe.Coding.Prefix.Code"/> provides access to the MEDCIN prefix code.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.#ctor(System.Int32,System.String,System.String)">
	<summary>
 Creates a new MedcinCodeEntry object from the specified MEDCIN base concept qualified by a prefix, and
 including a textual description of the base concept.
 </summary>
	<param name="MedcinId">The unique integer identifier of the MEDCIN concept associated with this coded entry.</param>
	<param name="Prefix">A MEDCIN prefix code that qualifies the meaning of the base MEDCIN concept.</param>
	<param name="Description">A text description of the base MEDCIN concept.</param>
	<remarks>
		<para>The Prefix parameter is the prefix code of an instance of <see cref="T:Quippe.Coding.Prefix"/> associated with the MEDCIN
 vocabulary. Only certain MEDCIN prefixes are available for use in code mapping and may be obtained from a Medicomp
 translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/> method using the MEDCIN
 vocabulary code, "medcin". Use the property, <see cref="P:Quippe.Coding.Vocabulary.Prefixes"/> to obtain the collection of available 
 prefixes. The property <see cref="P:Quippe.Coding.Prefix.Code"/> provides access to the MEDCIN prefix code.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.#ctor(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String)">
	<summary>
 Creates a new MedcinCodeEntry object from the specified MEDCIN base concept qualified by a prefix, status
 qualifier, modifier and result and including a textual description of the base concept.
 </summary>
	<param name="MedcinId">The unique integer identifier of the MEDCIN concept associated with this coded entry.</param>
	<param name="Prefix">A MEDCIN prefix that qualifies the meaning of the base MEDCIN concept.</param>
	<param name="Description">A text description of the base MEDCIN concept.</param>
	<param name="StatusQualifierCode">The unique string name (i.e., code) of the MEDCIN status qualifier.</param>
	<param name="ModifierCode">The unique string name (i.e., code) of the MEDCIN modifier.</param>
	<param name="ResultCode">The unique string name (i.e., code) of the result qualifier.</param>
	<param name="SpecificationString">A string describing additional specifier list/table selections that further qualify the base MEDCIN concept, such
 as might be used to indicate laterality and encounter information to obtain a billable ICD-10-CM code from the unbillable ICD-10-CM code mapped to 
 the base concept.</param>
	<remarks>
		<para>The Prefix parameter is the prefix code of an instance of <see cref="T:Quippe.Coding.Prefix"/> associated with the MEDCIN
 vocabulary. Only certain MEDCIN prefixes are available for use in code mapping and may be obtained from a Medicomp
 translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/> method using the MEDCIN
 vocabulary code, "medcin". Use the property, <see cref="P:Quippe.Coding.Vocabulary.Prefixes"/> to obtain the collection of available 
 prefixes. The property <see cref="P:Quippe.Coding.Prefix.Code"/> provides access to the MEDCIN prefix code.</para>
		<para>The StatusQualifierCode, ModifierCode and ResultCode parameters are unique string codes that identify the 
 desired optional MEDCIN qualifiers that are applied to the MEDCIN concept to alter or qualify its meaning.
 The qualifiers are represented internally by instances of the <see cref="T:Quippe.Coding.CodingQualifier"/> class and 
 the enum values from <see cref="T:Quippe.Coding.CodingQualifier.QualifierTypeEnum"/> identify the type of qualifier. For instance, 
 a status qualifier is a CodingQualifier of type <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.MedcinStatus"/>. 
 Status qualifier, modifier and result qualifier objects, valid for code mapping, may be obtained from a Medicomp 
 translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/>
 method using the MEDCIN vocabulary code, "medcin", and then using the property <see cref="P:Quippe.Coding.Vocabulary.Qualifiers(Quippe.Coding.CodingQualifier.QualifierTypeEnum)"/> to 
 obtain a collection of qualifiers by specified qualifier type.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.#ctor(System.Int32,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Int32,System.String)">
	<summary>
 Creates a new MedcinCodeEntry object from the specified MEDCIN base concept qualified by a prefix, status
 qualifier, modifier and result and including a textual description of the base concept.
 </summary>
	<param name="MedcinId">The unique integer identifier of the MEDCIN concept associated with this coded entry.</param>
	<param name="Prefix">A MEDCIN prefix that qualifies the meaning of the base MEDCIN concept.</param>
	<param name="Description">A text description of the base MEDCIN concept.</param>
	<param name="StatusQualifierCode">The unique string name (i.e., code) of the MEDCIN status qualifier.</param>
	<param name="ModifierCode">The unique string name (i.e., code) of the MEDCIN modifier.</param>
	<param name="ResultCode">The unique string name (i.e., code) of the result qualifier.</param>
	<param name="SpecificationString">A string describing additional specifier list/table selections that further qualify the base MEDCIN concept, such
 as might be used to indicate laterality and encounter information to obtain a billable ICD-10-CM code from the unbillable ICD-10-CM code mapped to 
 the base concept.</param>
	<param name="Value">A specific numeric test value of the finding passed as a String in the standard unit for the finding.</param>
	<param name="Age">The age of the patient in minutes. A valid Age must be greater than 0.</param>
	<param name="Sex">The sex of the patient, either "F" for female, "M" for male or "U" for unknown.</param>
	<remarks>
		<para>The Prefix parameter is the prefix code of an instance of <see cref="T:Quippe.Coding.Prefix"/> associated with the MEDCIN
 vocabulary. Only certain MEDCIN prefixes are available for use in code mapping and may be obtained from a Medicomp
 translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/> method using the MEDCIN
 vocabulary code, "medcin". Use the property, <see cref="P:Quippe.Coding.Vocabulary.Prefixes"/> to obtain the collection of available 
 prefixes. The property <see cref="P:Quippe.Coding.Prefix.Code"/> provides access to the MEDCIN prefix code.</para>
		<para>The StatusQualifierCode, ModifierCode and ResultCode parameters are unique string codes that identify the 
 desired optional MEDCIN qualifiers that are applied to the MEDCIN concept to alter or qualify its meaning.
 The qualifiers are represented internally by instances of the <see cref="T:Quippe.Coding.CodingQualifier"/> class and 
 the enum values from <see cref="T:Quippe.Coding.CodingQualifier.QualifierTypeEnum"/> identify the type of qualifier. For instance, 
 a status qualifier is a CodingQualifier of type <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.MedcinStatus"/>. 
 Status qualifier, modifier and result qualifier objects, valid for code mapping, may be obtained from a Medicomp 
 translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/>
 method using the MEDCIN vocabulary code, "medcin", and then using the property <see cref="P:Quippe.Coding.Vocabulary.Qualifiers(Quippe.Coding.CodingQualifier.QualifierTypeEnum)"/> to 
 obtain a collection of qualifiers by specified qualifier type.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.#ctor(System.Int32,System.String,System.String,Quippe.Coding.CodingQualifier,Quippe.Coding.CodingQualifier,Quippe.Coding.CodingQualifier,System.String,Quippe.Coding.TermType,System.String)">
	<summary>
 Creates a new MedcinCodeEntry object from the specified MEDCIN base concept qualified by a prefix and status
 qualifier, and including a textual description of the base concept and additional optional parameters.
 </summary>
	<param name="MedcinId">The unique integer identifier of the MEDCIN concept associated with this coded entry.</param>
	<param name="Prefix">A MEDCIN prefix code that qualifies the meaning of the base MEDCIN concept.</param>
	<param name="Description">A text description of the base MEDCIN concept.</param>
	<param name="StatusQualifier">Reference to a status qualifier object that qualifies the meaning of the base MEDCIN concept via a MEDCIN status qualifier.</param>
	<param name="Modifier">Reference to a modifier qualifier object that qualifies the meaning of the base MEDCIN concept via a MEDCIN modifier.</param>
	<param name="Result">Reference to a result qualifier object that qualifies the meaning of the base MEDCIN concept via a MEDCIN result qualifier.</param>
	<param name="SpecificationString">A string describing additional specifier list/table selections that further qualify the base MEDCIN concept, such
 as might be used to indicate laterality and encounter information to obtain a billable ICD-10-CM code from the unbillable ICD-10-CM code mapped to 
 the base concept.</param>
	<param name="TermType">An optional term type associated with the base MEDCIN concept.</param>
	<param name="NodeKey">The optional node key associated with the base MEDCIN concept.</param>
	<remarks>
		<para>The Prefix parameter is the prefix code of an instance of <see cref="T:Quippe.Coding.Prefix"/> associated with the MEDCIN
 vocabulary. Only certain MEDCIN prefixes are available for use in code mapping and may be obtained from a Medicomp
 translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/> method using the MEDCIN
 vocabulary code, "medcin". Use the property, <see cref="P:Quippe.Coding.Vocabulary.Prefixes"/> to obtain the collection of available 
 prefixes. The property <see cref="P:Quippe.Coding.Prefix.Code"/> provides access to the MEDCIN prefix code.</para>
		<para>The StatusQualifier, Modifier and Result parameters are instances of the <see cref="T:Quippe.Coding.CodingQualifier"/> class
 containing the appropriate enum value from <see cref="T:Quippe.Coding.CodingQualifier.QualifierTypeEnum"/> to identify the type of qualifier.
 These parameters identify the optional MEDCIN qualifiers that are applied to the underlying MEDCIN concept to alter or
 qualify its meaning.
 Status qualifier, modifier and result qualifier objects, valid for code mapping, may be obtained from a Medicomp 
 translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/>
 method using the MEDCIN vocabulary code, "medcin", and then using the property <see cref="P:Quippe.Coding.Vocabulary.Qualifiers(Quippe.Coding.CodingQualifier.QualifierTypeEnum)"/> to 
 obtain a collection of qualifiers by specified qualifier type.
 </para>
		<para>The TermType parameter is an instance of <see cref="P:Quippe.Coding.CodeEntry.TermType"/>. Term type objects valid for MEDCIN may be obtained
 from a Medicomp translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/>
 method using the MEDCIN vocabulary code, "medcin", and then using the property <see cref="P:Quippe.Coding.Vocabulary.TermTypes"/> to 
 obtain a collection of qualifiers by specified qualifier type.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.Clone">
	<summary>
 Returns a deep copy of this MedcinCodeEntry instance.
 </summary>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.#ctor(Quippe.Coding.MedcinCodeEntry)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The MedcinCodeEntry instance to copy when creating a new instance.</param>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.MedcinId">
	<summary>
 Gets or sets the unique integer identifier of the associated concept within the MEDCIN vocabulary.
 </summary>
	<remarks>
		<para>The standard MEDCIN vocabulary is available from the property, <see cref="P:Quippe.Coding.Vocabularies.MedcinVocab"/>.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.PrefixCode">
	<summary>
 Gets or sets the String code defining an optional prefix that qualifies the underlying concept represented by the MedcinId.
 </summary>
	<remarks>
		<para>When a prefix code is specified, this code entry actually represents a new concept derived from the underlying MEDCIN
 concept by applying the qualification associated with the prefix code. For instance, the prefix code "H" represents
 "History of" the underlying concept defined by the MedcinId.</para>
		<para>The PrefixCode property is the prefix code of an instance of <see cref="T:Quippe.Coding.Prefix"/> associated with the MEDCIN
 vocabulary. Only certain MEDCIN prefixes are available for use in code mapping and may be obtained from a Medicomp
 translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/> method using the MEDCIN
 vocabulary code, "medcin". Use the property, <see cref="P:Quippe.Coding.Vocabulary.Prefixes"/> to obtain the collection of available 
 prefixes. The property <see cref="P:Quippe.Coding.Prefix.Code"/> provides access to the MEDCIN prefix code.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.StatusQualifier">
	<summary>
 Gets or sets the qualifier object defining an optional status qualifier that qualifies the underlying MEDCIN concept represented by the MedcinId.
 </summary>
	<remarks>
		<para>If a MEDCIN status qualifier is defined for this MedcinCodeEntry, the modifier alters or qualifies the meaning of the underlying MEDCIN concept.
 The MEDCIN concept is not qualified by a status qualifier if this property returns Nothing.</para>
		<para>The StatusQualifier property value is an instance of <see cref="T:Quippe.Coding.CodingQualifier"/> and has the qualifier type,
 <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.MedcinStatus"/>. Status qualifier objects valid for code mapping may be 
 obtained from a Medicomp translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/>
 method using the MEDCIN vocabulary code, "medcin", and then using the property <see cref="P:Quippe.Coding.Vocabulary.Qualifiers(Quippe.Coding.CodingQualifier.QualifierTypeEnum)"/> to 
 obtain a collection of qualifiers by specified qualifier type.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.Modifier">
	<summary>
 Gets or sets the qualifier object defining an optional modifier that qualifies the underlying MEDCIN concept represented by the MedcinId.
 </summary>
	<remarks>
		<para>If a MEDCIN modifier is defined for this MedcinCodeEntry, the modifier alters or qualifies the meaning of the underlying MEDCIN concept.
 The MEDCIN concept is not qualified by a modifier if this property returns Nothing.</para>
		<para>The Modifier property value is an instance of <see cref="T:Quippe.Coding.CodingQualifier"/> and has the qualifier type,
 <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Modifier"/>. Modifier objects valid for code mapping may be 
 obtained from a Medicomp translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/>
 method using the MEDCIN vocabulary code, "medcin", and then using the property <see cref="P:Quippe.Coding.Vocabulary.Qualifiers(Quippe.Coding.CodingQualifier.QualifierTypeEnum)"/> to 
 obtain a collection of qualifiers by specified qualifier type.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.Result">
	<summary>
 Gets or sets the qualifier object defining an optional result that qualifies the underlying MEDCIN concept represented by the MedcinId as 
 either "normal" or "abnormal".
 </summary>
	<remarks>
		<para>If a result qualifier is defined for this MedcinCodeEntry, the result may alter or qualify the meaning of the underlying MEDCIN concept
 to include a qualification of "normal" or "abnormal". The MEDCIN concept is not qualified by a result qualifier if this property returns Nothing
 and would therefore have the default meaning of the underlying concept.</para>
		<para>The Result property value is an instance of <see cref="T:Quippe.Coding.CodingQualifier"/> and has the qualifier type,
 <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Result"/>. Result qualifier objects valid for code mapping may be 
 obtained from a Medicomp translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/>
 method using the MEDCIN vocabulary code, "medcin", and then using the property <see cref="P:Quippe.Coding.Vocabulary.Qualifiers(Quippe.Coding.CodingQualifier.QualifierTypeEnum)"/> to 
 obtain a collection of qualifiers by specified qualifier type.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.StatusQualifierCode">
	<summary>
 Gets the unique code (or name) of the optional MEDCIN status qualifier of the MEDCIN concept. 
 </summary>
	<returns>Returns the string code of the associated status qualifier, if the <see cref="P:Quippe.Coding.MedcinCodeEntry.StatusQualifier"/> property is defined
 (i.e., is not Nothing), otherwise returns the empty string.</returns>
	<remarks>The status qualifier's unique string "code" is the same as its name, which is given by the <see cref="P:Quippe.Coding.CodingQualifier.Name"/>
 property of the status qualifier instance associated with this code entry.
 </remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.ModifierCode">
	<summary>
 Gets the unique code (or name) of the optional MEDCIN modifier qualifier of the MEDCIN concept. 
 </summary>
	<returns>Returns the string code of the associated modifier qualifier, if the <see cref="P:Quippe.Coding.MedcinCodeEntry.Modifier"/> property is defined
 (i.e., is not Nothing), otherwise returns the empty string.</returns>
	<remarks>The modifier qualifier's unique string "code" is the same as its name, which is given by the <see cref="P:Quippe.Coding.CodingQualifier.Name"/>
 property of the modifier qualifier instance associated with this code entry.
 </remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.ResultCode">
	<summary>
 Gets the unique code (or name) of the optional MEDCIN result qualifier of the MEDCIN concept. 
 </summary>
	<returns>Returns the string code of the associated result qualifier, if the <see cref="P:Quippe.Coding.MedcinCodeEntry.Result"/> property is defined
 (i.e., is not Nothing), otherwise returns the empty string.</returns>
	<remarks>The result qualifier's unique string "code" is the same as its name, which is given by the <see cref="P:Quippe.Coding.CodingQualifier.Name"/>
 property of the result qualifier instance associated with this code entry.
 </remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.NodeKey">
	<summary>
 Gets or sets the optional Node Key of this Medcin code entry. 
 </summary>
	<returns><para>The NodeKey property is optional, for information only, and has no effect on the Medcin code mappings.</para></returns>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.HasQualifiers">
	<summary>
 Indicates whether the Medcin entry has any qualifiers, that is, whether any of the StatusQualifier, Modifier or Result properties are set.
 </summary>
	<returns>Returns True if any one of the StatusQualifier, Modifier or Result properties returns a instance of <see cref="T:Quippe.Coding.CodingQualifier"/>, indicating the
 Medcin entry has at least one qualifier set. Returns False if all three qualifier properties return Nothing, indicating that no qualifiers
 are set.</returns>
	<remarks>Note, the Medcin prefix is not considered a qualifier and has no bearing on the result of this function.</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.SpecifiedQualifierCount">
	<summary>
 Gets a count of the Medcin qualifiers that were explicitly specified.
 </summary>
	<value>The number of Medcin qualifiers that were specified (i.e., are not Nothing)</value>
	<remarks>Medcin qualifiers considered in the count are Status, Modifier and Result.</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.SpecificationString">
	<summary>
 Gets or sets the specifier qualifier string associated with this Medcin code entry. 
 </summary>
	<value><para>The specification string containing one or more specifiers that provide additional qualification of the 
 Medcin code entry specific to one or more referenced external vocabularies (e.g., ICD-10-CM and DSM).</para></value>
	<remarks><para></para></remarks>
	<exception cref="T:Quippe.Coding.CodingException">Thrown if the specification string is empty or improperly formatted.</exception>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Specifier"/>
	<seealso cref="T:Quippe.Coding.MedcinSpecifiers"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.HasSpecifiers">
	<summary>
 Indicates whether this Medcin code entry has associated specifiers.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Specifier"/>
	<seealso cref="T:Quippe.Coding.MedcinSpecifiers"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.Age">
	<summary>
 Gets or sets the age of the patient, in minutes.
 </summary>
	<value>The specific age of the patient associated with the Medcin entry, in minutes.</value>
	<remarks>
		<para>The Medcin entry may have a single specific patient age value and/or an age range as defined by the <see cref="P:Quippe.Coding.MedcinCodeEntry.StartAge"/> and <see cref="P:Quippe.Coding.MedcinCodeEntry.EndAge"/> properties.
 The specific patient age is typically an input to a translation from Medcin to an external vocabulary, whereas the age range
 is typically the result of a translation, from or to the Medcin vocabulary, and is taken from the range in the mapping 
 record. When age is relevant to a mapping from Medcin to an external vocabulary, the mapping record specifies an age range.
 When a specific age is presented as input to a translation, the resulting map, if it is age qualified, has an age range in
 the mapping record. Both the input age in the translation request and the age range in the mapping record may be needed for
 further processing after the translation and therefore the MedcinCodeEntry accomodates both.
 </para>
		<para>The age qualifies the underlying concept represented by the MedcinId. When a patient age is specified, this code entry 
 actually represents a new concept derived from the underlying MEDCIN
 concept by applying the limitation to the patients' age. For example, age, along with sex and value, may be used to qualify
 the body mass index concept to return a specific billable code in ICD-9-CM or ICD-10-CM.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.StartAge">
	<summary>
 Gets the start age of the age range associated with this Medcin code entry.
 </summary>
	<value>The start age of the age range associated with this Medcin code entry.</value>
	<remarks>
		<para>See the <see cref="P:Quippe.Coding.MedcinCodeEntry.Age"/> property for more information regarding the age range versus the specific age value.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.EndAge"/>
	<seealso cref="M:Quippe.Coding.MedcinCodeEntry.SetAgeRange(System.Int32,System.Int32)"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.EndAge">
	<summary>
 Gets the end age of the age range associated with this Medcin code entry.
 </summary>
	<value>The end age of the age range associated with this Medcin code entry.</value>
	<remarks>
		<para>A valid age range has a start age of zero or greater and an end age greater than the start age. The end age 
 defines the upper limit of the range, but is not considered part of the range.</para>
		<para>See the <see cref="P:Quippe.Coding.MedcinCodeEntry.Age"/> property for more information on age range versus specific age value.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.StartAge"/>
	<seealso cref="M:Quippe.Coding.MedcinCodeEntry.SetAgeRange(System.Int32,System.Int32)"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.DisplayAge(System.String,System.Int32)">
	<summary>
 Gets the age of the patient, in the specified time units (default minutes), as a string for display.
 </summary>
	<param name="TimeFormat">The desired units of time in which to return the age (default is "N" for minutes). Valid
 values are "Y" (years), "M" (months), "W" (weeks), "D" (days), "H" (hours), "N" (minutes), "S" (seconds).</param>
	<param name="Precision">The number of digits after the decimal point to display in the return value.</param>
	<value>A string representation of the age of the patient associated with the Medcin entry in the specified time units (defaults
 to minutes). If the age is less than or equal to zero, the return value is the empty string.</value>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.Age"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.DisplayAgeRange(System.String,System.Int32)">
	<summary>
 Gets the current age range associated with the entry, in the specified time units (default minutes), as a string for display.
 </summary>
	<param name="TimeFormat">The desired units of time in which to return the age range (default is "N" for minutes). Valid
 values are "Y" (years), "M" (months), "W" (weeks), "D" (days), "H" (hours), "N" (minutes), "S" (seconds).</param>
	<param name="Precision">The number of digits after the decimal point to display in the numeric values of the
 return value.</param>
	<value>A string representation of the age range associated with the Medcin entry in the specified time units (defaults
 to minutes). If the age range is not valid, the return value is the empty string. A valid age range has start age zero or 
 greater and start age less than end age.</value>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.StartAge"/>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.EndAge"/>
	<seealso cref="M:Quippe.Coding.MedcinCodeEntry.SetAgeRange(System.Int32,System.Int32)"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.HasAge">
	<summary>
 Indicates whether the specific age value associated with this Medcin code entry is valid.
 </summary>
	<returns>Returns True if the specific age value associated with this Medcin code entry is valid and False otherwise.
 The age is valid if it is greater than zero.</returns>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.Age"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.HasAgeRange">
	<summary>
 Indicates whether this Medcin code entry has an associated valid age range.
 </summary>
	<returns>Returns True if a valid age range is associated with this Medcin code entry and False otherwise.
 The age range is valid if the start age is zero or greater and the end age is greater than the start age.</returns>
	<remarks>
		<para>A valid age range may start with zero even though this contradicts the validity criteria for the specific
 Age property. This is to accomodate an open ended lower limit in the range as used in BMI age ranges, for example.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.StartAge"/>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.EndAge"/>
	<seealso cref="M:Quippe.Coding.MedcinCodeEntry.SetAgeRange(System.Int32,System.Int32)"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.SetAgeRange(System.Int32,System.Int32)">
	<summary>
 Sets the age range associated with this Medcin code entry.
 </summary>
	<param name="AgeStart">The age defining the lower limit or start of the range.</param>
	<param name="AgeEnd">The age defining the upper limit or end of the range.</param>
	<returns>Returns True if the age range is valid and hence was successfully set, otherwise returns False.</returns>
	<remarks>
		<para>The age range is valid if the start age is zero or greater and the end age is greater than the start age.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.StartAge"/>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.EndAge"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.Sex">
	<summary>
 Gets or sets the sex of the patient, in minutes, which qualifies the underlying concept represented by the MedcinId.
 </summary>
	<value>The sex of the patient associated with the Medcin entry, as a string code. Valid values are "F" for female, "M"
 for male and "U" for unknown.</value>
	<remarks>
		<para>When patient sex is specified, this code entry actually represents a new concept derived from the underlying MEDCIN
 concept by applying the limitation of the patient's sex. For example, sex, along with age and value, may be used to qualify
 the body mass index concept to return a specific billable code in ICD-9-CM or ICD-10-CM.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.HasSex">
	<summary>
 Indicates whether the Sex property is specified.
 </summary>
	<remarks><para>The Medcin code entry is considered to have been specified if the Sex property is not empty. This method
 does not determine if the Sex property has a valid value (see the <see cref="P:Quippe.Coding.MedcinCodeEntry.Sex"/> property).</para></remarks>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.Sex"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.Value">
	<summary>
 Gets or sets a value which qualifies the underlying concept represented by the MedcinId.
 </summary>
	<value>The value associated with the Medcin entry, as a string, often times a numerical value.</value>
	<remarks>
		<para>When a value is specified, this code entry actually represents a new concept derived from the underlying MEDCIN
 concept by qualifying it with the value. For example, a value in kg/m2, along with age and sex, may be used to qualify
 the body mass index concept to return a specific billable code in ICD-9-CM or ICD-10-CM.</para>
		<para>The Medcin entry may have a single specific value and/or a value range as defined by the <see cref="P:Quippe.Coding.MedcinCodeEntry.LowValue"/> and <see cref="P:Quippe.Coding.MedcinCodeEntry.HighValue"/> properties.
 The specific measurement or test value is typically an input to a translation from Medcin to an external vocabulary, whereas 
 the value range is typically the result of a translation, from or to the Medcin vocabulary, and is taken from the range in the mapping 
 record. When value is relevant to a mapping from Medcin to an external vocabulary, the mapping record specifies a value range.
 When a specific value is presented as input to a translation, the resulting map, if it is value-qualified, has a value range in
 the mapping record. Both the input value in the translation request and the value range in the mapping record may be needed for
 further processing after the translation and therefore the MedcinCodeEntry accomodates both.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.LowValue">
	<summary>
 Gets the start value of the value range associated with this Medcin code entry.
 </summary>
	<value>The value defining the lower limit of the value range associated with this Medcin code entry.</value>
	<remarks>
		<para>See the <see cref="P:Quippe.Coding.MedcinCodeEntry.Value"/> property for more information regarding the value range versus the specific value.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.HighValue"/>
	<seealso cref="M:Quippe.Coding.MedcinCodeEntry.SetValueRange(System.Double,System.Double)"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.HighValue">
	<summary>
 Gets the end value of the value range associated with this Medcin code entry.
 </summary>
	<value>The value defining the upper limit of the value range associated with this Medcin code entry.</value>
	<remarks>
		<para>The high value defines the upper limit of the range, but is not considered part of the range.</para>
		<para>See the <see cref="P:Quippe.Coding.MedcinCodeEntry.Value"/> property for more information regarding the value range versus the specific value.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.HighValue"/>
	<seealso cref="M:Quippe.Coding.MedcinCodeEntry.SetValueRange(System.Double,System.Double)"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.DisplayValue">
	<summary>
 Gets the value associated with this Medcin code entry as a string suitable for display.
 </summary>
	<value>A string representation of the Value property associated with the Medcin entry. If the age is null or empty, 
 the return value is the empty string.</value>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.Value"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.DisplayValueRange(System.Int32)">
	<summary>
 Gets the current value range associated with the entry as a string suitable for display.
 </summary>
	<value>A string representation of the value range associated with the Medcin entry. If the value range is not valid, 
 the return value is the empty string. A value range is valid if it has a non-null low value and high value
 and low value less than high value.</value>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.LowValue"/>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.HighValue"/>
	<seealso cref="M:Quippe.Coding.MedcinCodeEntry.SetValueRange(System.Double,System.Double)"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.HasValue">
	<summary>
 Indicates whether the specific value associated with this Medcin code entry is valid.
 </summary>
	<returns>Returns True if the specific value associated with this Medcin code entry is valid and False otherwise.
 The value is valid if it is not null (not Nothing).</returns>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.Value"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.HasNumericValue">
	<summary>
 Indicates whether the specific value associated with this Medcin code entry is a numeric value.
 </summary>
	<returns>Returns True if the specific value associated with this Medcin code entry is valid and is a numeric value
 and returns False otherwise.</returns>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.HasValue"/>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.Value"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="P:Quippe.Coding.MedcinCodeEntry.HasValueRange">
	<summary>
 Indicates whether this Medcin code entry has an associated valid value range.
 </summary>
	<returns>Returns True if a valid value range is associated with this Medcin code entry and False otherwise.
 The value range is valid if the low and high values are non-null and the high value is greater than the low age.</returns>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.LowValue"/>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.HighValue"/>
	<seealso cref="M:Quippe.Coding.MedcinCodeEntry.SetValueRange(System.Double,System.Double)"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.SetValueRange(System.Double,System.Double)">
	<summary>
 Sets the value range associated with this Medcin code entry.
 </summary>
	<param name="ValueLow">The value defining the lower limit or start of the range.</param>
	<param name="ValueHigh">The value defining the upper limit or end of the range.</param>
	<returns>Returns True if the value range is valid and hence was successfully set, otherwise returns False.</returns>
	<remarks>
		<para>The value range is valid if the low and high values are non-null and the high value is greater than the low age.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.LowValue"/>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.HighValue"/>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.HasSpecifier(System.String)">
	<summary>
 Indicates whether this Medcin code entry has a specifier for the specified vocabulary.
 </summary>
	<param name="VocabCode">The unique string code of the vocabulary.</param>
	<returns>Returns True if the Medcin code entry has a specifier for the specified vocabulary, and False otherwise.</returns>
	<remarks><para>Specifiers are added to the Medcin code entry setting the <see cref="P:Quippe.Coding.MedcinCodeEntry.SpecificationString"/> property or
 by calling <see cref="M:Quippe.Coding.MedcinCodeEntry.SetSpecifiers(System.String)"/>.</para></remarks>
	<seealso cref="P:Quippe.Coding.MedcinCodeEntry.SpecificationString"/>
	<seealso cref="M:Quippe.Coding.MedcinCodeEntry.SetSpecifiers(System.String)"/>
	<seealso cref="T:Quippe.Coding.MedcinSpecifiers"/>
	<seealso cref="T:Quippe.Coding.Specifier"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.SetSpecifiers(Quippe.Coding.Specifier)">
	<summary>
 Sets the specifiers associated with this Medcin code entry to a specific specifier.
 </summary>
	<param name="Specifier">The specifier to set.</param>
	<remarks>
		<para>Normally the SpecifierString property is used to set one or more specifiers (by parsing the string
 and creating the specifiers). This method can be used if a Specifier instance is available rather than the specifier
 string.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.MedcinSpecifiers"/>
	<seealso cref="T:Quippe.Coding.Specifier"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.ClearSpecifiers">
	<summary>
 Removes all specifiers associated with this Medcin code entry.
 </summary>
	<seealso cref="T:Quippe.Coding.MedcinSpecifiers"/>
	<seealso cref="T:Quippe.Coding.Specifier"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.GetSpecifier(System.String)">
	<summary>
 Gets the specifier associated with this Medcin code entry that has the specified vocabulary code.
 </summary>
	<param name="VocabCode">The unique code of the vocabulary used to identify the specifier to return.</param>
	<returns>Returns a specifier if this Medcin code entry has a specifier for the specified vocabulary, otherwise
 returns Nothing.</returns>
	<seealso cref="M:Quippe.Coding.MedcinCodeEntry.SetSpecifiers(System.String)"/>
	<seealso cref="T:Quippe.Coding.MedcinSpecifiers"/>
	<seealso cref="T:Quippe.Coding.Specifier"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.SetStatusQualifier(System.String)">
	<summary>
 Sets the <see cref="P:Quippe.Coding.MedcinCodeEntry.StatusQualifier"/> property to the MEDCIN status qualifier object associated with the specified qualifier code.
 </summary>
	<param name="Code">Unique code (or name) of the MEDCIN status qualifier.</param>
	<returns>Returns True if the status qualifier was set and False otherwise.</returns>
	<remarks>
		<para>The status qualifier is identified by its unique string code. This property attempts to obtain the associated
 status qualifier object from the standard MEDCIN vocabulary using this code. The status qualifier object is an
 instance of <see cref="T:Quippe.Coding.CodingQualifier"/> having the qualifier type, <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.MedcinStatus"/>.
 If the status qualifier code is invalid or not
 recognized as a standard MEDCIN qualifier code, the status qualifier object will not be set and the <see cref="P:Quippe.Coding.MedcinCodeEntry.StatusQualifier"/> property
 will return Nothing and the <see cref="P:Quippe.Coding.MedcinCodeEntry.StatusQualifierCode"/> property will return the empty string.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.SetModifier(System.String)">
	<summary>
 Sets the <see cref="P:Quippe.Coding.MedcinCodeEntry.Modifier"/> property of this code entry to the MEDCIN modifier object associated with the specified modifier code.
 </summary>
	<param name="Code">Unique code (or name) of the MEDCIN modifier.</param>
	<returns>Returns True if the <see cref="P:Quippe.Coding.MedcinCodeEntry.Modifier"/> property was set and False otherwise.</returns>
	<remarks>
		<para>The MEDCIN modifier is identified by its unique string code. This property attempts to obtain the associated
 modifier object from the standard MEDCIN vocabulary using this code. The modifier object is an
 instance of <see cref="T:Quippe.Coding.CodingQualifier"/> having the qualifier type, <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Modifier"/>.
 If the modifier code is invalid or not
 recognized as a standard MEDCIN qualifier code, the modifier object will not be set and the <see cref="P:Quippe.Coding.MedcinCodeEntry.Modifier"/> property
 will return Nothing and the <see cref="P:Quippe.Coding.MedcinCodeEntry.ModifierCode"/> property will return the empty string.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.SetResult(System.String)">
	<summary>
 Sets the <see cref="P:Quippe.Coding.MedcinCodeEntry.Result"/> property of this code entry to the MEDCIN result qualifier object associated with the specified result code.
 </summary>
	<param name="Code">Unique code (or name) of the MEDCIN result qualifier.</param>
	<returns>Returns True if the <see cref="P:Quippe.Coding.MedcinCodeEntry.Result"/> property was set and False otherwise.</returns>
	<remarks>
		<para>The MEDCIN result qualifier is identified by its unique string code. This property attempts to obtain the associated
 result qualifier object from the standard MEDCIN vocabulary using this code. The result qualifier object is an
 instance of <see cref="T:Quippe.Coding.CodingQualifier"/> having the qualifier type, <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Result"/>.
 If the result qualifier code is invalid or not
 recognized as a standard MEDCIN qualifier code, the result qualifier object will not be set and the <see cref="P:Quippe.Coding.MedcinCodeEntry.Result"/> property
 will return Nothing and the <see cref="P:Quippe.Coding.MedcinCodeEntry.ResultCode"/> property will return the empty string.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.GetQualifier(Quippe.Coding.CodingQualifier.QualifierTypeEnum)">
	<summary>
 Returns the qualifier of the specified type.
 </summary>
	<param name="QualifierType">The type of qualifier to return.</param>
	<returns>Returns the qualifier of the specified type or Nothing if a qualifier of that type is not defined.</returns>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.GetQualifierCode(Quippe.Coding.CodingQualifier.QualifierTypeEnum)">
	<summary>
 Returns the qualifier code of the specified type.
 </summary>
	<param name="QualifierType">The type of qualifier for which to obtain the qualifier code.</param>
	<returns>Returns the qualifier code of the specified type or the empty string if a qualifier of that type is not defined.</returns>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.SetTermType(System.Int32)">
	<summary>
 Sets the TermType to the MEDCIN term type associated with the specified term type identifier.
 </summary>
	<param name="Id">Integer identifier of the MEDCIN term type.</param>
	<returns>Returns the term type if the operation was successful and Nothing otherwise.</returns>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.ToString">
	<summary>
 Returns the String representation of this MedcinCodeEntry. This default implementation returns
 a String in the form "Medcin [PrefixCode] [MedcinId] [ST=StatusQualifierCode] [MOD=ModifierCode] [RES=ResultCode]".
 </summary>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.MedcinCodeEntry.CompareTo(Quippe.Coding.MedcinCodeEntry)">
	<summary>
 Compares this MedcinCodeEntry with another specified MedcinCodeEntry.
 </summary>
	<param name="other">A MedcinCodeEntry to compare with this MedcinCodeEntry.</param>
	<returns>Returns a signed integer that indicates the relative ordering this MedcinCodeEntry instance and Other. If this 
 instance is less than Other, this function returns a negative integer. If this instance equals y, this function 
 returns 0. If this instance is greater than y, this function returns a positive integer.</returns>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="T:Quippe.Coding.MedcinCodeEntry">
	<summary>
 Class representing a coded entry in the MEDCIN vocabulary. This class represents a clinical concept within the MEDCIN
 vocabulary defined as a specialized coded entry derived from GenericCodeEntry.
 </summary>
	<remarks>
		<para>A coded MEDCIN entry has specific properties that are not relevant to target vocabularies external to MEDCIN.
 The base concept represented by a MEDCIN code entry is embodied in the concept associated with the MEDCIN ID. The meaning
 of the base concept, for the purposes of mapping, may be modified (i.e., qualified) by optional MEDCIN qualifiers, 
 a prefix (e.g., "History of"), a status qualifier (e.g., "Worsening"), a modifier (e.g., "Severe"), and a result 
 (e.g., normal/abnormal).</para>
		<para>A MedcinCodeEntry is defined by specifying the unique MEDCIN ID of the MEDCIN clinical concept. The properties of the
 MEDCIN coding vocabulary are represented internally as a <see cref="T:Quippe.Coding.CodeSet"/> object, and can be accessed via the
 <see cref="P:Quippe.Coding.CodeEntry.CodeSet"/> property of the base class. Additional properties
 may be specified, including a description of the MEDCIN concept, a MEDCIN prefix code (see <see cref="P:Quippe.Coding.Prefix.Code"/>), 
 a term type (i.e., an instance of <see cref="T:Quippe.Coding.TermType"/>), and MEDCIN qualifiers. MEDCIN qualifiers are of type <see cref="T:Quippe.Coding.CodingQualifier"/>
 and include a status qualifier, a modifier and a result, each distinguished by a enum value from <see cref="T:Quippe.Coding.CodingQualifier.QualifierTypeEnum"/>.
 </para>
	</remarks>
</member><member name="M:Quippe.Coding.Icd10Specifier.Clone">
	<summary>
 Returns a deep copy of this Icd10Specifier instance.
 </summary>
</member><member name="M:Quippe.Coding.Icd10Specifier.#ctor(Quippe.Coding.Icd10Specifier)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The Icd10Specifier instance to copy when creating a new instance.</param>
</member><member name="M:Quippe.Coding.GenericCodeEntry.#ctor(Quippe.Coding.CodeSet,System.String,System.String,Quippe.Coding.TermType)">
	<summary>
 Creates a new GenericCodeEntry instance with the given parameters.
 </summary>
	<param name="CodeSet">The CodeSet representing the vocabulary and optional version in which the Code is defined.</param>
	<param name="Code">The unique String value of the code for the clinical concept represented by this code entry.</param>
	<param name="Description">A description of this code entry, typically the description associated with the Code
 in the associated vocabulary.</param>
	<param name="TermType">An optional term type (e.g., subtype or domain) within the vocabulary to which the Code belongs.</param>
	<remarks>
		<para>The CodeSet defines the coding system vocabulary associated with this code entry. The vocabulary is defined by
 a vocabulary code and an optional version. The CodeSet for a given coding system can be created from its associated
 <see cref="T:Quippe.Coding.Vocabulary"/> instance. All standard vocabularies are available from the <see cref="T:Quippe.Coding.Vocabularies"/> class.</para>
		<para>The term type would typically be one of a collection of values associated with the <see cref="T:Quippe.Coding.Vocabulary"/> instance
 corresponding to the CodeSet, the collection accessible from the <see cref="P:Quippe.Coding.Vocabulary.TermTypes"/> property.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="M:Quippe.Coding.GenericCodeEntry.Clone">
	<summary>
 Returns a deep copy of this GenericCodeEntry instance.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="M:Quippe.Coding.GenericCodeEntry.#ctor(Quippe.Coding.GenericCodeEntry)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The GenericCodeEntry instance to copy when creating a new instance.</param>
</member><member name="T:Quippe.Coding.GenericCodeEntry">
	<summary>
 Class representing a basic, unspecialized, CodeEntry. This class represents a clinical concept within a specific
 coding vocabulary as a generic coded entry.
 </summary>
	<remarks>
		<para>This class derives from CodeEntry and represents a generic CodeEntry. Use this class to represent a
 clinical code in a vocabulary when there is no other more suitable specialized code entry class defined.
 </para>
		<para>A GenericCodeEntry is defined by specifying the properties of the coding vocabulary (as a <see cref="T:Quippe.Coding.CodeSet"/> object) and
 a unique string Code representing the clinical concept within the specified vocabulary. Additional properties
 may be specified, including a description of the clinical concept and a term type.</para>
		<para>Use the derived class <see cref="T:Quippe.Coding.MedcinCodeEntry"/> to define a code entry from the MEDCIN vocabulary. For external
 (non-MEDCIN) vocabularies, use the derived class <see cref="T:Quippe.Coding.ExternalCodeEntry"/>.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TermType"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.ExternalCodeEntry.#ctor">
	<summary>
 Constructs a new ExternalCodeEntry instance.
 </summary>
	<remarks>This is the default constructor.</remarks>
</member><member name="M:Quippe.Coding.ExternalCodeEntry.#ctor(Quippe.Coding.CodeSet,System.String,System.String,Quippe.Coding.TermType)">
	<summary>
 Creates a new ExternalCodeEntry instance with the given parameters.
 </summary>
	<param name="CodeSet">The CodeSet representing the vocabulary and optional version in which the Code is defined.</param>
	<param name="Code">The unique String value of the code for the clinical concept represented by this ExternalCodeEntry.</param>
	<param name="Description">A description of this ExternalCodeEntry, typically the description associated with the Code
 in the associated vocabulary.</param>
	<param name="TermType">An optional term type (e.g., subtype or domain) within the vocabulary to which the Code belongs.</param>
	<remarks>
		<para>The TermType parameter is an instance of <see cref="P:Quippe.Coding.CodeEntry.TermType"/>. Term type objects valid for MEDCIN may be obtained
 from a Medicomp translation service provider by calling the <see cref="M:Quippe.Coding.ITranslator.GetVocabulary(System.String)"/>
 method using the MEDCIN vocabulary code, "medcin", and then using the property <see cref="P:Quippe.Coding.Vocabulary.TermTypes"/>.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.ITranslator"/>
	<seealso cref="T:Quippe.Coding.Vocabularies"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.ExternalCodeEntry.Clone">
	<summary>
 Returns a deep copy of this ExternalCodeEntry instance.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
</member><member name="M:Quippe.Coding.ExternalCodeEntry.#ctor(Quippe.Coding.ExternalCodeEntry)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The ExternalCodeEntry instance to copy when creating a new instance.</param>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.HasHints">
	<summary>
 Gets or sets a property that indicates whether the external code has associated hints.
 </summary>
	<returns>Returns True if the external code has hints, otherwise returns False</returns>
	<remarks>
		<para>Certain external codes, most notably ICD-9-CM codes, may have additional hints, both textual and code-related,
 that indicate how the underlying condition should be coded. If this property is True, then hints are potentially available
 from the associated coding translator provider. In this case, the <see cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/> property should be checked for hints. Medicomp
 translation providers have an option to automatically obtain hints in forward translations from MEDCIN. 
 See <see cref="T:Quippe.Coding.CodeHints"/> for more information on code hints.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.HasParameters">
	<summary>
 Gets or sets a property that indicates whether the code referenced in the base mapping from MEDCIN has an association with 
 more detailed codes that can only be determined by additional parameters obtained from patient, encounter and finding information.
 </summary>
	<returns>Returns True if the code in the base map has more detailed codes that vary by parameter, otherwise returns False.</returns>
	<remarks>
		<para>Certain external codes, such as ICD-9-CM body mass index, can be further refined to more detailed codes when
 additional parameters are specified. Medicomp
 translation providers automatically obtain parameterized codes in forward translations from MEDCIN when the appropriate
 parameters are made available. This property indicates whether the code is parameterized. If HasParameters is True, then
 the <see cref="P:Quippe.Coding.ExternalCodeEntry.IsCodeFromParameters"/> property indicates whether the detailed parameterized code was obtained and stored in the
 <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property - in that case, the <see cref="P:Quippe.Coding.ExternalCodeEntry.BaseCodeFromParameters"/> property has the original code from which the
 parameterized code was derived.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.IsCodeFromParameters">
	<summary>
 Gets a property that indicates whether the code in the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property was derived from a code referenced in the base 
 mapping from MEDCIN by using additional parameters obtained from patient, encounter and finding information.
 </summary>
	<returns>Returns True if the Code property contains a parameterized code, otherwise returns False. If True, then the
 <see cref="F:Quippe.Coding.ExternalCodeEntry._BaseCodeFromParameters"/> property contains the base code from which the parameterized code was derived.</returns>
	<remarks>
		<para>Certain external codes, such as ICD-9-CM body mass index, can be further refined to more detailed codes when
 additional parameters are specified. Medicomp translation providers automatically obtain parameterized codes in forward translations 
 from MEDCIN when the appropriate parameters are made available. If the IsCodeFromParameters property is True, the detailed 
 parameterized code was obtained and stored in the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property and <see cref="P:Quippe.Coding.ExternalCodeEntry.BaseCodeFromParameters"/> has the 
 original code from which the parameterized code was derived.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.BaseCodeFromParameters">
	<summary>
 Gets a property that contains the base code from which the parameterized code in the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property was derived, 
 by using additional parameters obtained from patient, encounter and finding information.
 </summary>
	<returns>Returns the base code, which is valid if the <see cref="P:Quippe.Coding.ExternalCodeEntry.IsCodeFromParameters"/> property is True. If the
 IsCodeFromParameters property is False, then the return value is not valid.</returns>
	<remarks>
		<para>Certain external codes, such as ICD-9-CM body mass index, can be further refined to more detailed codes when
 additional parameters are specified. Medicomp translation providers automatically obtain parameterized codes in 
 forward translations from MEDCIN when the appropriate parameters are made available.</para>
		<para>If the <see cref="P:Quippe.Coding.ExternalCodeEntry.IsCodeFromParameters"/> property is True, the detailed parameterized code was obtained 
 and stored in the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property and the BaseCodeFromParameters property has the original code from which the
 parameterized code was derived.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.HasSpecifiers">
	<summary>
 Gets or sets a property that indicates whether the external code has associated code specifier tables.
 </summary>
	<returns>Returns True if the external code has associated code specifier tables, otherwise returns False.</returns>
	<remarks>
		<para>Certain external vocabularies such as DSM and ICD-10-CM may have associated code specifier tables that provide
 additional details in the form of one or more picklists that could be presented to a user for further specification of
 the underlying finding. Medicomp translation providers have an option to automatically obtain specifiers in forward 
 translations from MEDCIN. See <see cref="T:Quippe.Coding.CodeSpecifierLists"/> for more information on code specifiers.</para>
		<para>If HasSpecifiers is True, then the <see cref="P:Quippe.Coding.ExternalCodeEntry.IsCodeFromSpecifiers"/> property indicates whether the a more detailed
 code was obtained by resolving the base code against the specifier table selections - in that case the derived code is 
 stored in the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property and <see cref="P:Quippe.Coding.ExternalCodeEntry.BaseCodeFromParameters"/> has the original base code.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.IsCodeFromSpecifiers">
	<summary>
 Gets or sets a property that indicates whether the code in the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property was derived from a code referenced in the base 
 mapping from MEDCIN by resolving the base code against code specifiers.
 </summary>
	<returns>Returns True if the Code property contains a code generated from the application of specifiers to a base code, otherwise 
 returns False. If True, then the <see cref="F:Quippe.Coding.ExternalCodeEntry._BaseCodeFromSpecifiers"/> property contains the base code from which the generated 
 code was derived.</returns>
	<remarks>
		<para>Certain external codes, including some ICD-10-CM codes, are indirectly mapped from Medcin via specifier lists/tables, and can 
 be further resolved to more detailed codes when individual specifier items from the specifier lists are selected to qualify the input 
 Medcin concept. Medicomp translation providers automatically obtain code specifiers and resolve base codes in forward translations 
 from MEDCIN when the appropriate input, including a Medcin specification string, is available.
 This property indicates whether the code in the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property is derived from a base code having been resolved against
 the specifier items. If the value is True, then the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property has the derived code and <see cref="P:Quippe.Coding.ExternalCodeEntry.BaseCodeFromSpecifiers"/>
 has the original base code from which the derived code was generated.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.BaseCodeFromSpecifiers">
	<summary>
 Gets or sets a property that contains the base code from which the derived code in the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property was obtained, 
 by resolving the base code against a set of code specifier item selections encoded in the specification string of the Medcin concept.
 </summary>
	<returns>Returns the base code, which is valid if the <see cref="P:Quippe.Coding.ExternalCodeEntry.IsCodeFromSpecifiers"/> property is True. If the
 IsCodeFromSpecifiers property is False, then the return value is not valid.</returns>
	<remarks>
		<para>Certain external codes, including some ICD-10-CM codes, are indirectly mapped from Medcin via specifier lists/tables, and can 
 be further resolved to more detailed codes when individual specifier items from the specifier lists are selected to qualify the input 
 Medcin concept. Medicomp translation providers automatically obtain code specifiers and resolve base codes in forward translations 
 from MEDCIN when the appropriate input, including a Medcin specification string, is available.</para>
		<para>If the <see cref="P:Quippe.Coding.ExternalCodeEntry.IsCodeFromSpecifiers"/> property is True, then the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property has the derived code and <see cref="P:Quippe.Coding.ExternalCodeEntry.BaseCodeFromSpecifiers"/>
 has the original base code from which the derived code was generated.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.VocabExtensionCode">
	<summary>
 Gets or sets a property that contains the unique code of an optional extension to the external vocabulary to which this code
 entry belongs.
 </summary>
	<returns>Returns a string code for the vocabulary extension to which the code entry belongs, if an extension is relevant, or the
 empty string if the code belongs to the base (non-extended) vocabulary or there is no vocabulary extension.</returns>
	<remarks>
		<para>The best example of a vocabulary with extensions is SNOMED-CT. A code entry in the internaional release of SNOMED-CT
 would have an empty extension code as the international release is consider to be the non-extended release of SNOMED-CT. A
 code entry in the US extensions of SNOMED-CT would have a non-empty Medicomp-created extension code that uniquely identifies
 the US extension within the universe of available extensions within SNOMED-CT.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.Hints">
	<summary>
 Gets the code hints associated with the external code.
 </summary>
	<returns>Returns a CodeHints object that contains a collection of hints (<see cref="T:Quippe.Coding.CodeHint"/> objects) associated 
 with the code or Nothing if no hints are available.</returns>
	<remarks>
		<para>Code hints may be obtained by the code translation provider during the translation operation. Medicomp
 translation providers have an option to automatically obtain hints in forward translations from MEDCIN.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists">
	<summary>
 Gets the code specifier lists (picklists or tables) associated with the external code.
 </summary>
	<remarks>
		<para>Certain external vocabularies such as DSM and ICD-10-CM may have associated code specifier tables that provide
 additional details in the form of one or more picklists that could be presented to a user for further specification of
 the underlying finding. Medicomp translation providers have an option to automatically obtain specifiers in forward 
 translations from MEDCIN and assign them to this property of the relevant external codes. The SpecifierLists property
 of the ExternalCodeEntry returned from the translation may be used to obtain the relevant specifier lists, if any.
 See <see cref="T:Quippe.Coding.CodeSpecifierLists"/> for more information on code specifiers.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.CodeQualifier">
	<summary>
 Gets or sets an object that defines a qualification on the code.
 </summary>
	<remarks>
		<para>A code qualifier is a <see cref="T:Quippe.Coding.CodingQualifier"/> object having the qualifier type,
 <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Code"/>. The qualifier can be used by an <see cref="T:Quippe.Coding.ITranslator"/> provider to define custom qualifications on code entries. For 
 example, the <see cref="T:Quippe.Coding.StandardTranslator"/> provider supplied by Medicomp uses qualifiers to represent whether an ICD-10-CM
 code is "other", "uspecified", "not elsewhere classified" etc.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.CodeQualifierName">
	<summary>
 Gets the name of the current code qualifier object, if defined.
 </summary>
	<returns>Returns the qualifier name, if a qualifier is defined, or the empty string otherwise.</returns>
	<remarks>
		<para>A code qualifier is a <see cref="T:Quippe.Coding.CodingQualifier"/> object having the qualifier type,
 <see cref="F:Quippe.Coding.CodingQualifier.QualifierTypeEnum.Code"/>. The qualifier object adds a vocabulary-specific
 qualification of the code entry. For 
 example, the <see cref="T:Quippe.Coding.StandardTranslator"/> provider supplied by Medicomp uses qualifiers to represent whether an ICD-10-CM
 code is "other", "uspecified", "not elsewhere classified" etc.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.IsCategory">
	<summary>
 Gets or sets a property indicating whether the code is considered category in the associated vocabulary.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.IsUnreportable">
	<summary>
 Gets or sets a property indicating whether the code is considered unreportable in the associated vocabulary.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.IsManifestation">
	<summary>
 Gets or sets a property indicating whether the code is considered a manifestation in the associated vocabulary.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.ExternalCodeEntry.Code">
	<summary>
 Gets or sets the unique String value of the code that identifies the associated clinical concept (within the 
 associated coding vocabulary) this CodeEntry represents and clears any information related to code parameters.
 </summary>
	<remarks>
		<para>Use this property to directly set the code when the code is not derived from parameters. Setting this property clears
 any information regarding code parameters stored in the properties <see cref="P:Quippe.Coding.ExternalCodeEntry.BaseCodeFromParameters"/> and
 <see cref="P:Quippe.Coding.ExternalCodeEntry.IsCodeFromParameters"/>.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)">
	<summary>
 Sets the Hints associated with the external code via a MEDCIN server hints string.
 </summary>
	<param name="TextHints">The hints string.</param>
	<remarks>
		<para>The hints string contains one or more encoded hints delimited with semi-colons.
 Each individual hint in the string has the format, [$(text)$][(hint-type)(ref-codes)],
 where (text) is the textual part of the hint, (hint-type) is a two character code that identifies
 the hint type (e.g. "CF" for a "code first" hint), and (ref-codes) is a comma separated list of codes, codes ranges, or substring match templates
 referenced by the hint. The textual part of the hint string is enclosed in dollar signs ("$") and may contain semi-colons. The reference part of
 the hint begins with a two character code indicating the hint type, and is followed by the referenced codes, code ranges, or substring matches
 in a comma-separated list. The hint must either have a text part, a reference part, or both. The text part always appears first. ICD-9-CM hints
 generally have a purely textual hint first, followed by reference-type hints, but ICD-10-CM hints are more general and each individual hint may
 have a text part followed by a reference part.</para>
		<para>For example, an ICD-9-CM hints string with three hints might be: 
 "$This is a textual hint; with a semi-colon$;CF123.45-123.49,234.56;UAE908-909". This hint string contains a textual hint (with a semi-colon inside
 the textual hint) followed by two reference hints identifying additional codes or code ranges. Each distinct hint is separated by a semi-colon.
 An example ICD-10-CM hints string is:
 "$Use additional code for any associated drug resistance (Z16)$UAZ16;$Excludes1: carrier or suspected carrier of infectious disease (Z22.-);$E1Z22.+".
 This example includes two hints, each with a text part and a reference part. The referenced substring match template, "Z22.+", is equivalent to 
 "Z22.-" in the ICD-10-CM documentation and represents the set of codes in the subtree rooted at code "Z22" that start with "Z22.".</para>
		<para>See <see cref="T:Quippe.Coding.CodeHints"/> and <see cref="T:Quippe.Coding.CodeHint"/> for more information on code hints and <see cref="T:Quippe.Coding.CodeHint.HintTypeEnum"/>
 to learn about the different hint types and their associated two character codes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String,System.String)">
	<summary>
 Sets the Hints associated with the external code via a MEDCIN server hints string, including a code version (e.g.,
 code year) indicating when the hint became effective.
 </summary>
	<param name="TextHints">The MEDCIN server hints string containing one or more code hints.</param>
	<param name="Version">The version (e.g., code year) associated with the hints.</param>
	<remarks>
		<para>The hints string contains one or more encoded hints delimited with semi-colons.
 Each individual hint in the string has the format, [$(text)$][(hint-type)(ref-codes)],
 where (text) is the textual part of the hint, (hint-type) is a two character code that identifies
 the hint type (e.g. "CF" for a "code first" hint), and (ref-codes) is a comma separated list of codes, codes ranges, or substring match templates
 referenced by the hint. The textual part of the hint string is enclosed in dollar signs ("$") and may contain semi-colons. The reference part of
 the hint begins with a two character code indicating the hint type, and is followed by the referenced codes, code ranges, or substring matches
 in a comma-separated list. The hint must either have a text part, a reference part, or both. The text part always appears first. ICD-9-CM hints
 generally have a purely textual hint first, followed by reference-type hints, but ICD-10-CM hints are more general and each individual hint may
 have a text part followed by a reference part.</para>
		<para>For example, an ICD-9-CM hints string with three hints might be: 
 "$This is a textual hint; with a semi-colon$;CF123.45-123.49,234.56;UAE908-909". This hint string contains a textual hint (with a semi-colon inside
 the textual hint) followed by two reference hints identifying additional codes or code ranges. Each distinct hint is separated by a semi-colon.
 An example ICD-10-CM hints string is:
 "$Use additional code for any associated drug resistance (Z16)$UAZ16;$Excludes1: carrier or suspected carrier of infectious disease (Z22.-);$E1Z22.+".
 This example includes two hints, each with a text part and a reference part. The referenced substring match template, "Z22.+", is equivalent to 
 "Z22.-" in the ICD-10-CM documentation and represents the set of codes in the subtree rooted at code "Z22" that start with "Z22.".</para>
		<para>See <see cref="T:Quippe.Coding.CodeHints"/> and <see cref="T:Quippe.Coding.CodeHint"/> for more information on code hints and <see cref="T:Quippe.Coding.CodeHint.HintTypeEnum"/>
 to learn about the different hint types and their associated two character codes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.ExternalCodeEntry.SetCodeFromParameters(System.String,System.String)">
	<summary>
 Sets the <see cref="P:Quippe.Coding.ExternalCodeEntry.Code"/> property to the code that was derived from parameters, saves the original base code, and sets a property 
 to indicate the Code was determined from parameters.
 </summary>
	<param name="CodeFromParm">The code to set that was determined from parameters.</param>
	<param name="DescriptionFromParm">The optional description of the code that was determined from parameters.</param>
	<remarks>
		<para>Used when a code is determined from the base code and parameters such as age, gender and test value, so that the
 base code is retained for information purposes. The base code is stored in the <see cref="P:Quippe.Coding.ExternalCodeEntry.BaseCodeFromParameters"/> property and the
 <see cref="P:Quippe.Coding.ExternalCodeEntry.IsCodeFromParameters"/> property should return True, indicating the code is parameterized. Setting the Code property
 directly resets the base code and any information related to code parameters.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.ExternalCodeEntry.CopyProperties(Quippe.Coding.ExternalCodeEntry)">
	<summary>
 Copies certain code properties of the specified code entry to this code entry.
 </summary>
	<param name="Other">The code entry from which the properties are copied.</param>
	<remarks>This method is used to copy code properties from the specified code entry in the Other parameter. Does not copy
 the Code, Description, TermType or CodeSet properties. Nor does it copy Hints or SpecifierLists.</remarks>
</member><member name="M:Quippe.Coding.ExternalCodeEntry.CompareTo(Quippe.Coding.ExternalCodeEntry)">
	<summary>
 Compares this ExternalCodeEntry with another specified ExternalCodeEntry.
 </summary>
	<param name="other">An ExternalCodeEntry to compare with this ExternalCodeEntry.</param>
	<returns>Returns a signed integer that indicates the relative ordering this ExternalCodeEntry instance and Other. If this 
 instance is less than Other, this function returns a negative integer. If this instance equals Other, this function 
 returns 0. If this instance is greater than Other, this function returns a positive integer.</returns>
	<seealso cref="T:Quippe.Coding.CodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="T:Quippe.Coding.ExternalCodeEntry">
	<summary>
 Class representing a coded entry in an external (non-MEDCIN) vocabulary. This class represents a clinical concept within
 a vocabulary external to MEDCIN, defined as a specialized coded entry derived from GenericCodeEntry.
 </summary>
	<remarks>
		<para>This class adds more detailed properties to the GenericCodeEntry class in order to model the
 additional information typcially associated with a code in an external (non-MEDCIN) vocabulary that is the target of
 a mapping from a source MEDCIN concept. Medicomp translation providers implementing <see cref="T:Quippe.Coding.ITranslator"/> use this class to 
 represent codes in external code sets. The class adds properties to represent additional code attributes, qualifiers, 
 code hints, specifier lists, and information associated with parameterized codes.</para>
		<para>A code in an external vocabulary, such as ICD-9-CM, that is the base target code of a Medicomp mapping from a
 MEDCIN concept, my have additional information associated with it that allows a more detailed representation of that
 mapping to be obtained. First, a base code may have associated code hints that reference other codes in the target 
 vocabulary that should or must be coded. The ExternalCodeEntry instance has a property to indicate hints are
 available with the base code and code hints may be stored in the ExternalCodeEntry instance representing the base code.
 See <see cref="T:Quippe.Coding.CodeHints"/> for more information on code hints.
 Second, a base code (e.g., body mass index, BMI) may lead to a more detailed code when additional parameters are
 defined (e.g., gender, age and measurement value). The ExternalCodeEntry instance has a property to indicate the code
 is parameterized and can store the base code as well as the more detailed code. Finally, the base code may have
 associated code specifier lists that provide choices that will lead to more detailed codes or code descriptions. A
 property of the ExternalCodeEntry instance indicates the presence of specifier lists and another property is used
 to access the lists. See <see cref="T:Quippe.Coding.CodeSpecifierLists"/> for more information on code specifiers.</para>
	</remarks>
</member><member name="M:Quippe.Coding.DsmSpecifier.Clone">
	<summary>
 Returns a deep copy of this DsmSpecifier instance.
 </summary>
</member><member name="M:Quippe.Coding.DsmSpecifier.#ctor(Quippe.Coding.DsmSpecifier)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The DsmSpecifier instance to copy when creating a new instance.</param>
</member><member name="M:Quippe.Coding.CodeSpecifierType.#ctor">
	<summary>
 Creates a new empty code specifier type.
 </summary>
</member><member name="M:Quippe.Coding.CodeSpecifierType.#ctor(System.Int32,System.String,System.String)">
	<summary>
 Creates a new specifier type with the specified unique Id, Tag and Description.
 </summary>
	<param name="Id">A unique integer identifier for the type, to be assigned to the <see cref="P:Quippe.Coding.CodeSpecifierType.Id"/> property.</param>
	<param name="Tag">A text tag, to be assigned to the <see cref="P:Quippe.Coding.CodeSpecifierType.Tag"/> property, that can be associated with the type to facilitate 
 classification or search (e.g., a "laterality" tag might identify all the laterality types).</param>
	<param name="Description">A text description of the type, to be assigned to the <see cref="P:Quippe.Coding.CodeSpecifierType.Description"/> property 
 (e.g., "Left", "Right", "Bilateral" might be some universal types tagged as lateralities).</param>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierType.Clone">
	<summary>
 Returns a deep copy of this CodeSpecifierType instance.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierType.#ctor(Quippe.Coding.CodeSpecifierType)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The CodeSpecifierType instance to copy when creating a new instance.</param>
</member><member name="P:Quippe.Coding.CodeSpecifierType.Id">
	<summary>
 Gets or sets the unique integer identifier of the code specifier type.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierType.Tag">
	<summary>
 Gets or sets an optional string tag associated with the type.
 </summary>
	<remarks>
		<para>The string tag could be used as a means of classification, to facilite search or for any desired purpose.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierType.Description">
	<summary>
 Gets or sets the string description associated with the code specifier type.
 </summary>
	<remarks>
		<para>Typically the description is the text representation of the universal type. For example, "Initial encounter", 
 "Subsequent encounter" and "Sequelae" might be universal instance types associated with ICD-10-CM code specifier tables
 or pick lists.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="T:Quippe.Coding.CodeSpecifierType">
	<summary>
 Class representing a unique type of code specifier item.
 </summary>
	<remarks>
		<para>Code specifier lists (<see cref="T:Quippe.Coding.CodeSpecifierList"/> objects) consist of code specifier items
 (<see cref="T:Quippe.Coding.CodeSpecifierItem"/> objects), each of which are of a specific
 code specifier type. The code specifier item includes specific code related information, such as the 
 associated code and sequence (e.g., laterality "left" represented by code digit "1"). The code specifier type
 defines the abstract concept divorced from its code specific information (e.g., laterality "left") so that
 multiple items of the same type can be represented with different code specific information (e.g., different
 digit codes).</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierLists.#ctor">
	<summary>
 Creates a new instance of this class as an empty collection of code specifier lists (<see cref="T:Quippe.Coding.CodeSpecifierList"/> objects).
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSpecifierLists.Clone">
	<summary>
 Returns a deep copy of this CodeSpecifierLists instance.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSpecifierLists.#ctor(Quippe.Coding.CodeSpecifierLists)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The CodeSpecifierLists instance to copy when creating a new instance.</param>
</member><member name="P:Quippe.Coding.CodeSpecifierLists.Lists">
	<summary>
 Gets the collection of code specifier lists managed by this object.
 </summary>
	<returns>Returns a <see cref="T:System.Collections.Generic.SortedList`2"/> of key value pairs, in which each pair consists of a code specifier list value,
 as an <see cref="T:Quippe.Coding.CodeSpecifierList"/> instance, and an integer key, corresponding to the list sequence number. The sequence
 numbers start at one and indicate the order the lists should be presented to the user for processing.</returns>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodeSpecifierLists.Count">
	<summary>
 Returns the number of <see cref="T:Quippe.Coding.CodeSpecifierList"/> objects in the Lists collection.
 </summary>
</member><member name="M:Quippe.Coding.CodeSpecifierLists.Add(Quippe.Coding.CodeSpecifierList)">
	<summary>
 Adds the specified code specifier list to the collection using the list's <see cref="P:Quippe.Coding.CodeSpecifierList.Sequence">Sequence</see> property value to
 identify and order the list in the collection.
 </summary>
	<param name="aList">The code specifier list to add to the collection.</param>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if a list having the same sequence as the aList parameter is already a member of the collection.</exception>
	<remarks>
		<para>If the specified list is Nothing, then no change is made to the collection.</para>
		<para>The specified list should have a unique <see cref="P:Quippe.Coding.CodeSpecifierList.Sequence">Sequence</see> property value within the collection.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierLists.Remove(System.Int32)">
	<summary>
 Removes the list with the specified Sequence from the collection.
 </summary>
	<param name="Sequence">The Sequence value of the list to remove from the collection.</param>
	<returns>Returns a reference to the CodeSpecifierList object removed from the collection if a list with the specified
 Sequence was found and the list was successfully removed from the collection. Returns Nothing if a list with the
 specified Sequence was not found.</returns>
	<remarks>
		<para>Medicomp sequence values start at 1 and uniquely identify the code specifier list in the collection. Therefore, no 
 two lists in the collection can have the same sequence number in their <see cref="P:Quippe.Coding.CodeSpecifierList.Sequence">Sequence</see> property.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierLists.Item(System.Int32)">
	<summary>
 Gets a reference to the <see cref="T:Quippe.Coding.CodeSpecifierList"/> instance from the collection that has the specified Sequence value
 in its <see cref="P:Quippe.Coding.CodeSpecifierList.Sequence">Sequence</see> property.
 </summary>
	<param name="Sequence">The Sequence value of the desired list.</param>
	<returns>Returns a reference to the <see cref="T:Quippe.Coding.CodeSpecifierList"/> object in the collection if a list with the specified
 Sequence was found. Returns Nothing if a list with the specified Sequence was not found.</returns>
	<remarks>
		<para>Medicomp sequence values start at 1 and uniquely identify the code specifier list in the collection. Therefore, no 
 two lists in the collection can have the same sequence number in their <see cref="P:Quippe.Coding.CodeSpecifierList.Sequence">Sequence</see> property.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierLists.ItemById(System.Int32)">
	<summary>
 Gets a reference to the <see cref="T:Quippe.Coding.CodeSpecifierList"/> instance from the collection that has an <see cref="P:Quippe.Coding.CodeSpecifierList.Id">Id</see> 
 property value equal to the specified ListId.
 </summary>
	<param name="ListId">The list ID value of the desired list in the collection.</param>
	<returns>Returns a reference to the <see cref="T:Quippe.Coding.CodeSpecifierList"/> object in the collection if a list with the specified
 <see cref="P:Quippe.Coding.CodeSpecifierList.Id">Id</see> property value was found. Returns Nothing if a list with the specified Id property 
 value was not found.</returns>
	<remarks>
		<para>Each list should have a unique <see cref="P:Quippe.Coding.CodeSpecifierList.Id">Id</see> property value, but this is not enforced in the collection.
 Therefore, the first list in the collection having the specified Id property value is returned, if any are found.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierLists.ItemByName(System.String)">
	<summary>
 Gets a reference to the first <see cref="T:Quippe.Coding.CodeSpecifierList"/> instance from the collection that has a <see cref="P:Quippe.Coding.CodeSpecifierList.Id">Name</see> 
 property value equal to the specified Name.
 </summary>
	<param name="Name">The Name property value of the desired list in the collection.</param>
	<returns>Returns a reference to the first <see cref="T:Quippe.Coding.CodeSpecifierList"/> object in the collection if a list with the specified
 <see cref="P:Quippe.Coding.CodeSpecifierList.Id">Name</see> property value was found. Returns Nothing if a list with the specified Name 
 property value was not found.</returns>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown If the value specified in the Name parameter is Nothing or empty.</exception>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierLists.Clear">
	<summary>
 Clears the collection, removing all references to code specifier lists (<see cref="T:Quippe.Coding.CodeSpecifierList"/> objects) from the collection.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="T:Quippe.Coding.CodeSpecifierLists">
	<summary>
 Class representing an ordered collection of code specifier lists.
 </summary>
	<remarks>
		<para>A base code in an external vocabulary, represented as an <see cref="T:Quippe.Coding.ExternalCodeEntry"/> in the coding service, may
 have an associated CodeSpecifiersLists object assigned via the <see cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/> property 
 during the code translation process. The collection of lists, each
 represented by an <see cref="T:Quippe.Coding.CodeSpecifierList"/> list identifies the items that may be selected to add further details to 
 the base code. Medicomp coding translation service providers use code specifier lists to provide additional details for
 DSM and ICD-10-CM codes in maps from MEDCIN.</para>
		<para>Each code specifier list (<see cref="T:Quippe.Coding.CodeSpecifierList"/> object) in the collection is  
 ordered by its Sequence property, which must be
 unique for each list in the collection. A code specifier list could represent the collection of lists
 from which a user makes selections to fully specify a code in a coding system vocabulary in which
 code specifiers are used (i.e., DMS and ICD-10-CM).</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSpecifierList.#ctor">
	<summary>
 Creates a new uninitialized code specifier list object.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierList.#ctor(System.String,System.String,System.Int32)">
	<summary>
 Creates a new code specifier list object from the specified name, group tag and sequence number.
 </summary>
	<param name="Name">A string name (e.g., "Laterality table A") to assign to the list's <see cref="P:Quippe.Coding.CodeSpecifierList.Name"/> property.</param>
	<param name="Group">A textual tag (e.g., "Laterality") to assign to the <see cref="P:Quippe.Coding.CodeSpecifierList.Group"/> property to identify the list's group or type.</param>
	<param name="Sequence">A integer sequence number starting at 1 to assign to the <see cref="P:Quippe.Coding.CodeSpecifierList.Sequence"/> property that indicates the order 
 (e.g., pick list order) the list should appear in a parent collection such as a <see cref="T:Quippe.Coding.CodeSpecifierLists"/> object.</param>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierList.#ctor(System.String,System.String,System.Int32,System.String,System.Int32,System.Char,System.String)">
	<summary>
 Creates a new code specifier list object from the specified parameters.
 </summary>
	<param name="Name">A string name (e.g., "Laterality table A") to assign to the list's <see cref="P:Quippe.Coding.CodeSpecifierList.Name"/> property.</param>
	<param name="Group">A string to assign to the <see cref="P:Quippe.Coding.CodeSpecifierList.Group"/> property to identify the list's group or type (e.g., "Laterality").</param>
	<param name="Sequence">A integer sequence number starting at 1 to assign to the <see cref="P:Quippe.Coding.CodeSpecifierList.Sequence"/> property that indicates the order 
 (e.g., pick list order) the list should appear in a parent collection such as a <see cref="T:Quippe.Coding.CodeSpecifierLists"/> object.</param>
	<param name="Description">A string description of the table to assign to the <see cref="P:Quippe.Coding.CodeSpecifierList.Description"/> property.</param>
	<param name="Digit">A character to assign to the <see cref="P:Quippe.Coding.CodeSpecifierList.Digit"/> property indicating the digit this list is associated with in 
 the external vocabulary code (e.g., ICD-10-CM 4th, 5th, 6th or 7th digit).</param>
	<param name="Tag">An optional text value to assign to the <see cref="P:Quippe.Coding.CodeSpecifierList.Tag"/> property that can be used to classify or tag 
 lists (e.g., "Laterality" or "Trimester").</param>
	<param name="Id">The unique integer identifier of the list to assign to the <see cref="P:Quippe.Coding.CodeSpecifierList.Id"/> property.</param>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierList.Clone">
	<summary>
 Returns a deep copy of this code specifier list instance.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierList.#ctor(Quippe.Coding.CodeSpecifierList)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The CodeSpecifierList instance to copy when creating a new instance.</param>
</member><member name="P:Quippe.Coding.CodeSpecifierList.Id">
	<summary>
 Gets or sets the unique integer identifier of the code specifier list.
 </summary>
	<remarks>
		<para>Medicomp uses the Id property to uniquely identify each code specifier list.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.Group">
	<summary>
 Gets or sets the group qualifier name that identifies the group to which the code specifier list belongs.
 </summary>
	<remarks>Medicomp uses the MEDCIN server v2.1 qualifier name to identify whether the list is for the DSM vocabulary, group "DSMLIST" or
 the ICD-10-CM vocabulary, "ICD10LIST".</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.Digit">
	<summary>
 Gets or sets the code digit (position) in the external vocabulary to which the code specifier list is associated.
 </summary>
	<remarks>
		<para>In Medicomp code specifier lists, the Digit property is relevant only to ICD-10-CM specifier lists. The Digit 
 indicates which digit position in the ICD-10-CM code is associated with the list and will usually range from 4 to 7, indicating
 either the 4th, 5th, 6th or 7th digit. Each item (<see cref="T:Quippe.Coding.CodeSpecifierItem"/> object) in the list identifies a digit code 
 that is appropriate at that code position
 if the item is selected to further qualify the base code (which may only contain the first 3 or 4 digits of the code). Each 
 ICD-10-CM specifier list allows one selection only and selections from multiple lists will allow the billable code to be fully
 specified in certain situations where picklists are required.</para>
		<para>The Digit property would typically be set by a parent object maintaining a list of code specifier lists associated with
 a specific base code. Such a parent object would typically also set the Sequence value, thus allowing the associated lists to
 be displayed in the order in which choices should be made from the list in order to further refine the base code. The
 <see cref="T:Quippe.Coding.ExternalCodeEntry"/> object associated with an external code in a code translation has a 
 <see cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists">SpecifierLists</see> property that holds a reference to a <see cref="T:Quippe.Coding.CodeSpecifierLists"/>
 object, which is essentially a collection of lists. The Digit property is typically assigned by a coding translation provider
 at the time the lists are created and added to the ExternalCodeEntry object.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.Sequence">
	<summary>
 Gets or sets a value indicating the order or position at which this list should appear in a parent collection.
 </summary>&gt;
 <remarks>
		<para>The sequence will generally be managed by a parent object that includes this list in a collection of lists
 where order is important (e.g., when presenting pick lists to the user in order of digit position).  The
 <see cref="T:Quippe.Coding.ExternalCodeEntry"/> object associated with an external code in a code translation has a 
 <see cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists">SpecifierLists</see> property that holds a reference to a <see cref="T:Quippe.Coding.CodeSpecifierLists"/>
 object, which is essentially a collection of lists. The Sequence property is typically assigned by a coding translation provider
 at the time the lists are created and added to the ExternalCodeEntry object.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.Name">
	<summary>
 Gets or sets the name of the list, which might be used for display or as an alternate identifier, typically
 unique within the Group.
 </summary>
	<remarks>
		<para>Medicomp uses the Name property to uniquely identify the list within the Group.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.Tag">
	<summary>
 Gets or sets an optional string tag associated with the list.
 </summary>
	<remarks>
		<para>The string tag could be used as a means of classification, to facilite search or for any desired purpose. For instance,
 if the list provides selections to indicate laterality, a tag of "Laterality" might classify the table appropriately.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.Description">
	<summary>
 An optional description of the code specifier list.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierItem"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.Items">
	<summary>
 Gets the collection of code specifier items contained in this list.
 </summary>
	<remarks>
		<para>The order in which items should appear in the list is given by the item's <see cref="P:Quippe.Coding.CodeSpecifierItem.Sequence">Sequence</see> property.</para>
	</remarks>
	<returns>Returns a collection of <see cref="T:Quippe.Coding.ICodeSpecifierItem"/> instances for items contained in the list.</returns>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.Item(System.Int32)">
	<summary>
 Gets a reference to the <see cref="T:Quippe.Coding.ICodeSpecifierItem"/> instance in the list's collection that has the specified Sequence value
 in its <see cref="P:Quippe.Coding.CodeSpecifierItem.Sequence">Sequence</see> property.
 </summary>
	<param name="Sequence">The Sequence number of the item to obtain.</param>
	<returns>Returns a reference to the <see cref="T:Quippe.Coding.ICodeSpecifierItem"/> instance in the collection if an item with the specified
 Sequence was found. Returns Nothing if an item with that Sequence number was not found.</returns>
	<remarks>
		<para>Medicomp sequence values start at 1 and uniquely identify the code specifier item in the collection. Therefore, no 
 two items in the collection can have the same sequence number in their <see cref="P:Quippe.Coding.CodeSpecifierItem.Sequence">Sequence</see> property.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.ItemById(System.Int32)">
	<summary>
 Gets a reference to the code specifier item in the list's item collection that has an <see cref="P:Quippe.Coding.CodeSpecifierItem.Id">Id</see> 
 property value equal to the specified ItemId.
 </summary>
	<param name="ItemId">The unique identifier of the item to obtain.</param>
	<returns>Returns a reference to the <see cref="T:Quippe.Coding.ICodeSpecifierItem"/> instance in the collection if an item with the specified
 <see cref="P:Quippe.Coding.CodeSpecifierItem.Id">Id</see> property value was found. Returns Nothing if an item with that Id value was not found.</returns>
	<remarks>
		<para>Searches for an item that has an <see cref="P:Quippe.Coding.CodeSpecifierItem.Id">Id</see> property value that matches the specified ItemId.</para>
		<para>Each item should have a unique Id property value, but this is not enforced in the collection.
 Therefore, the first item in the collection having the specified Id property value is returned, if any items are found.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.ItemByTypeId(System.Int32)">
	<summary>
 Gets a reference to the code specifier item in the <see cref="P:Quippe.Coding.CodeSpecifierList.Items"/> collection that has a <see cref="T:Quippe.Coding.CodeSpecifierType"/> object that is
 uniquely identified by the value of the TypeId parameter.
 </summary>
	<param name="TypeId">The unique identifier, or Id property value, of the <see cref="T:Quippe.Coding.CodeSpecifierType"/> of the item desired.</param>
	<returns>Returns a reference to the <see cref="T:Quippe.Coding.ICodeSpecifierItem"/> instance in the <see cref="P:Quippe.Coding.CodeSpecifierList.Items"/> collection that has a code specifier
 type, i.e., a <see cref="P:Quippe.Coding.CodeSpecifierItem.Type"/> property value, that has a type ID equal to TypeId. Returns Nothing if an item with a
 type corresponding to the TypeId value was not found.</returns>
	<remarks>
		<para>Searches for an item with a CodeSpecifierType object in the item's <see cref="T:System.Type"/> property that has a unique identifier equal
 to the value in the TypeId parameter.</para>
		<para>No two items in the list's Items collection should have the same CodeSpecifierType in the Type property, but this is not enforced 
 in the collection. Therefore, the first item in the collection having a Type matching the specified TypeId is returned.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierList.ItemByCode(System.String)">
	<summary>
 Gets a reference to the code specifier item in the list's <see cref="P:Quippe.Coding.CodeSpecifierList.Items"/> collection that has a <see cref="P:Quippe.Coding.CodeSpecifierItem.Code"/> property 
 value matching the specified value in the Code parameter.
 </summary>
	<param name="Code">The Code property value of the item desired.</param>
	<returns>Returns a reference to the <see cref="T:Quippe.Coding.ICodeSpecifierItem"/> instance in the <see cref="P:Quippe.Coding.CodeSpecifierList.Items"/> collection that has a 
 <see cref="P:Quippe.Coding.CodeSpecifierItem.Code"/> property value matching the specified value in the Code parameter. Returns Nothing if no item in the collection has the
 specified Code value.</returns>
	<remarks>
		<para>Searches for an item that that has a <see cref="P:Quippe.Coding.CodeSpecifierItem.Code"/> property equal to the value in the Code parameter.
 value.</para>
		<para>No two items in the list's Items collection should have the <see cref="P:Quippe.Coding.CodeSpecifierItem.Code"/> property value, but this is not enforced 
 in the collection. Therefore, the first item in the collection having the specified Code value is returned.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierList.Add(Quippe.Coding.CodeSpecifierItem)">
	<summary>
 Adds a code specifier item to this list's collection of items using the item's <see cref="P:Quippe.Coding.CodeSpecifierItem.Sequence">Sequence</see> property value to
 identify and order the item in the collection.
 </summary>
	<param name="Item">The item to add to the collection.</param>
	<exception cref="T:Quippe.Coding.CodingArgumentException">Thrown if an item with the same Sequence number already exists in the collection.</exception>
	<remarks>
		<para>If the specified value in Item is Nothing, then no change is made to the collection of items.</para>
		<para>The specified item should have a unique <see cref="P:Quippe.Coding.CodeSpecifierItem.Sequence">Sequence</see> property value within the collection.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierList.Remove(System.Int32)">
	<summary>
 Removes the code specifier item having the specified Sequence number from the list's item collection.
 </summary>
	<param name="Sequence">The Sequence number of the item to remove.</param>
	<returns>Returns the item if it was successfully removed. Returns Nothing if an item with that Sequence number was not found.</returns>
	<remarks>
		<para>Medicomp sequence values start at 1 and uniquely identify the code specifier item in the collection. Therefore, no 
 two items in the collection can have the same sequence number in their <see cref="P:Quippe.Coding.CodeSpecifierItem.Sequence">Sequence</see> property.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierList.Clear">
	<summary>
 Removes all references to <see cref="T:Quippe.Coding.CodeSpecifierItem"/> objects from the list's item collection.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierList.FilterItems(System.Collections.Generic.Dictionary{System.Int32,System.Int32})">
	<summary>
 Filters items currently in the list to those having an item ID contained in the specified collection of valid item IDs.
 </summary>
	<param name="ValidItemIds">Dictionary of IDs of items (item ID is both key and value) that are to remain in the list.</param>
</member><member name="T:Quippe.Coding.CodeSpecifierList">
	<summary>
 Class representing a list or table of items that further qualify an external code in an external vocabulary.
 </summary>
	<remarks>
		<para>The code specifier list is a list of items, represented as <see cref="T:Quippe.Coding.CodeSpecifierItem"/> objects, associated 
 with a base code in an external vocabulary, such as
 DMS or ICD-10-CM. The list identifies the items that may be selected to add further details to the base code. An external
 code may have multple lists associated with it via a reference to a <see cref="T:Quippe.Coding.CodeSpecifierLists"/> object accessible from 
 the <see cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists">SpecifierLists</see> property of the <see cref="T:Quippe.Coding.ExternalCodeEntry"/> object 
 corresponding to the external code. Each list represents essentially a pick list of items the user can choose
 to drill down to the desired detail from the base code. In the case of DSM, the specifier lists permit the user to select
 the text descriptions that most appropriately qualify the base concept. Note, in DSM, multiple selections per list are
 allowed. In the case of ICD-10-CM, the specifier lists permit the user to drill down from a base code that is clinically
 relevant, but may not be billable, to a less clinically relevant but billable code, by selecting such details as
 laterality or encounter instance qualifiers such as "initial", "subsequent", and "sequelae".</para>
		<para>For instance, an ICD10 specifier list might represent the possible laterality choices that further refine a base 
 concept in a code by a list of items such as "Left", "Right", and "Unspecified". In this example, the base concept
 might be ICD-10-CM code, S41.0, "Open wound of shoulder" and the aforementioned laterality list represents
 the possible choices that determine the 6th digit of the ICD10 code, the 5th digit being determined by
 another table that lists the type of wounds, e.g., "Unspecified", "Laceration without foreign body",
 "Laceration with foreign body", "Puncture wound without foreign body" and "Puncture wound with foreign body", and
 the 7th digit by a table with "encounter instance" values "Initial", "Subsequent" and "Sequelae". After making a selection
 from the three lists, the laterality list, the open wound type list and the "encounter instance" list, the ICD10 code would
 be fully specified. To whit, S41.0 with a selection of "Puncture wound without foreign body"
 from the 5th digit table, "Left" from the 6th digit table and "Initial" from the seventh digit table is equivalent to S41.032A, 
 "Puncture wound without foreign body of the left shoulder, initial encounter". The concept associated with the base code
 is clinically relevant, but the base code is not billable. The fully specified code may or may not include some information that is
 not clinically relevant, but it is a billable code.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSpecifierItem.#ctor">
	<summary>
 Default constructor that creates a new code specifier item with default property values.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierItem.#ctor(System.String,System.Int32,System.String)">
	<summary>
 Creates a new code specifier item from the specified Code, Sequence and Description.
 </summary>
	<param name="Code">The vocabulary specific string code or digit code associated with the specifier item to be
 assigned to the <see cref="P:Quippe.Coding.CodeSpecifierItem.Code"/> property.</param>
	<param name="Sequence">The unqiue position, starting at 1, of the item within it's parent code specifier list, to be
 assigned to the <see cref="P:Quippe.Coding.CodeSpecifierItem.Sequence"/> property.</param>
	<param name="Description">Text description of the item in the external vocabulary associated with the item, to be 
 assigned to the <see cref="P:Quippe.Coding.CodeSpecifierItem.Description"/> property.</param>
	<remarks>
		<para>The specified Code (assigned to the <see cref="P:Quippe.Coding.CodeSpecifierItem.Code"/> property) is a vocabulary specific value that may also be a unique identifier of the item within the
 specifier list containing the item. Use the <see cref="P:Quippe.Coding.CodeSpecifierItem.Id"/> property to set an integer identifier that uniquely identifies
 the item across all specifier items.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierItem.#ctor(System.Int32,System.String,System.Int32,System.String,Quippe.Coding.CodeSpecifierType)">
	<summary>
 Creates a new code specifier item from the specifier parameters and option specifier type.
 </summary>
	<param name="Id">Unique integer identifier of the code specifier item to be assigned to the <see cref="P:Quippe.Coding.CodeSpecifierItem.Id"/> property.</param>
	<param name="Code">The vocabulary specific string code or digit code associated with the specifier item to be
 assigned to the <see cref="P:Quippe.Coding.CodeSpecifierItem.Code"/> property.</param>
	<param name="Sequence">The unqiue position, starting at 1, of the item within it's parent code specifier list, to be
 assigned to the <see cref="P:Quippe.Coding.CodeSpecifierItem.Sequence"/> property.</param>
	<param name="Description">Text description of the item in the external vocabulary associated with the item, to be 
 assigned to the <see cref="P:Quippe.Coding.CodeSpecifierItem.Description"/> property.</param>
	<param name="Type">The specifier type that defines the type of this specifier item, to be assigned to the <see cref="P:Quippe.Coding.CodeSpecifierItem.Type"/> property.</param>
	<remarks>
		<para>The specified Code (assigned to the <see cref="P:Quippe.Coding.CodeSpecifierItem.Code"/> property) is a vocabulary specific value that may also be a unique identifier of the item within the
 specifier list containing the item. Use the <see cref="P:Quippe.Coding.CodeSpecifierItem.Id"/> property to set an integer identifier that uniquely identifies
 the item across all specifier items.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierItem.Clone">
	<summary>
 Returns a deep copy of this code specifier item instance.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="M:Quippe.Coding.CodeSpecifierItem.#ctor(Quippe.Coding.CodeSpecifierItem)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The CodeSpecifierItem instance to copy when creating a new instance.</param>
</member><member name="P:Quippe.Coding.CodeSpecifierItem.Id">
	<summary>
 Gets or sets the unique integer identifier of the code specifier list.
 </summary>
	<remarks>
		<para>
 Medicomp uses the Id property to uniquely identify the code specifier item within the universe
 of all specifier items.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierItem.Type">
	<summary>
 Gets or sets the type of the code specifier item.
 </summary>
	<remarks>
		<para>The type represents the basic abstract concept of the item, allowing the separation of the basic
 meaning of the item from is representation within the specific code specifier list (i.e., <see cref="T:Quippe.Coding.CodeSpecifierList"/> object) or location in the
 coding system vocabulary hierarchy (i.e., ICD-10-CM hierarchy). For instance, the laterality concept of "Left" is represented as a
 code specifier type, but the type does not indicate any specific code-related information, such as the
 character/digit <see cref="P:Quippe.Coding.CodeSpecifierItem.Code"/> or <see cref="P:Quippe.Coding.CodeSpecifierItem.Sequence"/> within a list. Multiple code specifier items that represent specific
 instances of the laterality concept may have the type "Left", but may have different Code property
 values.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierItem.Code">
	<summary>
 Gets or sets the vocabulary specific string code or digit code associated with the specifier item.
 </summary>
	<remarks>
		<para>The Code is a vocabulary specific value that may also be a unique identifier of the item within the
 specifier list (<see cref="T:Quippe.Coding.CodeSpecifierList"/> object) containing the item. For instance, a specifier item in the DSM vocabulary will have a one or two
 character text code (e.g., "A", "B", "AB" etc.) that uniquely identifies the specifier item. An ICD10 specifier
 item has a unique code within the containing list that identifies the character in the full ICD10 code that is
 the digit/character position associated with the list. For instance, the codes associated with ICD10 specifier 
 items for encounter instances, "Initial" "Subsequent" and "Sequelae", are "A", "D", and "S", respectively, and they
 uniquely identify the item with the containing list, and are usually associated with specifier lists that specify 
 the 7th digit of an ICD10 injury code, such as in the category S41, "Open wound of shoulder and upper arm".</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierItem.Sequence">
	<summary>
 Gets or sets a value indicating the order or position where this item should appear in a containing specifier list.
 </summary>&gt;
 <remarks>The sequence will generally be managed by a parent <see cref="T:Quippe.Coding.CodeSpecifierList"/> object that includes this item.</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="P:Quippe.Coding.CodeSpecifierItem.Description">
	<summary>
 A text description of the code specifier item.
 </summary>
	<remarks>
		<para>The description is usually text taken from the associated coding system vocabulary that describes
 the item. For example, "Laceration without foreign body" might be a text description associated with an
 item in the 5th digit specifier list associated with ICD10 code, S41.0.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeSpecifierList"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierLists"/>
	<seealso cref="T:Quippe.Coding.CodeSpecifierType"/>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists"/>
</member><member name="T:Quippe.Coding.CodeSpecifierItem">
	<summary>
 Class representing an item in a code specifier list.
 </summary>
	<remarks>
		<para>A code specifier item is an item in a code specifier list (i.e., a <see cref="T:Quippe.Coding.CodeSpecifierList"/> object). 
 An item represents a possible choice that refines the basic concept represented in the base code associated with the list.
 An external
 code may have multple lists associated with it via a reference to a <see cref="T:Quippe.Coding.CodeSpecifierLists"/> object accessible from 
 the <see cref="P:Quippe.Coding.ExternalCodeEntry.SpecifierLists">SpecifierLists</see> property of the <see cref="T:Quippe.Coding.ExternalCodeEntry"/> object 
 corresponding to the external code. Each list represents essentially a pick list of items the user can choose
 to drill down to the desired detail from the base code. The items could represent
 additional descriptions that may be chosen and inserted in the patient encounter to further qualify the base
 concept, as is the approach taken by Medicomp with the DSM code set. On the other hand, the items could represent
 choices that can be made to further qualify a MEDCIN concept in the encounter to obtain a code that is billable 
 in the external code set, as in Medicomp's implementation of ICD-10-CM.
 </para>
		<para>For instance, a
 specifier list might represent the possible laterality choices that further refine a base concept in a
 code, say by defining a list of items such as "Left", "Right", and "Unspecified". The base code may not be billable
 in the target code set, but the specifier list can provide a path to obtain the related billable code. Each entry in
 the laterality list is a specifier item, each with unique identifying information, including a specifier type
 (see <see cref="T:Quippe.Coding.CodeSpecifierType"/>), as well as a possible association with a billable code in the target code set.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSet.#ctor(System.String,System.String,System.String,System.String)">
	<summary>
 Creates a new CodeSet with the given name, version, and description.
 </summary>
	<param name="VocabCode">The unique String code for the new CodeSet, e.g., corresponding to a vocabulary code.</param>
	<param name="Name">The optional String name of the CodeSet.</param>
	<param name="Version">The optional version name of the CodeSet.</param>
	<param name="Description">The optional description of the CodeSet.</param>
	<remarks>
		<para>The vocabulary code from the corresponding <see cref="T:Quippe.Coding.Vocabulary"/> object should be used to create a corresponding CodeSet
 object for use in the code translation. The <see cref="T:Quippe.Coding.Vocabulary"/> object can return the corresponding CodeSet. The members of the
 <see cref="T:Quippe.Coding.Vocabularies"/> class can be used to return a CodeSet corresponding to a specified vocabulary code or can enumerate the 
 standard vocabularies and associated code sets.
 </para>
	</remarks>
</member><member name="M:Quippe.Coding.CodeSet.#ctor(Quippe.Coding.ICodeSet)">
	<summary>
 Creates a new CodeSet by copying the input instance.
 </summary>
	<param name="Other">The code set to copy.</param>
</member><member name="P:Quippe.Coding.CodeSet.VocabCode">
	<summary>
 Gets or sets the String code that uniquely identifies the CodeSet.
 </summary>
	<remarks>
		<para>The code identifying the code set corresponds to the unique vocabulary code associated with the corresponding
 <see cref="T:Quippe.Coding.Vocabulary"/> object. The standard vocabularies and associated CodeSets can be enumerated using members of
 the <see cref="T:Quippe.Coding.Vocabularies"/> class. The vocabulary code can be obtained from the <see cref="P:Quippe.Coding.Vocabulary.Code"/> 
 property.</para>
	</remarks>
</member><member name="P:Quippe.Coding.CodeSet.Name">
	<summary>
 Gets or sets the optional name of the CodeSet.
 </summary>
	<remarks>The Name is optional and is primarily for display in a user interface. Although the Name may be
 unique, the <see cref="P:Quippe.Coding.CodeSet.VocabCode"/> is the CodeSet identifier and must be unique.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodeSet.Version">
	<summary>
 Gets or sets the optional version name of the CodeSet.
 </summary>
	<remarks>
		<para>A CodeSet and its corresponding <see cref="T:Quippe.Coding.Vocabulary"/> may have versions defined. A translation provider,
 implementing the <see cref="T:Quippe.Coding.ITranslator"/> interface, may use the version during code translation to determine the appropriate mappings
 to return. In most cases, Medicomp uses a code year to identify the code set or vocabulary version, in which case the 
 version is a string representation of a 4 digit integer year (e.g., "2010"). See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class
 and <see cref="P:Quippe.Coding.Vocabulary.UsesCodeYears"/> for more information regarding versions and code years.</para>
	</remarks>
</member><member name="P:Quippe.Coding.CodeSet.Description">
	<summary>
 Gets or sets the optional description of the CodeSet.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodeSet.Empty">
	<summary>
 Returns a singleton representing an "empty" CodeSet.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSet.ToString">
	<summary>
 Returns the String representation of this CodeSet. This default implementation returns the <see cref="P:Quippe.Coding.CodeSet.VocabCode"/>
 property value.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSet.HasVocabCode">
	<summary>
 Indicates whether the <see cref="P:Quippe.Coding.CodeSet.VocabCode"/> property of this CodeEntry has been specified.
 </summary>
	<returns>Returns True if the VocabCode property returns a non-empty string and False otherwise.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSet.HasVersion">
	<summary>
 Indicates whether the <see cref="P:Quippe.Coding.CodeSet.Version"/> property of this CodeEntry has been specified.
 </summary>
	<returns>Returns True if the Version property returns a non-empty string and False otherwise.</returns>
	<remarks>
		<para>See the <see cref="T:Quippe.Coding.VocabularyVersion"/> class and <see cref="P:Quippe.Coding.Vocabulary.UsesCodeYears"/> for more information regarding
 versions and code years.</para>
	</remarks>
</member><member name="M:Quippe.Coding.CodeSet.Compare(Quippe.Coding.ICodeSet)">
	<summary>
 Compares the specified CodeSet object to this CodeSet instance and returns an integer that indicates
 their relative position in the sort order.
 </summary>
	<param name="Other">The CodeSet to compare to this CodeSet instance.</param>
	<returns>Returns a signed integer that indicates the relative ordering this CodeSet instance and Other. If this 
 instance is less than Other, this function returns a negative integer. If this instance equals Other, this function 
 returns 0. If this instance is greater than Other, this function returns a positive integer.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSet.Compare(Quippe.Coding.CodeSet,Quippe.Coding.CodeSet)">
	<summary>
 Compares two specified CodeSet objects and returns an integer that indicates their relative position
 in the sort order.
 </summary>
	<param name="x">The first CodeSet to compare.</param>
	<param name="y">The second CodeSet to compare.</param>
	<returns>Returns a signed integer that indicates the relative ordering of values x and y. If x is less than
 y, this function returns a negative integer. If x equals y, this function returns 0. If x is greater than y,
 this function returns a positive integer.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSet.CompareTo(Quippe.Coding.ICodeSet)">
	<summary>
 Compares the specified CodeSet object to this CodeSet instance and returns an integer that indicates
 their relative position in the sort order.
 </summary>
	<param name="Other">The CodeSet to compare to this CodeSet instance.</param>
	<returns>Returns a signed integer that indicates the relative ordering this CodeSet instance and Other. If this 
 instance is less than Other, this function returns a negative integer. If this instance equals Other, this function 
 returns 0. If this instance is greater than Other, this function returns a positive integer.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeSet.Clone">
	<summary>
 Creates a new object that is a deep copy of the current instance.
 </summary>
	<remarks>Creates a deep copy of the current CodeSet instance and returns the copy as an Object.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="T:Quippe.Coding.CodeSet">
	<summary>
 Class representing a coding vocabulary in a form suitable as input to the coding translators.
 </summary>
	<remarks>
		<para>A CodeSet is uniquely defined by a string code (e.g., the underlying vocabulary code) and an optional 
 String version. The CodeSet may also be given an optional name and description.</para>
		<para>The CodeSet represents a coding system vocabulary in a form suitable for input to a code translation
 provider (i.e., and implementation of the <see cref="T:Quippe.Coding.ITranslator"/> interface). The CodeSet for a given 
 coding system can be created from its associated <see cref="T:Quippe.Coding.Vocabulary"/> instance. All standard vocabularies
 are available from the <see cref="T:Quippe.Coding.Vocabularies"/> class. When a code translation is required to obtain the
 mappings from a given source code to a target vocabulary, two CodeSets will be created, one to identify the
 source vocabulary, usually as part of a <see cref="T:Quippe.Coding.CodeEntry"/> instance and the other to identify the 
 target vocabulary. Typically the source of a translation will be specified by either a 
 <see cref="T:Quippe.Coding.MedcinCodeEntry"/>, if the source is a MEDCIN code, or an <see cref="T:Quippe.Coding.ExternalCodeEntry"/> if the
 source is code from a non-MEDCIN vocabulary (e.g., ICD-10-CM).</para>
	</remarks>
</member><member name="P:Quippe.Coding.CodeHints.Hints">
	<summary>
 Gets the collection of individual code hints associated with this instance.
 </summary>
	<returns><para>Returns a collection of <see cref="T:Quippe.Coding.CodeHint"/> objects, each one containing a single code hint.</para></returns>
	<seealso cref="T:Quippe.Coding.CodeHint"/>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodeHints.Maps">
	<summary>
 Gets the collection of reverse maps from codes referenced in the code hints to the concepts in the source vocabulary (e.g., MEDCIN).
 </summary>
	<returns>Returns a <see cref="T:Quippe.Coding.MapManager"/> object containing a collection of reverse maps, each one a map record from the external code set (e.g., ICD-9-CM) to 
 the source code set (e.g., MEDCIN).
 </returns>
	<remarks>
		<para>A <see cref="T:Quippe.Coding.CodeHint"/> object may reference one or more codes, code ranges, or matching codes (via substring match) in an external 
 coding system vocabulary (e.g., some code set that is not MEDCIN, such as ICD-9-CM). Each such code, code range, or substring match template
 is represented as a <see cref="T:Quippe.Coding.CodeHintItem"/> in the CodeHint object. It may be useful to obtain reverse maps from each referenced external code to the mapped
 MEDCIN concepts. Once the reverse maps are obtained they can be added to the associated CodeHints object by calling the <see cref="M:Quippe.Coding.CodeHints.SetMaps(Quippe.Coding.MapManager)"/> method. The
 Maps property can be used to return the collection of reverse maps that were added in this way.</para>
		<para>For example, if the original code in the target external vocabulary (e.g., ICD-9-CM) contains a CodeFirst (CF) hint (<see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.CodeFirst"/>),
 the hint will reference additional codes in the target vocabulary that must be coded before the original code. If the reverse maps are available for the
 referenced codes, the concepts in the input terminology (e.g., MEDCIN) could be obtained from them and displayed to the user so a selection
 could be made in the encounter to satisfy the code first requirement in the external target vocabulary.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodeHints.HasMaps">
	<summary>
 Indicates whether this CodeHints instance has any maps under management.
 </summary>
	<returns>Returns True if this CodeHints instance has at least one map under management and False otherwise.</returns>
</member><member name="P:Quippe.Coding.CodeHints.Version">
	<summary>
 Gets the optional version (e.g., code year) associated with the code hints.
 </summary>
	<remarks>The version is assigned when the CodeHints instance is created using the appropriate constructor.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.CodeHints.VocabCode">
	<summary>
 Gets the optional vocabulary code associated with the code hints.
 </summary>
	<remarks>The vocabulary code is assigned when the CodeHints instance is created using the appropriate constructor.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.CodeHints.Count">
	<summary>
 Returns the number of <see cref="T:Quippe.Coding.CodeHint"/> objects in the hint collection.
 </summary>
</member><member name="M:Quippe.Coding.CodeHints.#ctor">
	<summary>
 Creates a new CodeHints object with an empty collection of code hints, i.e., <see cref="T:Quippe.Coding.CodeHint"/> objects.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeHintItem"/>
</member><member name="M:Quippe.Coding.CodeHints.#ctor(System.String)">
	<summary>
 Creates a new CodeHints object by parsing a MEDCIN server hints string.
 </summary>
	<param name="TextHints">The MEDCIN server hints string containing one or more code hints.</param>
	<remarks>
		<para>A MEDCIN server hints string consists of
 one or more hints separated by semi-colons. Each individual hint in the string has the format, [$(text)$][(hint-type)(ref-codes)],
 where (text) is the textual part of the hint, (hint-type) is a two character code that identifies
 the hint type (e.g. "CF" for a "code first" hint), and (ref-codes) is a comma separated list of codes, codes ranges, or substring match templates
 referenced by the hint. The textual part of the hint string is enclosed in dollar signs ("$") and may contain semi-colons. The reference part of
 the hint begins with a two character code indicating the hint type, and is followed by the referenced codes, code ranges, or substring matches
 in a comma-separated list. The hint must either have a text part, a reference part, or both. The text part always appears first. ICD-9-CM hints
 generally have a purely textual hint first, followed by reference-type hints, but ICD-10-CM hints are more general and each individual hint may
 have a text part followed by a reference part.</para>
		<para>For example, an ICD-9-CM hints string with three hints might be: 
 "$This is a textual hint; with a semi-colon$;CF123.45-123.49,234.56;UAE908-909". This hint string contains a textual hint (with a semi-colon inside
 the textual hint) followed by two reference hints identifying additional codes or code ranges. Each distinct hint is separated by a semi-colon.
 An example ICD-10-CM hints string is:
 "$Use additional code for any associated drug resistance (Z16)$UAZ16;$Excludes1: carrier or suspected carrier of infectious disease (Z22.-);$E1Z22.+".
 This example includes two hints, each with a text part and a reference part. The referenced substring match template, "Z22.+", is equivalent to 
 "Z22.-" in the ICD-10-CM documentation and represents the set of codes in the subtree rooted at code "Z22" that start with "Z22.".</para>
		<para> A separate <see cref="T:Quippe.Coding.CodeHint"/> object is created from each hint as the hints string is parsed and individual <see cref="T:Quippe.Coding.CodeHintItem"/> 
 objects are created and assigned to the hint for each code referenced in a reference hint.</para>
		<para>Hints are assigned to the <see cref="T:Quippe.Coding.ExternalCodeEntry"/> class instance representing the external code using the method, <see cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>, 
 when maps from MEDCIN to an external vocabulary are returned by a translation server that
 supports code hints.</para>
		<para>See <see cref="T:Quippe.Coding.CodeHint"/> for more information on code hints and <see cref="T:Quippe.Coding.CodeHint.HintTypeEnum"/>
 to learn about the different hint types and their associated two character codes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeHints.#ctor(System.String,System.String,System.String)">
	<summary>
 Sets the Hints associated with the external code via a MEDCIN server hints string, including a code version (e.g.,
 code year) indicating when the hint became effective.
 </summary>
	<param name="TextHints">The MEDCIN server hints string containing one or more code hints.</param>
	<param name="Version">The version (e.g., code year) associated with the hints.</param>
	<remarks>
		<para>A MEDCIN server hints string consists of
 one or more hints separated by semi-colons. Each individual hint in the string has the format, [$(text)$][(hint-type)(ref-codes)],
 where (text) is the textual part of the hint, (hint-type) is a two character code that identifies
 the hint type (e.g. "CF" for a "code first" hint), and (ref-codes) is a comma separated list of codes, codes ranges, or substring match templates
 referenced by the hint. The textual part of the hint string is enclosed in dollar signs ("$") and may contain semi-colons. The reference part of
 the hint begins with a two character code indicating the hint type, and is followed by the referenced codes, code ranges, or substring matches
 in a comma-separated list. The hint must either have a text part, a reference part, or both. The text part always appears first. ICD-9-CM hints
 generally have a purely textual hint first, followed by reference-type hints, but ICD-10-CM hints are more general and each individual hint may
 have a text part followed by a reference part.</para>
		<para>For example, an ICD-9-CM hints string with three hints might be: 
 "$This is a textual hint; with a semi-colon$;CF123.45-123.49,234.56;UAE908-909". This hint string contains a textual hint (with a semi-colon inside
 the textual hint) followed by two reference hints identifying additional codes or code ranges. Each distinct hint is separated by a semi-colon.
 An example ICD-10-CM hints string is:
 "$Use additional code for any associated drug resistance (Z16)$UAZ16;$Excludes1: carrier or suspected carrier of infectious disease (Z22.-);$E1Z22.+".
 This example includes two hints, each with a text part and a reference part. The referenced substring match template, "Z22.+", is equivalent to 
 "Z22.-" in the ICD-10-CM documentation and represents the set of codes in the subtree rooted at code "Z22" that start with "Z22.".</para>
		<para>A separate <see cref="T:Quippe.Coding.CodeHint"/> object is created from each hint as the hints string is parsed and individual <see cref="T:Quippe.Coding.CodeHintItem"/> 
 objects are created and assigned to the hint for each code referenced in a reference hint.</para>
		<para>Hints are assigned to the <see cref="T:Quippe.Coding.ExternalCodeEntry"/> class instance representing the external code using the method, <see cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>, 
 when maps from MEDCIN to an external vocabulary are returned by a translation server that
 supports code hints.</para>
		<para>See <see cref="T:Quippe.Coding.CodeHint"/> for more information on code hints and <see cref="T:Quippe.Coding.CodeHint.HintTypeEnum"/>
 to learn about the different hint types and their associated two character codes.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="M:Quippe.Coding.CodeHints.Clone">
	<summary>
 Returns a deep copy of this CodeHints instance.
 </summary>
</member><member name="M:Quippe.Coding.CodeHints.#ctor(Quippe.Coding.CodeHints)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The CodeHints instance to copy when creating a new instance.</param>
</member><member name="M:Quippe.Coding.CodeHints.Clear">
	<summary>
 Removes all <see cref="T:Quippe.Coding.CodeHint"/> objects from the hint collection and clears the associated collection of maps (see the <see cref="P:Quippe.Coding.CodeHints.Maps"/> property) 
 from referenced codes to MEDCIN.
 </summary>
</member><member name="M:Quippe.Coding.CodeHints.SetMaps(Quippe.Coding.MapManager)">
	<summary>
 Sets the collection of maps from referenced codes to MEDCIN to the specified maps.
 </summary>
	<param name="Maps">The collection of maps to sets.</param>
	<remarks>
		<para>A <see cref="T:Quippe.Coding.CodeHint"/> may reference one or more codes, code ranges, or matching codes (via substring match) in an external 
 coding system vocabulary (e.g., some code set that is not MEDCIN, such as ICD-9-CM). Each such code, code range, or substring match template
 is represented as a <see cref="T:Quippe.Coding.CodeHintItem"/> in the CodeHint object. It may be useful to obtain reverse maps from each referenced external code to the mapped
 MEDCIN concepts. Once the reverse maps are obtained they can be added to the associated CodeHints object by calling the <see cref="M:Quippe.Coding.CodeHints.SetMaps(Quippe.Coding.MapManager)"/> method. The
 <see cref="P:Quippe.Coding.CodeHints.Maps"/> property can be used to return the collection of reverse maps that were added in this way.</para>
		<para>For example, if the original code in the target external vocabulary (e.g., ICD-9-CM) contains a CodeFirst (CF) hint 
 (<see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.CodeFirst"/>), the hint will 
 reference additional codes in the target vocabulary that must be coded before the original code. If the reverse maps are available for the
 referenced codes, the concepts in the input terminology (e.g., MEDCIN) could be obtained from them and displayed to the user so a selection
 could be made in the encounter to satisfy the code first requirement in the external target vocabulary.</para>
		<para>Calling this method essentially clears the existing collection of maps, if any, and sets the map collection
 without any verification that the maps correspond to the codes referenced in the hints.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeHints.GetMapsByCode(System.String)">
	<summary>
 Returns the maps managed by this CodeHints instance that have a source entry containing the specified code.
 </summary>
	<param name="Code">The code in the external vocabulary (e.g., ICD-9-CM) associated with this instance for which maps to the input terminology (e.g., MEDCIN) are desired.</param>
	<returns>Returns a <see cref="T:Quippe.Coding.MapManager"/> object containing those maps managed by this instance that reference the specified external code in the source code entry. Returns
 Nothing if this instance has no managed maps or if the specified Code is empty.</returns>
	<remarks>
		<para>A <see cref="T:Quippe.Coding.CodeHint"/> may reference one or more codes, code ranges, or matching codes (via substring match) in an external 
 coding system vocabulary (e.g., some code set that is not MEDCIN, such as ICD-9-CM). Each such code, code range, or substring match template
 is represented as a <see cref="T:Quippe.Coding.CodeHintItem"/> in the CodeHint object. It may be useful to obtain reverse maps from each referenced external code to the mapped
 MEDCIN concepts. Once the reverse maps are obtained they can be added to the associated CodeHints object by calling the <see cref="M:Quippe.Coding.CodeHints.SetMaps(Quippe.Coding.MapManager)"/> method. The
 GetMapsByCode function can be then be used to return the collection of reverse maps that are associated with the specified single code,
 that is, that have a source external code equal to that specified in the Code parameter.</para>
		<para>The function searches the existing collection of maps in this instance for maps that have the code as a source code entry. The code
 is assumed to be in the external vocabulary associated with this CodeHints instance. The maps would normally be the reverse maps from codes
 in an external vocabulary (e.g., ICD-9-CM) referenced in the hints to the concepts in the input terminology (e.g., MEDCIN).</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeHints.GetMapsByRange(System.String,System.String)">
	<summary>
 Returns the maps managed by this CodeHints instance that have a source entry code that falls in the specified range.
 </summary>
	<param name="MinCode">The minimum code value defining the inclusive range of desired codes in the external vocabulary.</param>
	<param name="MaxCode">The maximum code value defining the inclusive range of desired codes in the external vocabulary.</param>
	<returns>Returns a <see cref="T:Quippe.Coding.MapManager"/> object containing those maps managed by this instance that reference the specified external code in the source code entry. Returns
 Nothing if this instance has no managed maps or if the specified Code is empty.</returns>
	<remarks>
		<para>A <see cref="T:Quippe.Coding.CodeHint"/> may reference one or more codes, code ranges, or matching codes (via substring match) in an external 
 coding system vocabulary (e.g., some code set that is not MEDCIN, such as ICD-9-CM). Each such code, code range, or substring match template
 is represented as a <see cref="T:Quippe.Coding.CodeHintItem"/> in the CodeHint object. It may be useful to obtain reverse maps from each referenced external code to the mapped
 MEDCIN concepts. Once the reverse maps are obtained they can be added to the associated CodeHints object by calling the <see cref="M:Quippe.Coding.CodeHints.SetMaps(Quippe.Coding.MapManager)"/> method. The
 GetMapsByRange function can be used to return the collection of reverse maps that are associated with a specified code range,
 that is, have a source external code that falls in the range specified in the MinCode and MaxCode parameters.</para>
		<para>The function searches the existing collection of maps in this instance for maps that have a source code entry that falls in the
 range. The codes defining the range are assumed to be in the external vocabulary associated with this CodeHints instance.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeHints.GetMapsBySubstring(System.String)">
	<summary>
 Returns the maps managed by this CodeHints instance that have a source entry code that starts with the specified substring.
 </summary>
	<param name="Substring">The substring that desired codes in the external vocabulary must begin with to be included in the result collection.</param>
	<returns>Returns a <see cref="T:Quippe.Coding.MapManager"/> object containing those maps managed by this instance that reference the specified external code in the source code entry. Returns
 Nothing if this instance has no managed maps or if the specified Code is empty.</returns>
	<remarks>
		<para>A <see cref="T:Quippe.Coding.CodeHint"/> may reference one or more codes, code ranges, or matching codes (via substring match) in an external 
 coding system vocabulary (e.g., some code set that is not MEDCIN, such as ICD-9-CM). Each such code, code range, or substring match template
 is represented as a <see cref="T:Quippe.Coding.CodeHintItem"/> in the CodeHint object. It may be useful to obtain reverse maps from each referenced external code to the mapped
 MEDCIN concepts. Once the reverse maps are obtained they can be added to the associated CodeHints object by calling the <see cref="M:Quippe.Coding.CodeHints.SetMaps(Quippe.Coding.MapManager)"/> method. The
 GetMapsBySubstring function can be used to return the collection of reverse maps that are associated with a code that begins with the specified
 substring, that is, have a source external code that begins with the substring specified in the Substring parameter.</para>
		<para>The function searches the existing collection of maps in this instance for maps that have a source code entry that begins with the
 specified substring. The substring is assumed to apply to codes in the external vocabulary associated with this CodeHints instance.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeHints.GetHintText(Quippe.Coding.CodeHint.HintTypeEnum)">
	<summary>
 Returns the text of the first code hint (i.e., <see cref="T:Quippe.Coding.CodeHint"/> object) having the specified HintType.
 </summary>
	<param name="HintType">The type of hint to find.</param>
	<returns>Returns the hint text of the first hint found that has the specified HintType, or returns the
 empty string if no hint of that type exists.</returns>
	<remarks>
		<para>Normally a Medicomp code hints string will have at most one hint of each possible type, but if that is
 not the case, be aware that this method will return only the first hint of the specified type.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHintItem"/>
</member><member name="M:Quippe.Coding.CodeHints.InitHints(System.String)">
	<summary>
 Intializes the CodeHints object by parsing the specified hints string into individual code hints.
 </summary>
	<param name="TextHints">The hints string.</param>
</member><member name="M:Quippe.Coding.CodeHints.AddHints(System.Collections.Generic.List{System.String})">
	<summary>
 Creates a <see cref="T:Quippe.Coding.CodeHint"/> object for each hint string in the input list of string hints, and adds those objects to the hints collection.
 </summary>
	<param name="Hints">A list of code hint strings, each in the format, [$(text)$][(hint-type)(ref-codes)].</param>
	<returns>Returns an integer indicating the number of hint strings that were successfully parsed and added as CodeHint objects.</returns>
	<remarks><para>Each individual hint string in the list is hint string in the format, [$(text)$][(hint-type)(ref-codes)],
 where (text) is the textual part of the hint, (hint-type) is a two character code that identifies
 the hint type (e.g. "CF" for a "code first" hint), and (ref-codes) is a comma separated list of codes, codes ranges, or substring match templates referenced
 by the hint. The textual part of the hint string is enclosed in dollar signs ("$"). The reference part of the hint begins with a two character code 
 indicating the hint type, and then lists the referenced codes, code ranges, or substring templates in a comma-separated list.</para>
		<para>For example, "$This is a texual code; with a semi-colon$" is a valid Textual type hint string, and "CF123.45-123.49,234.56"
 is a valid reference type hint, that starts with the code for Code First (CF), and includes a code range followed by
 a single code. "$This is a texual code; with a semi-colon$CF123.45-123.49,234.56" is also a valid reference-style hint that has a textual part.</para>
		<para>A separate <see cref="T:Quippe.Coding.CodeHint"/> object is created from each hint and individual <see cref="T:Quippe.Coding.CodeHintItem"/> 
 objects are created and assigned to the hint for each code referenced in a reference hint.</para>
		<para>Hints are assigned to the <see cref="T:Quippe.Coding.ExternalCodeEntry"/> class instance representing the external code using the method, <see cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>, 
 when maps from MEDCIN to an external vocabulary are returned by a translation server that
 supports code hints.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeHints.ParseHints(System.String)">
	<summary>
 Parses the MEDCIN server hints string, containing multiple hints, into a list of separate hint strings.
 </summary>
	<param name="TextHints">The input MEDCIN server hints string, containing one or more string hints separated by semi-colons.</param>
	<returns>Returns a list of the individual hint strings contained in the input string. Returns Nothing if the input hints string
 is empty or the parse operation fails to obtain any valid hints.</returns>
	<remarks><para>The input MEDCIN server hints string contains one or more string hints separated by semi-colons. Each string hint has the format 
 [$(text)$][(hint-type)(ref-codes)], where (text) is the textual part of the hint, (hint-type) is a two character code that identifies
 the hint type (e.g. "CF" for a "code first" hint), and (ref-codes) is a comma separated list of codes, codes ranges or substring match templates
 referenced by the hint. This method parses the input string into a list of separate string hints in the above format.</para>
		<para>See <see cref="T:Quippe.Coding.CodeHint"/> for more information on code hints and the format of the code hint string. See <see cref="T:Quippe.Coding.CodeHint.HintTypeEnum"/>
 to learn about the different hint types and their associated two character codes.</para>
	</remarks>
</member><member name="T:Quippe.Coding.CodeHints">
	<summary>
 Class representing a collection of hints associated with a code.
 </summary>
	<remarks>
		<para>Certain external vocabularies, such as ICD-9-CM, may have hints associated with a code. The CodeHints class represents
 the collection of hints, i.e., <see cref="T:Quippe.Coding.CodeHint"/> objects, associated with a code in an external vocabulary, such as ICD-9-CM. 
 An ICD-9-CM code may have a single textual hint and one or more reference type hints that reference additional codes in the vocabulary. 
 An ICD-10-CM code may have multiple hints with both textual and reference parts. Hints are assigned to the
 <see cref="T:Quippe.Coding.ExternalCodeEntry"/> class instance representing the external code using the method, <see cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>, 
 when maps from MEDCIN to an external vocabulary are returned by a translation server that
 supports code hints.</para>
		<para>In Medicomp mapping data, all hints for a particular code are contained in a MEDCIN server hints string, which consists of
 multiple hints separated by semi-colons. Each individual hint in the string has the format, [$(text)$][(hint-type)(ref-codes)],
 where (text) is the textual part of the hint, (hint-type) is a two character code that identifies
 the hint type (e.g. "CF" for a "code first" hint), and (ref-codes) is a comma separated list of codes or codes ranges referenced by the hint. The textual part of
 the hint string is enclosed in dollar signs ("$") and may contain semi-colons. The reference part of the hint begins with a two character code indicating the hint type,
 and is followed by the referenced codes or code ranges in a comma-separated list. The hint must either have a text part, a reference part,
 or both. The text part always appears first. ICD-9-CM hints generally have a purely textual hint first, followed by reference-type hints,
 but ICD-10-CM hints are more general and each individual hint may have a text part followed by a reference part.</para>
		<para>For example, the following ICD-9-CM hints string contains two hints, a textual hint followed by a reference hint: 
 "$Use additional code to identify manifestation$;UA711.4,730.8,727.01". The reference hint is a "use additional code" hint, indicating that
 one additional code from the comma-separated list of referenced codes must be used to identify the manifestation associated with the original
 code with which the hints are associated. Likewise, a "code first" hint might reference a list of codes and/or code
 ranges, indicating that one of these codes must be coded first before the base code. An example ICD-10-CM hints string is:
 "$Use additional code for any associated drug resistance (Z16)$UAZ16;$Excludes1: carrier or suspected carrier of infectious disease (Z22.-);$E1Z22.+".
 This example includes two hints, each with a text part and a reference part. The referenced substring match template, "Z22.+", is equivalent to "Z22.-" 
 in the ID-10-CM documentation and represents the set of codes that start with the substring "Z22." (and are therefore in the subtree rooted at code "Z22").</para>
		<para>A separate <see cref="T:Quippe.Coding.CodeHint"/> object is
 created from each hint as the hints string is parsed and individual <see cref="T:Quippe.Coding.CodeHintItem"/> objects are created and assigned to the hint
 for each code referenced in a reference hint.</para>
		<para>If a code hint references 
 additional codes and/or code ranges, this class can store the reverse maps associated with those referenced codes. This
 allows a user to view the list of reference codes (e.g., those that must be coded first) and the reverse maps from those codes back to the
 mapped source concepts, which may be the input terminology (e.g., MEDCIN concepts).</para>
	</remarks>
	<para>See <see cref="T:Quippe.Coding.CodeHint"/> for more information on code hints and <see cref="T:Quippe.Coding.CodeHint.HintTypeEnum"/>
 to learn about the different hint types and their associated two character codes.</para>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeHintItem.#ctor(System.String)">
	<summary>
 Creates the item from a text string containing the single code value, a range of codes, or a substring match.
 </summary>
	<param name="CodeText">The text containing the code or code range.</param>
	<remarks>
		<para>A valid code range text string is a range specifiying the minimum code value, a dash character ("-"), 
 followed by the maximum code value (e.g., "123.45-123.49") and represents all codes in the range, inclusive. 
 A valid substring match specification is the beginning of a code followed by a plus sign ("+") (e.g., "A05.+"),
 which represents all codes that start with the substring "A05.".</para>
		<para>This method parses the string and sets the IsValid property. A complete check for
 syntactically legitimate codes is not performed. Only basic validity of a range is checked. Thus, a string 
 is considered invalid if it is empty or is a range or substring that does not have the format described above. The method
 also considers invalid a text string that is a single "-" or a single "+" (and "--").</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHint"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
</member><member name="M:Quippe.Coding.CodeHintItem.Clone">
	<summary>
 Returns a deep copy of this CodeHintItem instance.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeHint"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
</member><member name="M:Quippe.Coding.CodeHintItem.#ctor(Quippe.Coding.CodeHintItem)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The CodeHintItem instance to copy when creating a new instance.</param>
</member><member name="P:Quippe.Coding.CodeHintItem.IsRange">
	<summary>
 Indicates whether the item is a range of codes.
 </summary>
	<returns>Returns True, if the item is a range of codes, or False, if the item is an individual code or subtree.</returns>
	<remarks>
		<para>A reference-type hint, as a <see cref="T:Quippe.Coding.CodeHint"/> instance, that references a range of codes in its comma-separated list of code references would
 be parsed into a CodeHintItem that represents that range. For instance, the first reference in the ICD-9-CM code hint,
 "CF123.45-123.49,234.56", would be represented as a range in the associated CodeHintItem, and therefore its 
 <see cref="P:Quippe.Coding.CodeHintItem.IsRange"/> property would return True.
 </para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
</member><member name="P:Quippe.Coding.CodeHintItem.IsSubstring">
	<summary>
 Indicates whether the item specifies a template for a substring match, representing all codes that start with the specified substring.
 </summary>
	<returns>Returns True, if the item is a substring match, or False, if the item is an individual code or range.</returns>
	<remarks>
		<para>A reference-type hint, as a <see cref="T:Quippe.Coding.CodeHint"/> instance, that references a substring match template in its comma-separated list of code references would
 be parsed into a CodeHintItem that represents all codes that start with the specified substring. For instance, the first reference in the ICD-10-CM code hint,
 "E1A05.+,A18.32,Z22.+,O98.+,J00-J22", is interpreted as a substring match, "A05.+", which represents all codes that start with the substring "A05." 
 (e.g., "A05.0", "A05.1", etc.). When this substring match reference is parsed into a CodeHintItem object, the object's <see cref="P:Quippe.Coding.CodeHintItem.IsSubstring"/> property 
 would return True.
 </para>
		<para>Note, the substring match template is represented in the ICD-10-CM documentation using a hypen, "-", as in "A05.-", however, Medicomp uses the "+" sign
 to indicate a substring match, as in "A05.+".</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
</member><member name="P:Quippe.Coding.CodeHintItem.MinValue">
	<summary>
 Gets the minimum code value if the item is a range, the substring if the item is the template for a substring match, or the individual code value otherwise.
 </summary>
	<returns>Returns the minimum value of the item if the item represents a range of codes (<see cref="P:Quippe.Coding.CodeHintItem.IsRange"/> is True),
 returns the substring used to find matching codes if the item represents a substring match (<see cref="P:Quippe.Coding.CodeHintItem.IsSubstring"/> is True),
 otherwise returns the code value if this item represents a single code (<see cref="P:Quippe.Coding.CodeHintItem.IsRange"/> is False).</returns>
	<remarks>
		<para>If the item is a single code, then MinValue and <see cref="P:Quippe.Coding.CodeHintItem.MaxValue"/> both hold the individual code value. If the 
 item is a range, the MinValue property holds the minimum value in the range and MaxValue holds the maximum
 value. If the item is a substring match, the both MinValue and <see cref="P:Quippe.Coding.CodeHintItem.MaxValue"/> both hold the substring.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHint"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
</member><member name="P:Quippe.Coding.CodeHintItem.MaxValue">
	<summary>
 Gets the maximum code value if the item is a range, the substring if the item is the template for a substring match, or the individual code value otherwise.
 </summary>
	<returns>Returns the maximum value of the item if the item represents a range of codes (<see cref="P:Quippe.Coding.CodeHintItem.IsRange"/> is True), 
 returns the substring used to find matching codes if the item represents a substring match (<see cref="P:Quippe.Coding.CodeHintItem.IsSubstring"/> is True),
 or returns the code value if this item represents a single code (<see cref="P:Quippe.Coding.CodeHintItem.IsRange"/> is False).</returns>
	<remarks>
		<para>If the item is a single code, then MinValue and <see cref="P:Quippe.Coding.CodeHintItem.MaxValue"/> both hold the individual code value. If the 
 item is a range, the MinValue property holds the minimum value in the range and MaxValue holds the maximum
 value. If the item is a substring match, the both MinValue and <see cref="P:Quippe.Coding.CodeHintItem.MaxValue"/> both hold the substring.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHint"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
</member><member name="P:Quippe.Coding.CodeHintItem.IsValid">
	<summary>
 Indicates whether the item is valid.
 </summary>
	<returns>Returns True if the item is valid, otherwise, returns False if the item is invalid.</returns>
	<remarks>
		<para>The validity of the item is determined in the constructor when the item text is parsed. An item is invalid if the
 item text was empty or if the item represents a range of codes and the range was not valid (e.g., the minimum value
 was greater than the maximum value) or if the item represents a substring match and the substring template is not valid.
 </para>
		<para> A valid code range text string is the minimum code value, a dash character ("-"), followed by the maximum
 code value (e.g., "123.45-123.49"). A valid template for a substring match is the starting substring of a code followed by
 a plus sign ("+") (e.g., "A05.+").</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHint"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
</member><member name="M:Quippe.Coding.CodeHintItem.RefersTo(System.String)">
	<summary>
 Indicates whether this item refers to the specified external code.
 </summary>
	<param name="Code">The external code for which a reference is sought.</param>
	<returns>Returns True if the external code is referenced by this item, either directly or in a range,
 or False otherwise.</returns>
	<remarks>
		<para>If the item references a single code then RefersTo returns True if the specified code in the Code parameter
 exactly equals the referenced code value contained in the <see cref="P:Quippe.Coding.CodeHintItem.MinValue"/> and <see cref="P:Quippe.Coding.CodeHintItem.MaxValue"/> property. 
 If the item references a range of codes, then RefersTo returns True if the specified code in the Code parameter falls
 within the range, inclusive, of the minimum value in MinValue and maximum value in MaxValue. If the item references
 a substring match template then RefersTo returns True if the specified code in the Code parameter starts with the
 code in the substring template. A case-insensitive String comparison is used to determine equality of a single code, 
 containment in a range, or a substring match.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHint"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
</member><member name="T:Quippe.Coding.CodeHintItem">
	<summary>
 Class representing a single code, code range reference, or substring match template found in a code hint.
 </summary>
	<remarks>
		<para>A reference-type code hint (a <see cref="T:Quippe.Coding.CodeHint"/> object with a <see cref="T:Quippe.Coding.CodeHint.HintTypeEnum"/> value that is a reference type) may reference 
 one or more codes, code ranges, or substring match templates in the associated coding system vocabulary. When a reference-type code hint is parsed by the 
 associated CodeHint instance, a CodeHintItem is created for each referenced code, code range or substring template found in the hint.
 For instance, the hint, "$Use additional code to identify manifestation$;UA711.4,730.8,727.01" has a reference type hint, "UA711.4,730.8,727.01", which is of type 
 <see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.UseAdditionalCode"/>. This hint, when parsed, would cause three CodeHintItem objects to be created, one each for the referenced ICD-9-CM codes,
 711.4, 730.8 and 727.01. These are single codes and so would be represented as such in the CodeHintItem, that is, the <see cref="P:Quippe.Coding.CodeHintItem.IsRange"/> property would return False, and
 both <see cref="P:Quippe.Coding.CodeHintItem.MinValue"/> and <see cref="P:Quippe.Coding.CodeHintItem.MaxValue"/> would be equal. A code range, such as the first reference in this "code first" hint,
 "CF123.45-123.49,234.56", would be represented as a range in the associated CodeHintItem, and therefore the IsRange property would return True, MinValue would return "123.45", 
 and MaxValue, "123.49". A substring match template reference such as, "A05.+", which might occur in an ICD-10-CM hint, represents all codes starting with the substring "A05." 
 (e.g., "A05.0", "A05.1", etc.); the associated CodeHintItem for such a reference would return True for the <see cref="P:Quippe.Coding.CodeHintItem.IsRange"/> property and MinValue and MaxValue would
 return the substring "A05.".</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="F:Quippe.Coding.CodeHint.HintTypeEnum.Unspecified">
	<summary>Unspecified is the default value and indicates the hint string was not specified or was not parsed.</summary>
</member><member name="F:Quippe.Coding.CodeHint.HintTypeEnum.Textual">
	<summary>Indicates the hint is a textual hint, which should be the first hint, enclosed in '$' signs.</summary>
</member><member name="F:Quippe.Coding.CodeHint.HintTypeEnum.CodeFirst">
	<summary>Indicates this reference type hint is a code first hint (starts with "CF" followed by a comma-separated list of codes and/or code ranges).</summary>
</member><member name="F:Quippe.Coding.CodeHint.HintTypeEnum.UseAdditionalCode">
	<summary>Indicates this reference type hint is a use additional code hint (starts with "UA" followed by a comma-separated list of codes and/or code ranges).</summary>
</member><member name="F:Quippe.Coding.CodeHint.HintTypeEnum.MustCode">
	<summary>Indicates this reference type hint is a must code hint (starts with "MC" followed by a comma-separated list of codes and/or code ranges).</summary>
</member><member name="F:Quippe.Coding.CodeHint.HintTypeEnum.CompositeMeasure">
	<summary>Indicates this reference type hint is a composite measure hint (starts with "CM" followed by a comma-separated list of codes and/or code ranges).</summary>
</member><member name="F:Quippe.Coding.CodeHint.HintTypeEnum.CodeAlso">
	<summary>Indicates this reference type hint is a code also hint (starts with "CA" followed by a comma-separated list of codes and/or code ranges).</summary>
</member><member name="F:Quippe.Coding.CodeHint.HintTypeEnum.Excludes1">
	<summary>Indicates this reference type hint is an Excludes1 hint (starts with "E1" followed by a comma-separated list of codes and/or code ranges).</summary>
</member><member name="F:Quippe.Coding.CodeHint.HintTypeEnum.Unknown">
	<summary>Unknown indicates the hint text was specified and was at least partially parsed bu the hint type is unknown, e.g., because it did not follow the required format of any of the other hint types.</summary>
</member><member name="T:Quippe.Coding.CodeHint.HintTypeEnum">
	<summary>Provides enumerated values for each type of hint that is supported. A type is either a Textual type, a
 reference type hint (references additional codes and/or ranges) or is Unspecified or Unknown.</summary>
</member><member name="M:Quippe.Coding.CodeHint.#ctor(System.String,System.String)">
	<summary>
 Creates a new CodeHint object from the textual representation of the hint.
 </summary>
	<param name="Hint">The textual representation of the hint in the MEDCIN server format.</param>
	<param name="VocabCode">The unique code of the vocabulary assocaited with the code hint (e.g., ICD-9-CM or ICD-10-CM).</param>
	<remarks>
		<para>The hint string in the parameter, Hint, should have the format, [$(text)$][(hint-type)(ref-codes)],
 where (text) is the textual part of the hint, (hint-type) is a two character code that identifies
 the hint type (e.g. "CF" for a "code first" hint), and (ref-codes) is a comma separated list of codes, codes ranges, or substring match templates
 referenced by the hint. The textual part of the hint string is enclosed in dollar signs ("$") and may contain semi-colons. The reference part of
 the hint begins with a two character code indicating the hint type, and is followed by the referenced codes, code ranges, or substring matches
 in a comma-separated list. The hint must either have a text part, a reference part, or both. The text part always appears first. ICD-9-CM hints
 generally have a purely textual hint first, followed by reference-type hints, but ICD-10-CM hints are more general and each individual hint may
 have a text part followed by a reference part.</para>
		<para>For example, the following ICD-9-CM hints string contains two hints, a textual hint followed by a reference hint: 
 "$Use additional code to identify manifestation$;UA711.4,730.8,727.01". The reference hint is a "use additional code" hint, indicating that
 one additional code from the comma-separated list of referenced codes must be used to identify the manifestation associated with the original
 code with which the hints are associated. Likewise, a "code first" hint might reference a list of codes and/or code
 ranges, indicating that one of these codes must be coded first before the base code. An example ICD-10-CM hints string is:
 "$Use additional code for any associated drug resistance (Z16)$UAZ16;$Excludes1: carrier or suspected carrier of infectious disease (Z22.-);$E1Z22.+".
 This example includes two hints, each with a text part and a reference part. The referenced substring match template, "Z22.+", is equivalent to 
 "Z22.-" in the ICD-10-CM documentation and represents the set of codes in the subtree rooted at code "Z22" that start with "Z22.".</para>
		<para>The CodeHint object is created from the hint text and individual <see cref="T:Quippe.Coding.CodeHintItem"/> 
 objects are created and assigned to the hint for each referenced code, if the hint is a reference hint.</para>
	</remarks>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="M:Quippe.Coding.CodeHint.Clone">
	<summary>
 Returns a deep copy of this CodeHint instance.
 </summary>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="M:Quippe.Coding.CodeHint.#ctor(Quippe.Coding.CodeHint)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The CodeHint instance to copy when creating a new instance.</param>
</member><member name="P:Quippe.Coding.CodeHint.HintType">
	<summary>
 Gets or sets the hint type.
 </summary>
	<seealso cref="T:Quippe.Coding.CodeHintItem"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="P:Quippe.Coding.CodeHint.VocabCode">
	<summary>
 Gets the optional vocabulary code associated with the code hint.
 </summary>
	<remarks>The vocabulary code is assigned when the CodeHint instance is created using the appropriate constructor.</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
	<seealso cref="T:Quippe.Coding.VocabularyVersion"/>
</member><member name="P:Quippe.Coding.CodeHint.Text">
	<summary>
 Gets or sets the text part of the hint.
 </summary>
	<remarks>
		<para>This property merely sets the text part of the hint, overriding what may have been set when the full hint string was parsed.
 To parse the full hint text and automatically set the text part, obtain the hint type and set the collection of referenced
 CodeHintItem objects, use a constructor to create a new CodeHint object. The hint text can be parsed separately using the
 <see cref="M:Quippe.Coding.CodeHint.ParseHint(System.String,System.String@,Quippe.Coding.CodeHint.HintTypeEnum@,System.String@,System.Collections.Generic.List{Quippe.Coding.CodeHintItem}@)"/> shared method to obtain the referenced CodeHintItem objects.
 </para>
		<para>The Text property should contain a text string (without enclosing dollar signs). For instance, if the full hint string
 was "$This is a texual code; with a semi-colon$", the Text property would return the hint text without the dollar signs, i.e., 
 "This is a textual code; with a semi-colon", and the HintType property set to <see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.Textual"/>.</para>
		<para>If the full hint string also contains a reference part, then the Text property still only returns the text part and not 
 the comma-separated list of codes and/or code ranges in the reference part. For instance, if
 the full hint was "$This is a texual code; with a semi-colon$CF123.45-123.49,234.56", the Text property would still return
 "This is a textual code; with a semi-colon". Further, the list of referenced codes, i.e., "123.45-123.49,234.56" would be 
 returned by the <see cref="P:Quippe.Coding.CodeHint.ReferenceText"/> property and and the HintType property would return <see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.CodeFirst"/>.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="P:Quippe.Coding.CodeHint.ReferenceText">
	<summary>
 Gets the textual representation of the reference part of the hint, which contains the code references as a comma-separated list of codes.
 </summary>
	<remarks>
		<para>The ReferenceText property returns the comma-separated list of codes and/or code ranges contained in the reference part of the
 full hint. For instance, if the full hint was "$Text part$CF123.45-123.49,234.56", this property should return the list of referenced codes and code ranges,
 i.e., "123.45-123.49,234.56". Further, the <see cref="P:Quippe.Coding.CodeHint.Text"/> property would return "Text part" and the HintType property should return the hint type
 <see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.CodeFirst"/>.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="P:Quippe.Coding.CodeHint.CodeItems">
	<summary>
 Gets the collection of code hint items associated with a reference type hint.
 </summary>
	<remarks>
		<para>A <see cref="T:Quippe.Coding.CodeHintItem"/> represents either a single code or a code range referenced in a reference type hint.</para>
		<para>For example, "CF123.45-123.49,234.56" is a valid reference type hint that starts with the code for Code First (CF), and includes 
 a code range, "123.45-123.49" followed by a single code, "234.56". When this hint is parsed, two CodeHintItem objects
 will be created and added to the internal collection of code items, one for the range and another for the single code.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="P:Quippe.Coding.CodeHint.Maps">
	<summary>
 Gets the collection of reverse maps from codes referenced in the code hint to the concepts in the source vocabulary (e.g., MEDCIN).
 </summary>
	<returns>Returns a <see cref="T:Quippe.Coding.MapManager"/> object containing a collection of reverse maps, each one a map record from the external code set (e.g., ICD-9-CM) to 
 the source code set (e.g., MEDCIN).
 </returns>
	<remarks>
		<para>A <see cref="T:Quippe.Coding.CodeHint"/> object may reference one or more codes, code ranges, or matching codes (via substring match) in an external 
 coding system vocabulary (e.g., some code set that is not MEDCIN, such as ICD-9-CM). Each such code, code range, or substring match template
 is represented as a <see cref="T:Quippe.Coding.CodeHintItem"/> in the CodeHint object. It may be useful to obtain reverse maps from each referenced external code to the mapped
 MEDCIN concepts. Once the reverse maps are obtained they can be added to the associated CodeHints object by calling the <see cref="M:Quippe.Coding.CodeHint.AddMaps(Quippe.Coding.MapManager)"/> method. The
 Maps property can be used to return the collection of reverse maps that were added in this way.</para>
		<para>For example, if the original code in the target external vocabulary (e.g., ICD-9-CM) contains a CodeFirst (CF) hint (<see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.CodeFirst"/>),
 the hint will reference additional codes in the target vocabulary that must be coded before the original code. If the reverse maps are available for the
 referenced codes, the concepts in the input terminology (e.g., MEDCIN) could be obtained from them and displayed to the user so a selection
 could be made in the encounter to satisfy the code first requirement in the external target vocabulary.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="P:Quippe.Coding.CodeHint.HasMaps">
	<summary>
 Indicates whether this code hint has any maps in its internal map collection.
 </summary>
	<returns>Returns True if this code hint has at least one map in its internal collection of maps and False otherwise.</returns>
</member><member name="P:Quippe.Coding.CodeHint.IsValid">
	<summary>
 Indicates whether this code hint contains valid data
 </summary>
	<value>Returns True if the hint contains valid or useful data and False otherwise.</value>
	<remarks>The code hint is invalid if it does not contain any useful data, in other words, the hint is invalid if
 either the HintType is unspecified (<see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.Unspecified"/>) or if the HintType is unknown (<see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.Unknown"/>) 
 and the hint Text and ReferenceText are both empty. If the HintType
 is unknown and either Text or ReferenceText is not empty, the hint may still be of some use, therefore a hint of this type is considered
 valid.</remarks>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="M:Quippe.Coding.CodeHint.AddMaps(Quippe.Coding.MapManager)">
	<summary>
 Adds the specified maps to the collection of reverse maps associated with this hint.
 </summary>
	<param name="Maps">A <see cref="T:Quippe.Coding.MapManager"/> containing reverse maps (maps to MEDCIN) from external codes referenced in the hint text.</param>
	<returns>Returns an integer indicating the number of maps that were successfully added.</returns>
	<remarks>The specified maps to add are expected to be reverse maps from the external codes referenced in the hint text to the MEDCIN
 vocabulary. Thus, the method will only add a map if its target vocabulary is MEDCIN and its source code is one of the codes that is referenced
 in the hint text (e.g., matches a code, range, or substring specification in the hint's collection of associated <see cref="T:Quippe.Coding.CodeHintItem"/> objects.</remarks>
</member><member name="M:Quippe.Coding.CodeHint.AddMapEntry(Quippe.Coding.MapEntry)">
	<summary>
 Adds the specified map entry to the collection of reverse maps associated with this hint.
 </summary>
	<param name="Entry">A <see cref="T:Quippe.Coding.MapEntry"/> containing reverse maps (maps to MEDCIN) from external codes referenced in the hint text.</param>
	<returns>Returns True if the map entry was successfully added and False otherwise.</returns>
	<remarks>The specified map to add is expected to be a reverse map from an external code referenced in the hint text to the MEDCIN
 vocabulary. Thus, the method will only add the map if its target vocabulary is MEDCIN and its source code is one of the codes that is referenced
 in the hint text (e.g., matches a code, range, or substring specification in the hint's collection of associated <see cref="T:Quippe.Coding.CodeHintItem"/> objects.</remarks>
</member><member name="M:Quippe.Coding.CodeHint.RefersTo(System.String)">
	<summary>
 Indicates whether this hint refers to the specified external code.
 </summary>
	<param name="Code">The external code for which a reference is sought.</param>
	<returns>Returns True if the external code is referenced by this hint, either directly or in a range,
 or False otherwise.</returns>
	<remarks>
		<para>External codes are referenced in <see cref="T:Quippe.Coding.CodeHintItem"/> objects associated with a reference hint and accessed using
 the <see cref="P:Quippe.Coding.CodeHint.CodeItems"/> property.</para>
	</remarks>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="M:Quippe.Coding.CodeHint.GetMapsByCode(System.String)">
	<summary>
 Returns the maps managed by this CodeHint instance that have a source entry containing the specified code.
 </summary>
	<param name="Code">The code in the external vocabulary (e.g., ICD-9-CM) associated with this instance for which maps to the input terminology (e.g., MEDCIN) are desired.</param>
	<returns>Returns a <see cref="T:Quippe.Coding.MapManager"/> object containing those maps managed by this hint that reference the specified external code in the source code entry. Returns
 Nothing if this instance has no managed maps or if the specified Code is empty.</returns>
	<remarks>
		<para>A <see cref="T:Quippe.Coding.CodeHint"/> may reference one or more codes, code ranges, or matching codes (via substring match) in an external 
 coding system vocabulary (e.g., some code set that is not MEDCIN, such as ICD-9-CM). Each such code, code range, or substring match template
 is represented as a <see cref="T:Quippe.Coding.CodeHintItem"/> in the CodeHint object. It may be useful to obtain reverse maps from each referenced external code to the mapped
 MEDCIN concepts. Once the reverse maps are obtained they can be added to the associated CodeHints object. The
 GetMapsByCode function can be then be used to return the collection of reverse maps that are associated with the specified single code,
 that is, that have a source external code equal to that specified in the Code parameter.</para>
		<para>The function searches the existing collection of maps in this instance for maps that have the code as a source code entry. The code
 is assumed to be in the external vocabulary associated with this CodeHints instance. The maps would normally be the reverse maps from codes
 in an external vocabulary (e.g., ICD-9-CM) referenced in the hints to the concepts in the input terminology (e.g., MEDCIN).</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeHint.GetMapsByRange(System.String,System.String)">
	<summary>
 Returns the maps managed by this CodeHints instance that have a source entry code that falls in the specified range.
 </summary>
	<param name="MinCode">The minimum code value defining the inclusive range of desired codes in the external vocabulary.</param>
	<param name="MaxCode">The maximum code value defining the inclusive range of desired codes in the external vocabulary.</param>
	<returns>Returns a <see cref="T:Quippe.Coding.MapManager"/> object containing those maps managed by this hint that reference the specified external code in the source code entry. Returns
 Nothing if this instance has no managed maps or if the specified Code is empty.</returns>
	<remarks>
		<para>A <see cref="T:Quippe.Coding.CodeHint"/> may reference one or more codes, code ranges, or matching codes (via substring match) in an external 
 coding system vocabulary (e.g., some code set that is not MEDCIN, such as ICD-9-CM). Each such code, code range, or substring match template
 is represented as a <see cref="T:Quippe.Coding.CodeHintItem"/> in the CodeHint object. It may be useful to obtain reverse maps from each referenced external code to the mapped
 MEDCIN concepts. Once the reverse maps are obtained they can be added to the associated CodeHints object. The
 GetMapsByRange function can be used to return the collection of reverse maps that are associated with a specified code range,
 that is, have a source external code that falls in the range specified in the MinCode and MaxCode parameters.</para>
		<para>The function searches the existing collection of maps in this instance for maps that have a source code entry that falls in the
 range. The codes defining the range are assumed to be in the external vocabulary associated with this CodeHints instance.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeHint.GetMapsBySubstring(System.String)">
	<summary>
 Returns the maps managed by this CodeHints instance that have a source entry code that starts with the specified substring.
 </summary>
	<param name="Substring">The substring that desired codes in the external vocabulary must begin with to be included in the result collection.</param>
	<returns>Returns a <see cref="T:Quippe.Coding.MapManager"/> object containing those maps managed by this hint that reference the specified external code in the source code entry. Returns
 Nothing if this instance has no managed maps or if the specified Code is empty.</returns>
	<remarks>
		<para>A <see cref="T:Quippe.Coding.CodeHint"/> may reference one or more codes, code ranges, or matching codes (via substring match) in an external 
 coding system vocabulary (e.g., some code set that is not MEDCIN, such as ICD-9-CM). Each such code, code range, or substring match template
 is represented as a <see cref="T:Quippe.Coding.CodeHintItem"/> in the CodeHint object. It may be useful to obtain reverse maps from each referenced external code to the mapped
 MEDCIN concepts. Once the reverse maps are obtained they can be added to the associated CodeHints object. The
 GetMapsBySubstring function can be used to return the collection of reverse maps that are associated with a code that begins with the specified
 substring, that is, have a source external code that begins with the substring specified in the Substring parameter.</para>
		<para>The function searches the existing collection of maps in this instance for maps that have a source code entry that begins with the
 specified substring. The substring is assumed to apply to codes in the external vocabulary associated with this CodeHints instance.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.ExternalCodeEntry"/>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeHint.HintCodeToHintType(System.String)">
	<summary>
 Converts a string indicator of the hint type into its equivalent <see cref="T:Quippe.Coding.CodeHint.HintTypeEnum"/> value.
 </summary>
	<param name="HintCode">The string indicator of the hint type.</param>
	<returns>Returns the HintTypeEnum value that is equivalent to the string indicator. Returns <see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.Unknown"/>
 if the indicator string is not a recognized indicator.</returns>
	<remarks>The string indicator is obtained from the full hint string during parsing. This function is
 used to convert the parsed string indicator, which occurs at the beginning of the hint text, into its
 equivalent hint type.</remarks>
	<seealso cref="T:Quippe.Coding.CodeHintItem"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="M:Quippe.Coding.CodeHint.ParseReferenceText(System.String)">
	<summary>
 Parses the reference part of a hint string into its collection of referenced codes, ranges or substring match templates.
 </summary>
	<param name="ReferenceText">The reference part of a reference type hint which contains the referenced codes, code ranges, 
 and substrings, but without the initial two characters that indicates the type.</param>
	<returns>Returns a List of CodeHintItems found in the specified reference part of the hint text. Returns Nothing if the reference text
 is empty.</returns>
	<remarks><para>This function parses the comma-separated string of codes, code ranges, and substring match templates, and returns a 
 list of CodeHintItem objects, one for each single code, code range, or substring template found.</para>
		<para>For example, "CF123.45-123.49,234.56" is a valid ICD-9-CM reference type hint that starts with the code for Code First (CF), but only
 the comma-separate list of codes, "123.45-123.49,234.56", should be passed to this method in the input parameter. When this reference text 
 is parsed, two CodeItem objects will be created and returned in the collection of code items, one for the range and 
 another for the single code. Annother example is the following reference part of an ICD-10-CM hints string:
 "E1A05.+,A18.32,J00-J22,O98.+,Z22.+". When this reference text is parsed, five CodeItem objects will be created and returned in the collection
 of code items, one for the single code "A18.32", one for the range "J00-J22" and three for the substring templates, "A05.+", "O98.+", and "Z22.+".
 </para>
	</remarks>
	<seealso cref="M:Quippe.Coding.ExternalCodeEntry.SetHints(System.String)"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="M:Quippe.Coding.CodeHint.ParseHint(System.String,System.String@,Quippe.Coding.CodeHint.HintTypeEnum@,System.String@,System.Collections.Generic.List{Quippe.Coding.CodeHintItem}@)">
	<summary>
 Parses the full hint text string into its text part, hint type, reference part as a string, and the referenced codes or ranges as a list of CodeHintItem objects.
 </summary>
	<param name="FullHint">The full text of the MEDCIN server hint string that is to be parsed.</param>
	<param name="TextPart">Returns the textual part of the hint string that appears between dollar signs ("$"), if any.</param>
	<param name="HintType">Returns the hint type derived from the two-character code that appears between the textual part of the hint 
 and code reference part.</param>
	<param name="ReferencePart">Returns the code reference part of the hint as a String value.</param>
	<param name="ReferencedItems">Returns a list of <see cref="T:Quippe.Coding.CodeHintItem"/> objects corresponding to the parsed code 
 references in the reference part of the string, each one representing an individual code, code range, or substring match template.</param>
	<returns>Returns True if the parse was performed without error and False otherwise. If the function returns False, then there was 
 a problem with the input hint string in FullHint (e.g., it was empty, had only one "$" sign, was less than 3 character longs, etc.).
 However, if the HintType is not <see cref="F:Quippe.Coding.CodeHint.HintTypeEnum.Unspecified"/> and the TextPart or ReferencePart is not empty, then the hint
 may be useable.</returns>
	<remarks>
		<para></para>
		<para>The hint string in the parameter, FullHint, should have the format, [$(text)$][(hint-type)(ref-codes)],
 where (text) is the textual part of the hint, (hint-type) is a two character code that identifies
 the hint type (e.g. "CF" for a "code first" hint), and (ref-codes) is a comma separated list of codes, codes ranges, or substring match templates
 referenced by the hint. The textual part of the hint string is enclosed in dollar signs ("$") and may contain semi-colons. The reference part of
 the hint begins with a two character code indicating the hint type, and is followed by the referenced codes, code ranges, or substring matches
 in a comma-separated list. The hint must either have a text part, a reference part, or both. The text part always appears first. ICD-9-CM hints
 generally have a purely textual hint first, followed by reference-type hints, but ICD-10-CM hints are more general and each individual hint may
 have a text part followed by a reference part.</para>
		<para>For example, the following ICD-9-CM hints string contains two hints, a textual hint followed by a reference hint: 
 "$Use additional code to identify manifestation$;UA711.4,730.8,727.01". The reference hint is a "use additional code" hint, indicating that
 one additional code from the comma-separated list of referenced codes must be used to identify the manifestation associated with the original
 code with which the hints are associated. Likewise, a "code first" hint might reference a list of codes and/or code
 ranges, indicating that one of these codes must be coded first before the base code. An example ICD-10-CM hints string is:
 "$Use additional code for any associated drug resistance (Z16)$UAZ16;$Excludes1: carrier or suspected carrier of infectious disease (Z22.-);$E1Z22.+".
 This example includes two hints, each with a text part and a reference part. The referenced substring match template, "Z22.+", is equivalent to 
 "Z22.-" in the ICD-10-CM documentation and represents the set of codes in the subtree rooted at code "Z22" that start with "Z22.".</para>
	</remarks>
</member><member name="M:Quippe.Coding.CodeHint.HintTypeHasCodes(Quippe.Coding.CodeHint.HintTypeEnum)">
	<summary>
 Function that determines if a specified <see cref="T:Quippe.Coding.CodeHint.HintTypeEnum"/> value is a reference hint type, that is, a hint type
 that has referenced codes and code ranges in its hint text.
 </summary>
	<param name="aHintType">The hint type.</param>
	<returns>Returns True, if the hint type is a reference type and False otherwise.</returns>
	<remarks><para>External codes are referenced in <see cref="T:Quippe.Coding.CodeHintItem"/> objects associated with a reference hint and accessed using
 the <see cref="P:Quippe.Coding.CodeHint.CodeItems"/> property.</para></remarks>
	<seealso cref="P:Quippe.Coding.ExternalCodeEntry.Hints"/>
	<seealso cref="T:Quippe.Coding.CodeHints"/>
</member><member name="T:Quippe.Coding.CodeHint">
	<summary>
 Class representing a single code hint associated with a specific code in a coding system vocabulary.
 </summary>
	<remarks>
		<para>A code hint may be associated with a specific code in a coding system vocabulary that provides instructional
 notations with the codes, such as ICD-9-CM or ICD-10-CM. A hint provides additional information or instructions to 
 assist the coder in selecting the required codes for a given encounter entry.</para>
		<para>Hints are represented as CodeHint objects in the Coding Service. A hint may be one of several types as defined
 in <see cref="T:Quippe.Coding.CodeHint.HintTypeEnum"/>. A code hint may contain both a purely textual part and a part that references 
 additional codes, code ranges, or substring match templates. Each referenced code or code range in the reference part of the hint
 is represented by a <see cref="T:Quippe.Coding.CodeHintItem"/> object. This class maintains a collection of the code items referenced in the hint as 
 well as the original string representations of the text and reference parts of the hint.</para>
		<para>Note, a single code in a coding system vocabulary may have multiple code hints. A hints string associated with a code in
 an external coding system is obtained when maps from MEDCIN to an external vocabulary are returned by a translation server that
 supports code hints. The hints string is parsed into separate CodeHint objects, which are stored in a collection in a 
 <see cref="T:Quippe.Coding.CodeHints"/> object in the <see cref="T:Quippe.Coding.ExternalCodeEntry"/> class instance associated with the external code.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeEntry.#ctor">
	<summary>
 Constructs a new CodeEntry instance.
 </summary>
	<remarks>This is the default constructor.</remarks>
</member><member name="M:Quippe.Coding.CodeEntry.#ctor(Quippe.Coding.CodeSet,System.String,System.String,Quippe.Coding.TermType)">
	<summary>
 Constructs a new CodeEntry instance from specified property values.
 </summary>
	<param name="CodeSet">Defines the coding system vocabulary of the code entry to construct.</param>
	<param name="Code">The Code is the vocabulary-specific unique identifier of the clinical concept within the coding system vocabulary defined by the CodeSet parameter.</param>
	<param name="Description">The description of the concept associated with the code.</param>
	<param name="TermType">The term type defining the type or domain of the concept.</param>
	<remarks></remarks>
</member><member name="M:Quippe.Coding.CodeEntry.Clone">
	<summary>
 Function a derived class must override to returns a deep copy of the instance.
 </summary>
</member><member name="M:Quippe.Coding.CodeEntry.#ctor(Quippe.Coding.CodeEntry)">
	<summary>
 Copy constructor used for cloning.
 </summary>
	<param name="Other">The CodeEntry instance to copy when creating a new instance.</param>
</member><member name="P:Quippe.Coding.CodeEntry.CodeSet">
	<summary>
 Gets or sets the CodeSet to which this CodeEntry belongs.
 </summary>
	<remarks>
		<para>The CodeSet defines the coding system vocabulary associated with this code entry. The vocabulary is defined by
 a vocabulary code and an optional version. The CodeSet for a given coding system can be created from its associated
 <see cref="T:Quippe.Coding.Vocabulary"/> instance. All standard vocabularies are available from the <see cref="T:Quippe.Coding.Vocabularies"/> class.</para>
	</remarks>
</member><member name="P:Quippe.Coding.CodeEntry.Code">
	<summary>
 Gets or sets the unique String value of the code that identifies the associated clinical concept this CodeEntry represents.
 </summary>
	<remarks>The Code is the vocabulary-specific unique identifier of the clinical concept within the coding system vocabulary defined by the CodeSet property.</remarks>
	<seealso cref="P:Quippe.Coding.CodeEntry.CodeSet"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodeEntry.HasCode">
	<summary>
 Indicates whether the Code property of this CodeEntry has been specified.
 </summary>
	<returns>Returns True if the Code property returns a non-empty string and False otherwise.</returns>
	<seealso cref="P:Quippe.Coding.CodeEntry.CodeSet"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodeEntry.TermTypeName">
	<summary>
 Gets the name of the term type of this CodeEntry. 
 </summary>
	<returns>Returns the string name of the associated term type, if the term type property is defined
 (i.e., is not Nothing), otherwise returns the empty string.</returns>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodeEntry.TermTypeDisplayName">
	<summary>
 Gets the display name of the term type associated with this CodeEntry, if one exists.
 </summary>
	<returns>Returns the string display name of the associated term type, if the <see cref="P:Quippe.Coding.CodeEntry.TermType"/> property is defined
 (i.e., is not Nothing), otherwise returns the empty string.</returns>
	<remarks>
		<para>Certain coding vocabularies, use term types to define the type or domain of the concept. 
 For instance, the RxNorm vocabulary has term types for ingredients (IN), semantic clinical drugs (SCD), semantic clinical drug
 forms (SCDF), and so on. The term types associated with a vocabulary can be accessed from the property,
 <see cref="P:Quippe.Coding.Vocabulary.TermTypes"/></para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodeEntry.TermType">
	<summary>
 Gets or sets the optional term type associated with this code entry.
 </summary>
	<remarks>
		<para>Certain coding vocabularies, use term types to define the type or domain of the concept. 
 For instance, the RxNorm vocabulary has term types for ingredients (IN), semantic clinical drugs (SCD), semantic clinical drug
 forms (SCDF), and so on. The term types associated with a vocabulary can be accessed from the property,
 <see cref="P:Quippe.Coding.Vocabulary.TermTypes"/></para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="P:Quippe.Coding.CodeEntry.Description">
	<summary>
 Gets or sets the text description associated with this CodeEntry.
 </summary>
	<remarks>
		<para>The description will usually be the concept description associated with the Code in the coding system defined by the 
 <see cref="P:Quippe.Coding.CodeEntry.CodeSet"/>.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeEntry.ToString">
	<summary>
 Returns the String representation of this CodeEntry. This default implementation returns
 a String consisting of the <see cref="P:Quippe.Coding.CodeEntry.CodeSet"/> name followed by the optional term type name and then the code.
 </summary>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="M:Quippe.Coding.CodeEntry.CompareTo(Quippe.Coding.ICodeEntry)">
	<summary>
 Compares this CodeEntry with another specified CodeEntry.
 </summary>
	<param name="other">A CodeEntry to compare with this CodeEntry.</param>
	<returns>Returns a signed integer that indicates the relative ordering of this CodeEntry instance and the instance in the Other
 parameter. If this instance is less than Other, this function returns a negative integer. If this instance equals Other, this function 
 returns 0. If this instance is greater than Other, this function returns a positive integer.</returns>
	<seealso cref="P:Quippe.Coding.CodeEntry.CodeSet"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member><member name="T:Quippe.Coding.CodeEntry">
	<summary>
 Base class for representing a clinical concept within a specific coding vocabulary as a coded entry.
 </summary>
	<remarks>
		<para>A CodeEntry is defined by specifying the properties of the coding vocabulary (as a <see cref="T:Quippe.Coding.CodeSet"/> object) and
 a unique string Code representing the clinical concept within the specified vocabulary. Additional properties
 may be specified, including a description of the clinical concept and a term type.</para>
	</remarks>
	<seealso cref="T:Quippe.Coding.TermType"/>
	<seealso cref="T:Quippe.Coding.Vocabulary"/>
</member>
</members>
</doc>